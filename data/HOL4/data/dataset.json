["\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2282 s2 \u21d4 s1 \u2286 s2 \u2227 \u00ac(s2 \u2286 s1)", "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d4 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n", "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f (MAP g l) = MAP (f \u2218 g) l", "(x :\u03b1) \u2208 RDOM ((R :\u03b1 -> \u03b2 -> bool) \\\\ (k :\u03b1)) \u21d4 x \u2208 RDOM R \u2227 x \u2260 k", "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 antisymmetric R", "\u2200(P :\u03b1 option -> bool). (\u2200(a :\u03b1). P (SOME a)) \u2227 P (NONE :\u03b1 option) \u21d2 \u2200(x :\u03b1 option). P x", "PROD_SET (\u2205 :num -> bool) = (1 :num)", "(p :bool) \u2227 (q :bool) \u21d2 p", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). WFP R x \u21d2 P x", "\u2200(t :bool). t \u2227 T \u21d4 t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s DIFF t \u21d4 x \u2208 s \u2227 x \u2209 t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s DELETE x) \u2229 t = s \u2229 t DELETE x", "\u2200(a :\u03b1 -> bool) (b :\u03b1 -> bool) (c :\u03b2 -> bool) (d :\u03b2 -> bool). a \u2286 b \u2227 c \u2286 d \u21d2 a \u00d7 c \u2286 b \u00d7 d", "\u2200(s :\u03b1 -> bool) (n :num). s HAS_SIZE n \u21d2 CARD s = n", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 option) (y :\u03b2). OPTION_MAP f x = SOME y \u21d4 \u2203(z :\u03b1). x = SOME z \u2227 y = f z", "\u2200(x :num -> \u03b1 -> bool) (y :num -> \u03b1 -> bool). mk_rec x = mk_rec y \u21d2 ZRECSPACE x \u2227 ZRECSPACE y \u21d2 x = y", "((p :bool) \u21d4 (q :bool) \u2228 (r :bool)) \u21d4 (p \u2228 \u00acq) \u2227 (p \u2228 \u00acr) \u2227 (q \u2228 r \u2228 \u00acp)", "\u2200(s :\u03b1 -> bool). (\u2203(f :num -> \u03b1). BIJ f \ud835\udd4c(:num) s) \u21d4 BIJ (enumerate s) \ud835\udd4c(:num) s", "LENGTH (TAKE (n :num) (xs :\u03b1 list)) = if n \u2264 LENGTH xs then n else LENGTH xs", "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z) \u21d2 \u2200(x :\u03b1 list) (y :\u03b1 list) (z :\u03b1 list). LIST_REL R x y \u2227 LIST_REL R y z \u21d2 LIST_REL R x z", "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 = h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l2 \u21d2 h1::l1 = h2::l2", "($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool)) \u21d4 s = \ud835\udd4c(:\u03b1)", "\u2200(n :num). count (SUC n) = n INSERT count n", "\u2200(xs :\u03b1 list) (x :\u03b1) (y :\u03b1) (ys :\u03b1 list). LUPDATE x (LENGTH xs) (xs ++ y::ys) = xs ++ x::ys", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s \u222a t) = PREIMAGE f s \u222a PREIMAGE f t", "\u2200(l :\u03b1 list) (m :num). m = LENGTH l \u21d2 TAKE m l = l", "\u2200(s :\u03b1 -> bool). s \u2286 s", "(f :\u03b4 -> \u03b3) \u2218 UNCURRY (g :\u03b1 -> \u03b2 -> \u03b4) = UNCURRY (($o f :(\u03b2 -> \u03b4) -> \u03b2 -> \u03b3) \u2218 g)", "\u2200(t :bool). F \u21d2 t \u21d4 T", "\u2200(s :num -> bool). s \u2260 (\u2205 :num -> bool) \u2227 FINITE s \u21d2 MIN_SET s \u2264 MAX_SET s", "\u2200(s :\u03b1 -> bool). SURJ (\u03bb(x :\u03b1). x) s s", "\u2200(x :\u03b1 -> bool). BIGUNION {x} = x", "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2) (s :\u03b1 -> bool). IMAGE (f \u2218 g) s = IMAGE f (IMAGE g s)", "\u2200(R1 :\u03b1 -> \u03b2 -> bool) (R2 :\u03b1 -> \u03b2 -> bool). R1 \u2286\u1d63 R2 \u2227 R2 \u2286\u1d63 R1 \u21d2 R1 = R2", "$! (UNCURRY (\u03bb(x :\u03b1). (P :\u03b1 -> \u03b2 -> bool) x)) \u21d4 \u2200(x :\u03b1). $! (P x)", "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). (y INSERT s) x \u21d4 x = y \u2228 x \u2208 s", "\u2200(l :\u03b1 list) (x :\u03b1). BUTLASTN (LENGTH l) (x::l) = [x]", "SING ((x :\u03b1) INSERT (s :\u03b1 -> bool)) \u21d4 s = (\u2205 :\u03b1 -> bool) \u2228 s = {x}", "\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)", "\u2200(P :\u03b1 -> \u03b2 -> bool) (Q :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list). (\u2200(x :\u03b1 # \u03b2). MEM x (ZIP (l1,l2)) \u2227 UNCURRY P x \u21d2 UNCURRY Q x) \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL Q l1 l2", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P (REVERSE l) \u21d4 EXISTS P l", "(l1 :\u03b1 list) ++ (l2 :\u03b1 list) = (h :\u03b1)::(t :\u03b1 list) \u21d4 l1 = ([] :\u03b1 list) \u2227 l2 = h::t \u2228 \u2203(lt :\u03b1 list). l1 = h::lt \u2227 t = lt ++ l2", "(([] :\u03b1 list) \u227c (l :\u03b1 list) \u21d4 T) \u2227 ((h :\u03b1)::(t :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 F) \u2227 ((h1 :\u03b1)::(t1 :\u03b1 list) \u227c (h2 :\u03b1)::(t2 :\u03b1 list) \u21d4 h1 = h2 \u2227 t1 \u227c t2)", "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 \u00acA \u21d2 \u00acB \u21d2 F", "\u2200(f :\u03b1 -> bool) (l :\u03b1 list). FILTER f (FILTER f l) = FILTER f l", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR $\\/ F (MAP P l)", "\u2200(R :\u03b1 -> \u03b1 -> bool). irreflexive R \u2227 transitive R \u21d2 antisymmetric R", "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 s \u222a t) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u222a s", "countable \ud835\udd4c(:num)", "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c c \u21d2 a \u227c c", "\u2200(r1 :\u03b1 -> \u03b2 option) (r2 :\u03b1 -> \u03b2 option) (rows1 :(\u03b1 -> \u03b2 option) list) (rows2 :(\u03b1 -> \u03b2 option) list) (rows3 :(\u03b1 -> \u03b2 option) list) (v :\u03b1). (IS_SOME (r2 v) \u21d2 IS_SOME (r1 v)) \u21d2 PMATCH v (rows1 ++ r1::rows2 ++ r2::rows3) = PMATCH v (rows1 ++ r1::rows2 ++ rows3)", "INVOL (relinv :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "\u2200(p :\u03b1 -> \u03b2) (g :\u03b1 -> bool) (i :\u03b2). (\u2200(x1 :\u03b1) (x2 :\u03b1). g x1 \u2227 g x2 \u2227 p x1 = p x2 \u21d2 x1 = x2) \u21d2 \u2200(x :\u03b1). PMATCH_ROW_COND p g i x \u21d2 (@(y :\u03b1). PMATCH_ROW_COND p g i y) = x", "\u2200(f :num -> \u03b1) (s :num -> bool). countable (IMAGE f s)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (l :\u03b2 list). LENGTH (SCANL f e l) = SUC (LENGTH l)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). REST s x \u21d4 x \u2208 s \u2227 x \u2260 CHOICE s", "(\u2200(x :\u03b1) (y :\u03b1). (R1 :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b1 -> bool) x y) \u2227 (\u2200(x :\u03b2) (y :\u03b2). (R3 :\u03b2 -> \u03b2 -> bool) x y \u21d2 (R4 :\u03b2 -> \u03b2 -> bool) x y) \u21d2 (R1 LEX R3) (x :\u03b1 # \u03b2) (y :\u03b1 # \u03b2) \u21d2 (R2 LEX R4) x y", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2282 s \u21d2 FINITE t", "\u2200(r :\u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). r \u2286 s \u21d2 r DIFF s \u2229 t = r DIFF t", "\u2200(R :\u03b2 -> \u03b2 -> bool) (f :\u03b1 -> \u03b2) (x :\u03b1) (y :\u03b1). inv_image R f x y \u21d4 R (f x) (f y)", "COMPL ((s :\u03b1 -> bool) \u222a (t :\u03b1 -> bool)) = COMPL s \u2229 COMPL t", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). (s DELETE y) x \u21d4 x \u2208 s \u2227 x \u2260 y", "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). y \u2208 IMAGE f s \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s", "(x :\u03b1) \u2208 RDOM (R :\u03b1 -> \u03b2 -> bool) \u21d4 \u2203(y :\u03b2). R x y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 R\u207a x y", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (P :\u03b1 -> bool) (P' :\u03b1 -> bool). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EVERY P l1 \u21d4 EVERY P' l2)", "\u2200(m :num) (n :num). m < n \u21d2 EL m (COUNT_LIST n) = m", "\u2200(c :bool) (x :bool). (if c then T else x) \u21d4 \u00acc \u21d2 x", "TAKE (0 :num) (l :\u03b1 list) = ([] :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e [x] = f x e", "\u2200(l :\u03b1 list). DROP (LENGTH l) l = ([] :\u03b1 list)", "\u2200(e :\u03b1) (s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 s1 \u2286 e INSERT s2", "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(t :\u03b1 list). P t \u21d2 \u2200(h :\u03b1). P (h::t)) \u21d2 \u2200(l :\u03b1 list). P l", "\u00acT \u21d4 F", "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R\u207a x y \u2227 R y z", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2282 t \u2227 t \u2286 u \u21d2 s \u2282 u", "RC ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (\u00acy \u21d2 x \u21d2 x') \u2227 (\u00acx' \u21d2 y \u21d2 y') \u21d2 x \u2228 y \u21d2 x' \u2228 y'", "\u2200(e :\u03b1) (s :\u03b1 -> bool). POW (e INSERT s) = IMAGE ($INSERT e) (POW s) \u222a POW s", "\u2200(s :\u03b1 -> bool). s DIFF s = (\u2205 :\u03b1 -> bool)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x' \u21d2 x) \u2227 (x' \u21d2 y \u21d2 y') \u21d2 (x \u21d2 y) \u21d2 x' \u21d2 y'", "\u2200(x :\u03b1) (l :\u03b1 list). REVERSE (SNOC x l) = x::REVERSE l", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u21d2 OPTION_ALL P (opt :\u03b1 option) \u21d2 OPTION_ALL P' opt", "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 (\u03bb(x :\u03b1). P x) \u21d4 P x", "(tri (n :num) = (0 :num) \u21d4 n = (0 :num)) \u2227 ((0 :num) = tri n \u21d4 n = (0 :num))", "REVERSE ([] :\u03b2 list) = ([] :\u03b2 list) \u2227 \u2200(x :\u03b1) (l :\u03b1 list). REVERSE (x::l) = SNOC x (REVERSE l)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). \u00acNULL l1 \u21d2 ELL (LENGTH l2) (l1 ++ l2) = LAST l1", "\u2200(x :\u03b1) (l :\u03b1 list). LENGTH (SNOC x l) = SUC (LENGTH l)", "(\u2200(f :\u03b1 -> \u03b2 -> \u03b3). MAP2 f ([] :\u03b1 list) ([] :\u03b2 list) = ([] :\u03b3 list)) \u2227 \u2200(f :\u03b4 -> \u03b5 -> \u03b6) (h1 :\u03b4) (t1 :\u03b4 list) (h2 :\u03b5) (t2 :\u03b5 list). MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2", "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2) (x :\u03b1). f \u2208 FUNSET s t \u2227 x \u2208 s \u21d2 f x \u2208 t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u222a t = t", "RC (R :\u03b1 -> \u03b1 -> bool) = R \u222a\u1d63 ($= :\u03b1 -> \u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). UNCURRY f = (\u03bb(x :\u03b1 # \u03b2). f (FST x) (SND x))", "\u2200(l :bool list). OR_EL l \u21d4 FOLDR $\\/ F l", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). LENGTH l1 = LENGTH l2 \u2227 (\u2200(x :num). x < LENGTH l1 \u21d2 EL x l1 = EL x l2) \u21d2 l1 = l2", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 x INSERT s = s", "\u2200(P :num -> bool) (Q :num -> bool). FINITE P \u2227 (P = (\u2205 :num -> bool) \u21d2 Q (0 :num)) \u2227 (\u2200(x :num). (\u2200(y :num). y \u2208 P \u21d2 y \u2264 x) \u2227 x \u2208 P \u21d2 Q x) \u21d2 Q (MAX_SET P)", "\u2200(e :\u03b1) (l :\u03b1 list). MEM (LAST (e::l)) (e::l)", "\u2200(R :\u03b1 -> \u03b1 -> bool). R\ua673 \ua673 = R\ua673", "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 \u00acq", "\u2200(n :num) (ls :\u03b1 list). n < LENGTH ls \u21d2 LUPDATE (EL n ls) n ls = ls", "\u2200(y :bool) (x :bool). ASM_MARKER y x \u21d4 x", "\u2200(x :num) (l :num list). SUM (SNOC x l) = SUM l + x", "\u2200(R :\u03b1 -> \u03b1 -> bool). StrongOrder R \u21d2 STRORD (RC R) = R", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). (\u2200(n :num). n < LENGTH l1 \u2227 (R :\u03b1 -> \u03b1 -> bool) (EL n l1) (EL n l2) \u2227 R (EL n l2) (EL n l3) \u21d2 R (EL n l1) (EL n l3)) \u2227 LIST_REL R l1 l2 \u2227 LIST_REL R l2 l3 \u21d2 LIST_REL R l1 l3", "\u2200(P :\u03b1 -> \u03b2) (v :\u03b3). P (PMATCH v ([] :(\u03b3 -> \u03b1 option) list)) = P (ARB :\u03b1)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 \u2203(x :\u03b1). x \u2208 s \u2227 x \u2209 t", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (n :num). n < LENGTH rows \u2227 IS_SOME (EL n rows v) \u21d2 PMATCH v rows = PMATCH v (TAKE (SUC n) rows)", "\u2200(f :\u03b1 -> \u03b2) (ls :\u03b1 list). ALL_DISTINCT (MAP f ls) \u21d2 ALL_DISTINCT ls", "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(h1 :\u03b2) (h2 :\u03b2) (t :\u03b2 list). LAST (h1::h2::t) = LAST (h2::t)", "\u2200(s :\u03b1 -> bool). FINITE (REST s) \u21d4 FINITE s", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (\u00acy \u21d2 x' \u21d2 x) \u2227 (\u00acx' \u21d2 y' \u21d2 y) \u21d2 x' \u2228 y' \u21d2 x \u2228 y", "PMATCH_ROW_COND (pat :\u03b1 -> \u03b2) (guard :\u03b1 -> bool) (inp :\u03b2) (v :\u03b1) \u21d4 inp = pat v \u2227 guard v", "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T l", "(0 :num) < (n :num) \u21d2 TAKE n ((x :\u03b1)::(xs :\u03b1 list)) = x::TAKE (n \u2212 (1 :num)) xs", "COUNT_LIST (0 :num) = ([] :num list) \u2227 \u2200(n :num). COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)", "\u2200(x :\u03b1) (l :\u03b1 list). ([] :\u03b1 list) \u2260 SNOC x l", "IDEM (RTC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "\u2200(v_old :\u03b1) (v_new :\u03b2). PMATCH v_old ([] :(\u03b1 -> \u03b3 option) list) = PMATCH v_new ([] :(\u03b2 -> \u03b3 option) list)", "OPTION_GUARD (b :bool) = if b then SOME () else (NONE :unit option)", "(\u2200(opt :\u03b1 option). (P :\u03b1 option -> bool) opt) \u21d4 P (NONE :\u03b1 option) \u2227 \u2200(x :\u03b1). P (SOME x)", "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x INSERT y INSERT s = y INSERT x INSERT s", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u2227 FINITE s \u21d2 FINITE t", "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) DIFF s = (\u2205 :\u03b1 -> bool)", "\u2200(M :\u03b1 list) (N :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = N \u2227 (\u2200(x :\u03b1). MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N", "\u2200(m :num) (l :\u03b1 list). m \u2264 LENGTH l \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 \u2200(f :\u03b1 -> \u03b2). IMAGE f s \u2286 IMAGE f t", "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). SURJ f s t) \u21d2 \u2203(g :\u03b2 -> \u03b1). INJ g t s", "\u2200(f :num -> \u03b1) (n :num). LENGTH (GENLIST f n) = n", "IDEM (TC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b1 -> \u03b1). ASSOC f \u21d2 \u2200(e :\u03b1). LEFT_ID f e \u21d2 \u2200(l :\u03b1 list list). FOLDR f e (FLAT l) = FOLDR f e (MAP (FOLDR f e) l)", "\u2200(l :\u03b1 list). IS_SUFFIX l l", "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 \u2260 h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). h1::l1 \u2260 h2::l2", "\u2200(P :\u03b2 -> bool) (f :\u03b1 -> \u03b2) (l :\u03b1 list). EVERY P (MAP f l) \u21d4 EVERY (\u03bb(x :\u03b1). P (f x)) l", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (n :num) (x :\u03b1). LENGTH l1 \u2264 n \u21d2 LUPDATE x n (l1 ++ l2) = l1 ++ LUPDATE x (n \u2212 LENGTH l1) l2", "{x | (P :\u03b1 -> bool) x} = P", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). x INSERT s \u2286 t \u21d4 x \u2208 t \u2227 s \u2286 t", "\u2200(t :bool). t \u21d2 T", "(\u2200(x :\u03b1) (y :\u03b2). (R1 :\u03b1 -> \u03b2 -> bool) x y \u21d2 (R2 :\u03b2 -> \u03b1 -> bool) y x) \u21d2 \u2200(x :\u03b1 list) (y :\u03b2 list). LIST_REL R1 x y \u21d2 LIST_REL R2 y x", "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 ELL (0 :num) l = LAST l", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (i :num). i < LENGTH rows \u21d2 (EL i (STRONGEST_REDUNDANT_ROWS_INFO v rows) \u21d4 EVERY (\u03bb(r :\u03b1 -> \u03b2 option). r v = (NONE :\u03b2 option)) (TAKE i rows) \u21d2 EL i rows v = (NONE :\u03b2 option))", "UNCURRY (f :\u03b1 -> \u03b2 -> \u03b3) = UNCURRY (g :\u03b1 -> \u03b2 -> \u03b3) \u21d4 f = g", "PMATCH_ROW_COND_NOT_EX_OR_EQ (i :\u03b1) (r :\u03b1 -> \u03b2 option) ([] :(\u03b1 -> \u03b2 option) list) \u21d4 r i \u2260 (NONE :\u03b2 option) \u21d2 F", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2229 u \u21d4 s \u2286 t \u2227 s \u2286 u", "\u2200(P :\u03b1 -> bool) (v :\u03b2) (rows :(\u03b2 -> \u03b1 option) list). P (PMATCH v rows) \u21d4 PMATCH_EXPAND_PRED P v ([] :(\u03b2 -> \u03b1 option) list) rows", "nsnd (0 :num) = (0 :num)", "\u2200(l :\u03b1 list) (m :num). m = LENGTH l \u21d2 DROP m l = ([] :\u03b1 list)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u2227 (\u2200(y :\u03b1). y \u2208 s \u21d2 x = y) \u21d4 s = {x}", "(\u2203(p :\u03b1 # \u03b2). (P :\u03b1 -> \u03b2 -> bool) (FST p) (SND p)) \u21d4 \u2203(p1 :\u03b1) (p2 :\u03b2). P p1 p2", "([] :\u03b1 list) \u2208 common_prefixes (s :\u03b1 list -> bool)", "\u2200(P :\u03b2 -> bool) (f :\u03b1 -> \u03b2) (l :\u03b1 list). EXISTS P (MAP f l) \u21d4 EXISTS (\u03bb(x :\u03b1). P (f x)) l", "\u2200(x :\u03b1). (NONE :\u03b1 option) \u2260 SOME x", "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (y :\u03b1) (z :\u03b1). R y z \u21d2 RESTRICT f R z y = f y", "\u2200(x :\u03b1) (y :\u03b1). SOME x = SOME y \u21d4 x = y", "\u2200(s :\u03b1 -> bool). DISJOINT (\u2205 :\u03b1 -> bool) s \u2227 DISJOINT s (\u2205 :\u03b1 -> bool)", "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a (t DIFF s) = s \u222a t) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t DIFF s \u222a s = t \u222a s", "DATATYPE ((option :\u03b1 option -> (\u03b1 -> \u03b1 option) -> \u03b2) (NONE :\u03b1 option) (SOME :\u03b1 -> \u03b1 option))", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u2227 t \u2286 s \u21d2 s = t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d4 \u00acNULL l", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). (\u2200(x :\u03b1). P x \u21d2 Q x) \u21d2 \u2200(l :\u03b1 list). EVERY P l \u21d2 EVERY Q l", "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d2 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). (DISJOINT (s \u222a t) u \u21d4 DISJOINT s u \u2227 DISJOINT t u) \u2227 (DISJOINT u (s \u222a t) \u21d4 DISJOINT s u \u2227 DISJOINT t u)", "\u2200(xs :\u03b1 list) (h :\u03b1) (i :num). (P :\u03b1 -> bool) h \u2227 EVERY P xs \u21d2 EVERY P (LUPDATE h i xs)", "\u2200(P :(\u03b1 -> bool) -> bool). (BIGUNION P = (\u2205 :\u03b1 -> bool) \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)}) \u2227 ((\u2205 :\u03b1 -> bool) = BIGUNION P \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)})", "(x :\u03b1 -> bool) \u2229 COMPL x = (\u2205 :\u03b1 -> bool) \u2227 COMPL x \u2229 x = (\u2205 :\u03b1 -> bool)", "TAKE (n :num) (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 l = ([] :\u03b1 list)", "APPLY_REDUNDANT_ROWS_INFO ([] :bool list) ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 (\u2200(is :bool list) (x :\u03b2) (xs :\u03b2 list). APPLY_REDUNDANT_ROWS_INFO (T::is) (x::xs) = APPLY_REDUNDANT_ROWS_INFO is xs) \u2227 \u2200(is :bool list) (x :\u03b3) (xs :\u03b3 list). APPLY_REDUNDANT_ROWS_INFO (F::is) (x::xs) = x::APPLY_REDUNDANT_ROWS_INFO is xs", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u", "\u2200(n :num) (f :num -> \u03b1) (m :num). n < m \u21d2 EL n (MAP f (COUNT_LIST m)) = f n", "\u2200(x :\u03b1 + \u03b2). \u00acISR x \u21d4 ISL x", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R^= x y", "\u2200(l :\u03b1 list) (n :num). LENGTH l \u2264 n \u21d2 TAKE n l = l", "\u2200(R :\u03b1 -> \u03b2 -> bool). R\u1d40 \u1d40 = R", "\u2200(R :\u03b1 -> \u03b1 -> bool). R\u207a \u207a = R\u207a", "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). PRIM_REC x f (0 :num) = x \u2227 \u2200(m :num). PRIM_REC x f (SUC m) = f (PRIM_REC x f m) m", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (l1 ++ l2) l", "\u2200(x :\u03b1) (f :\u03b2 -> \u03b1 -> bool) (s :\u03b2 -> bool). x \u2208 BIGINTER (IMAGE f s) \u21d4 \u2200(y :\u03b2). y \u2208 s \u21d2 x \u2208 f y", "\u2200(x :\u03b1). x INSERT \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)", "OPTION_MAP2 (f :\u03b1 -> \u03b2 -> \u03b3) (o1 :\u03b1 option) (o2 :\u03b2 option) = SOME (v :\u03b3) \u21d4 \u2203(x1 :\u03b1) (x2 :\u03b2). o1 = SOME x1 \u2227 o2 = SOME x2 \u2227 v = f x1 x2", "(\u2200(s :\u03b1). (P :\u03b1 -> bool) s \u21d4 (Q :\u03b1 -> bool) s) \u21d2 ((\u2203(s :\u03b1). P s) \u21d4 \u2203(s :\u03b1). Q s)", "reflexive (R :\u03b1 -> \u03b1 -> bool)^=", "\u2200(f :\u03b1 -> \u03b2) (ls :\u03b1 list) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ls = MAP f ls ++ a", "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 (f x = f y \u21d4 x = y)", "\u2200(s :\u03b1 -> bool). IMAGE (\u03bb(x :\u03b1). x) s = s", "(R :\u03b1 -> \u03b1 -> bool)\ua673 (x :\u03b1) x", "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'", "\u2200(x :\u03b1) (f :\u03b1 -> \u03b1) (g1 :num -> \u03b1) (g2 :num -> \u03b1) (m1 :num) (m2 :num). SIMP_REC_REL g1 x f m1 \u2227 SIMP_REC_REL g2 x f m2 \u21d2 \u2200(n :num). n < m1 \u2227 n < m2 \u21d2 g1 n = g2 n", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list list). FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)", "\u2200(s :\u03b1 list) (h :\u03b1) (t :\u03b1 list). IS_SUFFIX s (h::t) \u21d2 IS_SUFFIX s t", "\u2200(P :\u03b1 -> bool) (s :(\u03b1 -> bool) -> bool). (\u2200(x :\u03b1). x \u2208 BIGUNION s \u21d2 P x) \u21d4 \u2200(t :\u03b1 -> bool) (x :\u03b1). t \u2208 s \u2227 x \u2208 t \u21d2 P x", "\u2200(t :bool). F \u2227 t \u21d4 F", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l \u2260 l \u21d4 \u2203(x :\u03b1). MEM x l \u2227 \u00acP x", "(x :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 (0 :num) < LENGTH x", "\u2200(y :\u03b1) (x :\u03b1) (l :\u03b1 list). MEM y (SNOC x l) \u21d4 y = x \u2228 MEM y l", "SUM_SET (\u2205 :num -> bool) = (0 :num)", "MAP (\u03bb(x :\u03b1). x) (l :\u03b1 list) = l \u2227 MAP (I :\u03b1 -> \u03b1) l = l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u2227 countable t \u21d2 countable s", "{x | F} = (\u2205 :\u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool). s \u2286 PREIMAGE f (IMAGE f s)", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (x INSERT s) \u21d4 DISJOINT t s \u2227 x \u2209 t", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = if x \u2208 t then s \u222a t else x INSERT s \u222a t", "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R y z \u21d2 R\ua673 x z", "\u2200(s :num -> bool) (t :num -> bool). FINITE t \u2227 s \u2286 t \u21d2 SUM_SET s \u2264 SUM_SET t", "\u2200(x :\u03b1 list) (l :\u03b1 list list). FLAT (SNOC x l) = FLAT l ++ x", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). f \u2208 FUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q", "\u2200(v :\u03b1) (rows1 :(\u03b1 -> \u03b2 option) list) (rows2 :(\u03b1 -> \u03b2 option) list) (rows3 :(\u03b1 -> \u03b2 option) list). PMATCH_EQUIV_ROWS v rows1 rows2 \u21d2 PMATCH_EQUIV_ROWS v rows2 rows3 \u21d2 PMATCH_EQUIV_ROWS v rows1 rows3", "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list) (f :\u03b1 -> \u03b2 -> bool). LIST_REL f l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 EVERY (UNCURRY f) (ZIP (l1,l2))", "(\u2200(s :\u03b1 + \u03b2). (P :\u03b1 + \u03b2 -> bool) s) \u21d4 (\u2200(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2227 \u2200(y :\u03b2). P (INR y :\u03b1 + \u03b2)", "\u2200(P :\u03b1 # \u03b2 -> \u03b3). (\u03bb(p :\u03b1 # \u03b2). P p) = (\u03bb((p1 :\u03b1),(p2 :\u03b2)). P (p1,p2))", "\u2200(n :num). count (n + (1 :num)) = n INSERT count n", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) l", "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_FST l) = LENGTH l", "\u2200(R :\u03b1 -> \u03b1 -> bool). WeakOrder R \u21d2 \u2200(y :\u03b1) (z :\u03b1). y = z \u21d4 R y z \u2227 R z y", "\u2200(opt :\u03b1 option). OPTION_BIND opt (SOME :\u03b1 -> \u03b1 option) = opt", "((p :bool) \u21d4 (q :bool) \u2227 (r :bool)) \u21d4 (p \u2228 \u00acq \u2228 \u00acr) \u2227 (q \u2228 \u00acp) \u2227 (r \u2228 \u00acp)", "LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). (P :\u03b1 -> \u03b2 -> bool) a b \u2227 (Q :\u03b1 -> \u03b2 -> bool) a b) (l1 :\u03b1 list) (l2 :\u03b2 list) \u21d4 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). P a b) l1 l2 \u2227 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). Q a b) l1 l2", "\u2200(n :num) (m :num) (l :\u03b1 list). TAKE (n + m) l = TAKE n l ++ TAKE m (DROP n l)", "MAX (0 :num) (x :num) = x \u2227 MAX x (0 :num) = x \u2227 MAX (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then y else x)", "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 R\u207a = R", "(OPTION_GUARD (b :bool) = SOME () \u21d4 b) \u2227 (OPTION_GUARD b = (NONE :unit option) \u21d4 \u00acb)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f s = s \u2218 f", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (P :\u03b1 -> bool) (P' :\u03b1 -> bool). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EXISTS P l1 \u21d4 EXISTS P' l2)", "flip (UNCURRY (f :\u03b1 -> \u03b2 -> \u03b4 -> \u03b3)) (x :\u03b4) = UNCURRY (flip ((flip :(\u03b2 -> \u03b4 -> \u03b3) -> \u03b4 -> \u03b2 -> \u03b3) \u2218 f) x)", "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 l \u21d2 EVERY P1 (FILTER P2 l)", "\u2200(p :\u03b1 -> \u03b2) (g :\u03b1 -> bool) (r :\u03b1 -> \u03b3) (v :\u03b2) (rows :(\u03b2 -> \u03b3 option) list). (\u2200(x :\u03b1). r x = (ARB :\u03b3)) \u21d2 PMATCH v (SNOC (PMATCH_ROW p g r) rows) = PMATCH v rows", "\u2200(x :\u03b1) (l :\u03b1 list). MEM x l \u21d4 EXISTS ($= x) l", "\u00ac(\u00ac(A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 A \u21d2 \u00acB \u21d2 F", "\u2200(R :\u03b1 -> \u03b1 -> bool). SC (RC R) = RC (SC R) \u2227 RC (RC R) = RC R \u2227 (RC R)\u207a = RC R\u207a", "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2286 s", "\u2200(l :\u03b1 list). NULL l \u21d4 LENGTH l = (0 :num)", "\u2200(P :\u03b1 # \u03b2 -> bool). (\u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)) \u21d2 \u2200(p :\u03b1 # \u03b2). P p", "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 R\u207a (x :\u03b1) (y :\u03b1) \u21d2 x \u2260 y", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2) (l :\u03b3 list). FOLDL f e (MAP g l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 IMAGE f s \u2286 t", "\u2200(opt :\u03b1 option). opt = (NONE :\u03b1 option) \u2228 \u2203(x :\u03b1). opt = SOME x", "(\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2229 s = (\u2205 :\u03b1 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). s \u2229 (\u2205 :\u03b1 -> bool) = (\u2205 :\u03b1 -> bool)", "OPTION_MAP (I :\u03b1 -> \u03b1) (x :\u03b1 option) = x \u2227 OPTION_MAP (\u03bb(x :\u03b1). x) x = x", "(pair_CASE (p :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = (v :\u03b1) \u21d4 \u2203(x :\u03b2) (y :\u03b3). p = (x,y) \u2227 f x y = v", "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 irreflexive R", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). FINITE s \u2227 t \u2286 s \u21d2 FINITE t", "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b2 -> bool) (M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (x :\u03b1). f = WFREC R M \u2227 WF R \u2227 INDUCTIVE_INVARIANT R P M \u21d2 P x (f x)", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (RC R) \u21d4 symmetric R", "\u2200(n :num) (x :\u03b1) (y :\u03b1). MEM y (REPLICATE n x) \u21d4 x = y \u2227 (0 :num) < n", "\u2200(P :\u03b1 -> bool) (ls :\u03b1 list). NULL (FILTER P ls) \u21d4 \u2200(x :\u03b1). MEM x ls \u21d2 \u00acP x", "SING (\u2205 :\u03b1 -> bool) \u21d4 F", "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acq", "(([(f :\u03b2 -> \u03b1)] <*> [(x :\u03b2)]) :\u03b1 list) = [f x]", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). x \u2208 PREIMAGE f s \u21d4 f x \u2208 s", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (x :\u03b2). FOLDL f e [x] = f e x", "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1). (x INSERT P) \u00d7 Q = {x} \u00d7 Q \u222a P \u00d7 Q", "(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,COUNT_LIST n) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)", "(\u2200(x :\u03b1). MEM x (ls :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) x x) \u21d2 LIST_REL R ls ls", "LAST ((h :\u03b1)::(t :\u03b1 list)) = if t = ([] :\u03b1 list) then h else LAST t", "\u2200(s :\u03b1 -> bool). s \u2286 (\u2205 :\u03b1 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "SET_TO_LIST {(x :\u03b1)} = [x]", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s DIFF t) x \u21d4 x \u2208 s \u2227 x \u2209 t", "\u2200(n :num) (k :num). SUM (REPLICATE n k) = n * k", "\u2200(P :\u03b1 -> bool). INFINITE P \u21d2 \u2203(x :\u03b1). x \u2208 P", "(n :num) \u2264 tri n", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 R\ua673 (f x) (f y)", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). LENGTH (MAP f l) = LENGTH l", "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2200(x :\u03b1) (y :\u03b2). LINV_OPT f s y = SOME x \u21d4 y = f x \u2227 x \u2208 s \u2227 y \u2208 t", "MAP (\u03bb((x :\u03b1),(y :\u03b2),(z :\u03b3)). x) (funs :(\u03b1 # \u03b2 # \u03b3) list) = MAP (FST :\u03b1 # \u03b2 # \u03b3 -> \u03b1) funs", "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_SND l) = LENGTH l", "Order (R :\u03b1 -> \u03b1 -> bool) \u21d4 WeakOrder (RC R)", "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b1 -> \u03b2 -> \u03b2) (f' :\u03b1 -> \u03b2 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f x a = f' x a) \u21d2 FOLDR f b l = FOLDR f' b' l'", "\u2200(f :\u03b1 -> \u03b1) (s :\u03b1 -> bool). (x :\u03b1) \u2208 schroeder_close f s \u21d4 \u2203(n :num). x \u2208 FUNPOW (IMAGE f) n s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2208 partition R s \u21d2 t \u2286 s", "\u2200(M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (f :\u03b1 -> \u03b2). f = WFREC R M \u21d2 WF R \u21d2 \u2200(x :\u03b1). f x = M (RESTRICT f R x) x", "\u2200(n :num). \u00ac(n < (0 :num))", "\u2200(S :\u03b1 -> bool). FINITE S \u21d2 \u2200(t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f S t \u2227 FINITE t \u21d2 CARD S = CARD t", "((x :\u03b1),(y :\u03b2)) \u2208 {(x,y) | (P :\u03b1 -> \u03b2 -> bool) x y} \u21d4 P x y", "\u2200(ls :\u03b1 list) (f :\u03b2 -> \u03b1 # \u03b1 -> \u03b2) (e :\u03b2). FOLDL f e (ZIP (ls,ls)) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f x (y,y)) e ls", "\u2200(t :bool). \u00ac\u00act \u21d4 t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (x INSERT s) DIFF t = if x \u2208 t then s DIFF t else x INSERT s DIFF t", "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). POW set e \u21d4 e \u2286 set", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R' :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R^= (x :\u03b1) (y :\u03b1) \u21d2 R'^= x y", "nfst (0 :num) = (0 :num)", "\u2200(s :\u03b1 -> bool). s \u222a s = s", "(\u2200(l :\u03b1 list). TAKE (0 :num) l = ([] :\u03b1 list)) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). TAKE (SUC n) (x::l) = x::TAKE n l", "\u2200(l :\u03b1 list). NULL l \u21d4 l = ([] :\u03b1 list)", "\u2200(x :\u03b1 -> bool) (y :\u03b2 -> bool). FUNSET x y = DFUNSET x (K y :\u03b1 -> \u03b2 -> bool)", "\u2200(A :bool). \u00acA \u2227 A \u21d4 F", "\u2200(x :\u03b1) (y :\u03b2). (INL x :\u03b1 + \u03b2) \u2260 (INR y :\u03b1 + \u03b2)", "\u2200(ls :\u03b1 list) (n :num). DROP n ls = ([] :\u03b1 list) \u21d4 LENGTH ls \u2264 n", "DIV2 (BIT1 (x :num)) = x", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). P x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 P y z \u21d2 P x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 P x y", "\u2200(s :\u03b1 -> bool) (x :\u03b1). x INSERT s = {x} \u222a s", "BIJ (f :\u03b1 -> \u03b2) \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) \u21d2 \u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d4 x = y", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). MAP f (TL l) = TL (MAP f l)", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2 -> \u03b2) (b :\u03b2). FINITE s \u21d2 ITSET f s b = if s = (\u2205 :\u03b1 -> bool) then b else ITSET f (REST s) (f (CHOICE s) b)", "\u2200(x :\u03b1) (l :\u03b1 list). ALL_DISTINCT (SNOC x l) \u21d4 \u00acMEM x l \u2227 ALL_DISTINCT l", "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2228 p \u21d4 p \u2228 stmarker m) \u2227 (p \u2228 q \u2228 stmarker m \u21d4 (p \u2228 q) \u2228 stmarker m) \u2227 ((p \u2228 stmarker m) \u2228 q \u21d4 (p \u2228 q) \u2228 stmarker m)", "\u2200(x :\u03b1). {x} \u2260 (\u2205 :\u03b1 -> bool)", "S (f :\u03b1 # \u03b2 -> \u03b4 -> \u03b3) (UNCURRY (g :\u03b1 -> \u03b2 -> \u03b4)) = UNCURRY (S ((S :(\u03b2 -> \u03b4 -> \u03b3) -> (\u03b2 -> \u03b4) -> \u03b2 -> \u03b3) \u2218 ($o f :(\u03b2 -> \u03b1 # \u03b2) -> \u03b2 -> \u03b4 -> \u03b3) \u2218 ($, :\u03b1 -> \u03b2 -> \u03b1 # \u03b2)) g)", "\u2200(s :\u03b1 -> bool). s DIFF (\u2205 :\u03b1 -> bool) = s", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d4 x INSERT s = s", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). DFUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). P x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u2227 P y z \u21d2 P x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 P x y", "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). SURJ f (\u2205 :\u03b1 -> bool) s \u21d4 s = (\u2205 :\u03b2 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). SURJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (l :\u03b2 list). EVERY P (MAP f l) \u21d4 EVERY (P \u2218 f) l", "\u2200(n1 :num) (n2 :num). (ind_type$INJN n1 :num -> \u03b1 -> bool) = (ind_type$INJN n2 :num -> \u03b1 -> bool) \u21d4 n1 = n2", "\u2200(x :\u03b1 list) (y :\u03b1 list) (z :\u03b1 list). y \u227c x \u2227 z \u227c y \u21d2 z \u227c x", "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). EVERY P (SNOC x l) \u21d4 EVERY P l \u2227 P x", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 f x = f y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). transitive R \u21d2 transitive (inv_image R f)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SEG (1 :num) n l = [EL n l]", "(\u2200(a :\u03b1 list) (c :\u03b1 list). (d :\u03b1 list) \u2260 a ++ [(b :\u03b1)] ++ c) \u21d4 \u00acMEM b d", "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c a ++ c \u21d4 b \u227c c", "countable \ud835\udd4c(:\u03b1 # \u03b2) \u21d4 countable \ud835\udd4c(:\u03b1) \u2227 countable \ud835\udd4c(:\u03b2)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (e :\u03b1). FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)", "\u2200(v :\u03b1) (rows_old :(\u03b1 -> \u03b2 option) list) (rows_new :(\u03b1 -> \u03b2 option) list) (r :\u03b1 -> \u03b2 option). PMATCH v rows_old = PMATCH v rows_new \u21d2 PMATCH v (r::rows_old) = PMATCH v (r::rows_new)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (a :\u03b1). Q a \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R y z \u21d2 Q z) \u21d2 \u2200(z :\u03b1). R\ua673 a z \u21d2 Q z", "\u2200(n :num) (l :\u03b1 list). LENGTH (DROP n l) = LENGTH l \u2212 n", "(\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). ([] :\u03b1 list) = l1 ++ l2 \u21d4 l1 = ([] :\u03b1 list) \u2227 l2 = ([] :\u03b1 list)) \u2227 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = ([] :\u03b1 list) \u21d4 l1 = ([] :\u03b1 list) \u2227 l2 = ([] :\u03b1 list)", "\u2200(P :\u03b1 option -> bool). P (NONE :\u03b1 option) \u2227 (\u2200(a :\u03b1). P (SOME a)) \u21d2 \u2200(x :\u03b1 option). P x", "\u2200(R :\u03b1 -> \u03b1 -> bool). WF R \u21d2 \u2200(P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). P x", "\u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (REST s)", "transitive (R1 :\u03b1 -> \u03b1 -> bool) \u2227 transitive (R2 :\u03b1 -> \u03b1 -> bool) \u21d2 transitive (R1 \u2229\u1d63 R2)", "\u2200(l :\u03b1 list) (m :num) (x :\u03b1). MEM x (TAKE m l) \u21d2 MEM x l", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 \u2200(t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s \u2286 t", "\u2200(m :num) (n :num). m \u2264 n \u21d2 count m \u2286 count n", "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). reflexive R \u21d2 reflexive (inv_image R f)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 \u2200(u :\u03b1) (v :\u03b1). R\u207a u v \u21d2 P u v", "LIST_BIND [(x :\u03b2)] (f :\u03b2 -> \u03b1 list) = f x", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R\u207a (x :\u03b1) (y :\u03b1) \u21d2 Q\u207a x y", "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). X \u2286 BIGINTER P \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 X \u2286 Y", "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). x \u2208 P \u00d7 Q \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f (x INSERT s) t \u21d4 INJ f s t \u2227 f x \u2208 t \u2227 \u2200(y :\u03b1). y \u2208 s \u2227 f x = f y \u21d2 x = y", "FINITE (s :\u03b1 -> bool) \u2227 FINITE (t :\u03b1 -> bool) \u21d2 CARD (s \u222a t) \u2264 CARD s + CARD t", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). l \u2260 ([] :\u03b1 list) \u21d2 LAST (MAP f l) = f (LAST l)", "\u2200(m :num). m < SUC m \u2227 m < SUC (SUC m)", "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 s)", "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). EL n (l1 ++ l2) = EL (n \u2212 LENGTH l1) l2", "LINV_OPT (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (y :\u03b2) = SOME (x :\u03b1) \u21d2 x \u2208 s \u2227 f x = y", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P (REVERSE l) \u21d4 EVERY P l", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT (x INSERT s) t \u21d4 DISJOINT s t \u2227 x \u2209 t", "\u2200(l :num list). SUM (REVERSE l) = SUM l", "\ud835\udd4c(:\u03b1 # \u03b2) = \ud835\udd4c(:\u03b1) \u00d7 \ud835\udd4c(:\u03b2)", "\u2200(ll :\u03b1 list). ll = ([] :\u03b1 list) \u2228 \u2203(x :\u03b1) (l :\u03b1 list). ll = SNOC x l", "\u2200(P :\u03b1 + \u03b2 -> bool). (\u2203(s :\u03b1 + \u03b2). P s) \u21d4 (\u2203(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). P (INR y :\u03b1 + \u03b2)", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 reflexive R\u207a", "\u2200(p :bool) (q :bool) (m :bool). (p \u2228 stmarker m \u21d4 stmarker m \u2228 p) \u2227 ((stmarker m \u2228 p) \u2228 q \u21d4 stmarker m \u2228 p \u2228 q) \u2227 (p \u2228 stmarker m \u2228 q \u21d4 stmarker m \u2228 p \u2228 q)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (f :\u03b1 -> \u03b2) (f' :\u03b1 -> \u03b2). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 f x = f' x) \u21d2 MAP f l1 = MAP f' l2", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b2 -> \u03b2 -> bool) ((f :\u03b1 -> \u03b2) x) (f y)) \u2227 reflexive Q \u2227 transitive Q \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 Q (f x) (f y)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2282 u \u21d2 s \u2282 u", "\u2200(p :\u03b1 # \u03b2) (q :\u03b1 # \u03b2). p = q \u21d4 FST p = FST q \u2227 SND p = SND q", "\u2200(n :num). EL n (l :\u03b1 list) = if n = (0 :num) then HD l else EL (PRE n) (TL l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u222a t \u21d4 x \u2208 s \u2228 x \u2208 t", "\u2200(l1 :num list) (l2 :num list). SUM (l1 ++ l2) = SUM l1 + SUM l2", "\u2200(M :\u03b1 + \u03b2) (M' :\u03b1 + \u03b2) (f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). M = M' \u2227 (\u2200(x :\u03b1). M' = (INL x :\u03b1 + \u03b2) \u21d2 f x = (f' :\u03b1 -> \u03b3) x) \u2227 (\u2200(y :\u03b2). M' = (INR y :\u03b1 + \u03b2) \u21d2 f1 y = (f1' :\u03b2 -> \u03b3) y) \u21d2 (sum_CASE M f f1 :\u03b3) = (sum_CASE M' f' f1' :\u03b3)", "REVERSE (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 l = ([] :\u03b1 list)", "\u2200(l :\u03b1 list). FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l = l", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 IMAGE f (s DELETE x) = IMAGE f s", "\u2200(c :bool) (x :bool). (if c then F else x) \u21d4 \u00acc \u2227 x", "OPTION_CHOICE (m1 :\u03b1 option) (NONE :\u03b1 option) = m1", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). RC R x y \u21d2 f x = f y", "\u2200(c :bool) (l :\u03b1 list). EXISTS (\u03bb(x :\u03b1). c) l \u21d4 l \u2260 ([] :\u03b1 list) \u2227 c", "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 LENGTH x = LENGTH y \u21d4 x = y", "((SOME (f :\u03b2 -> \u03b1) <*> SOME (x :\u03b2)) :\u03b1 option) = SOME (f x)", "\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d4 l = ([] :\u03b1 list)", "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool) \u21d2 \u2200(t1 :\u03b1 -> bool) (t2 :\u03b1 -> bool). t1 \u2208 partition R s \u2227 t2 \u2208 partition R s \u2227 t1 \u2260 t2 \u21d2 DISJOINT t1 t2", "\u2200(L :\u03b1 list). LENGTH L = LEN L (0 :num)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1). R\u207a x z \u21d2 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE (l1 ++ l2) = REVERSE l2 ++ REVERSE l1", "total (R1 :\u03b1 -> \u03b1 -> bool) \u2227 total (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 total (R1 LEX R2)", "(\u2200(y :\u03b1) (x :\u03b1). (INL x :\u03b1 + \u03b2) = (INL y :\u03b1 + \u03b2) \u21d4 x = y) \u2227 \u2200(y :\u03b2) (x :\u03b2). (INR x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u21d4 x = y", "\u2200(s :\u03b1 -> bool). POW s \u2260 (\u2205 :(\u03b1 -> bool) -> bool)", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 EL (PRE (LENGTH l)) l = LAST l", "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u222a y DIFF x = y DIFF x \u2227 x \u222a y DIFF y = x DIFF y", "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). (P \u00d7 Q) x \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q", "\u2200(n :num). SUC n \u2260 n", "\u2200(x :\u03b1). x \u2209 (\u2205 :\u03b1 -> bool)", "(\u2200(m :num). m < (n :num) \u21d2 (f1 :num -> \u03b1) m = (f2 :num -> \u03b1) m) \u21d2 GENLIST f1 n = GENLIST f2 n", "\u2200(f :\u03b1 -> \u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). INJ f (set l1 \u222a set l2) \ud835\udd4c(:\u03b2) \u21d2 (MAP f l1 = MAP f l2 \u21d4 l1 = l2)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 WFP R y) \u21d2 WFP R x", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). LASTN (LENGTH l2) (l1 ++ l2) = l2", "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d2 LENGTH (TL l) = LENGTH l \u2212 (1 :num)", "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 BIJ f (s DELETE e) (t DELETE f e)", "\u2200(n :num) (x :\u03b1). LENGTH (REPLICATE n x) = n", "IMAGE (I :\u03b1 -> \u03b1) (s :\u03b1 -> bool) = s", "antisymmetric ($RSUBSET :(\u03b1 -> \u03b2 -> bool) -> (\u03b1 -> \u03b2 -> bool) -> bool)", "\u2200(l :\u03b1 list). LASTN (LENGTH l) l = l", "\u2200(R :\u03b1 -> \u03b1 -> bool). equivalence R \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 R x = R y", "\u2200(l :\u03b1 list) (x :\u03b1). ELL (LENGTH l) (SNOC x l) = if NULL l then x else HD l", "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (DROP m l) \u21d2 EXISTS P l", "\u2200(m :num) (n :num). (\u03bb(x :num) (y :num). y = SUC x)\u207a m (SUC n) \u21d4 (\u03bb(x :num) (y :num). y = SUC x)\ua673 m n", "\u2200(P :\u03b3 -> \u03b4) (M :\u03b1 # \u03b2) (N :\u03b1 -> \u03b2 -> \u03b3). P (let ((x :\u03b1),(y :\u03b2)) = M in N x y) = (let ((x :\u03b1),(y :\u03b2)) = M in P (N x y))", "\u2200(R :\u03b1 -> \u03b1 -> bool). rcdiamond R \u21d4 diamond (RC R)", "\u2200(s :\u03b1 -> bool). \u00ac(\ud835\udd4c(:\u03b1) \u2282 s)", "\u2200(l :(\u03b1 # \u03b2) list). ZIP (UNZIP l) = l", "\u2200(P :\u03b1 -> bool). BIGINTER {P} = P", "\u2200(M :'a1 # 'a2) (N :'a1 -> 'a2 -> \u03b2 -> \u03b3) (b :\u03b2). (let ((x :'a1),(y :'a2)) = M in N x y) b = (let ((x :'a1),(y :'a2)) = M in N x y b)", "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INR x :\u03b2 + \u03b1) \u2208 (t :\u03b2 + \u03b1 -> bool)) \u21d2 INJ (INR :\u03b1 -> \u03b2 + \u03b1) s t", "\u2200(n :num) (m :num). n < m \u21d2 tri n < tri m", "\u2200(m :num) (n :num). SUC m < n \u21d2 m < n", "transitive (R :\u03b1 -> \u03b1 -> bool)^=", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d2 s \u2286 t \u2227 t \u2286 s", "\u2200(l :\u03b1 list) (n :num). n < LENGTH (FRONT l) \u2227 \u00acNULL l \u21d2 EL n (FRONT l) = EL n l", "(s0 :\u03b1 -> bool) \u2286 (s :\u03b1 -> bool) \u2227 INJ (f :\u03b1 -> \u03b2) s (t :\u03b2 -> bool) \u21d2 BIJ f s0 (IMAGE f s0)", "\u2200(n :num). LENGTH (l1 :\u03b1 list) < n \u21d2 TAKE n (l1 ++ (l2 :\u03b1 list)) = l1 ++ TAKE (n \u2212 LENGTH l1) l2", "\u2200(x :\u03b1 + \u03b2). ISL x \u21d2 (INL (OUTL x) :\u03b1 + \u03b2) = x", "\u2200(s :num -> bool). FINITE s \u21d2 \u2200(e :num). SUM_SET (s DELETE e) = if e \u2208 s then SUM_SET s \u2212 e else SUM_SET s", "\u2200(f :\u03b1 -> \u03b2). IMAGE f (\u2205 :\u03b1 -> bool) = (\u2205 :\u03b2 -> bool)", "\u2200(m :num) (n :num). n \u2264 n \u2297 m", "\u2200(l :\u03b1 list) (x :\u03b1). MEM x (TL l) \u21d2 MEM x l", "\u2200(R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). pairwise R t \u2227 s \u2286 t \u21d2 pairwise R s", "\u00ac\u00ac(p :bool) \u21d2 p", "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2208 POW s", "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 HD l::TL l = l", "\u2200(x :\u03b1) (y :\u03b1 list). FRONT (x::y) \u227c x::y", "$! (UNCURRY (f :\u03b1 -> \u03b2 -> bool)) \u21d4 $! (($! :(\u03b2 -> bool) -> bool) \u2218 f)", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). LASTN n (x::l) = LASTN n l", "\u2200(x :\u03b1). SOME x \u2260 (NONE :\u03b1 option)", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (SC R)", "\u2200(l1 :\u03b1 list) (l1' :\u03b1 list) (l2 :\u03b2 list) (l2' :\u03b2 list) (P :\u03b1 -> \u03b2 -> bool) (P' :\u03b1 -> \u03b2 -> bool). l1 = l1' \u2227 l2 = l2' \u2227 (\u2200(x :\u03b1) (y :\u03b2). MEM x l1' \u2227 MEM y l2' \u21d2 (P x y \u21d4 P' x y)) \u21d2 (LIST_REL P l1 l2 \u21d4 LIST_REL P' l1' l2')", "\u2200(p :\u03b1 # \u03b2) (f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4). SND ((f ## g) p) = g (SND p)", "ind_type$ISO (f :\u03b1 -> \u03b3) (f' :\u03b3 -> \u03b1) \u2227 ind_type$ISO (g :\u03b2 -> \u03b4) (g' :\u03b4 -> \u03b2) \u21d2 ind_type$ISO (\u03bb(h :\u03b1 -> \u03b2) (a' :\u03b3). g (h (f' a'))) (\u03bb(h :\u03b3 -> \u03b4) (a :\u03b1). g' (h (f a)))", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R \u21d2 R\u1d40 = R", "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP (n \u2212 LENGTH l1) l2", "\u2200(n :num) (l1 :\u03b1 list). n \u2264 LENGTH l1 \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 ++ l2) = TAKE n l1", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). LENGTH (l1 ++ l2) = LENGTH l1 + LENGTH l2", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 \u2200(x :\u03b1). s x \u21d2 t x", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR $/\\ T (MAP P l)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (LENGTH l1) (l1 ++ l2) = l2", "\u2200(f :'z -> 'z). INVOL f \u21d4 \u2200(x :'z). f (f x) = x", "\u2200(R :\u03b1 -> \u03b1 -> bool). antisymmetric R\u1d40 \u21d4 antisymmetric R", "\u2200(P :\u03b1 -> bool). P \u00d7 (\u2205 :\u03b2 -> bool) = (\u2205 :\u03b1 # \u03b2 -> bool) \u2227 (\u2205 :\u03b3 -> bool) \u00d7 P = (\u2205 :\u03b3 # \u03b1 -> bool)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T l", "\u00acNULL (l2 :\u03b1 list) \u2227 (n :num) = LENGTH (l1 :\u03b1 list) \u21d2 EL n (l1 ++ l2) = HD l2", "(r1 :\u03b1) = (r2 :\u03b1) \u21d2 (Abbrev ((v :\u03b1) = r1) \u21d4 Abbrev (v = r2))", "MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (x :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)", "\u2200(c :\u03b1 list) (a :\u03b1 list). a \u227c a ++ c", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). (EXISTS (\u03bb(x :\u03b1). P x \u2228 Q x) l \u21d4 EXISTS P l) \u2228 EXISTS Q l", "\u2200(x :\u03b1 option). \u00acIS_SOME x \u21d4 x = (NONE :\u03b1 option)", "OPTION_MAP2 (f :\u03b1 -> \u03b2 -> \u03b3) (o1 :\u03b1 option) (o2 :\u03b2 option) = (NONE :\u03b3 option) \u21d4 o1 = (NONE :\u03b1 option) \u2228 o2 = (NONE :\u03b2 option)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = l2 \u21d4 l1 = REVERSE l2", "\u2200(s :num -> bool). countable s", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 \u2203(e :\u03b1). MEM e l \u2227 P e", "\u2200(x :\u03b1) (l :\u03b1 list). MEM x l \u21d4 FOLDR $\\/ F (MAP ($= x) l)", "symmetric (R :\u03b1 -> \u03b1 -> bool) \u21d4 R\u1d40 \u2286\u1d63 R", "OPTION_IGNORE_BIND (NONE :\u03b2 option) (m :\u03b1 option) = (NONE :\u03b1 option) \u2227 OPTION_IGNORE_BIND (SOME (v :\u03b3)) m = m", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = t \u2229 s", "\u2200(p :bool) (q :bool) (m :bool). (p \u2227 stmarker m \u21d4 stmarker m \u2227 p) \u2227 ((stmarker m \u2227 p) \u2227 q \u21d4 stmarker m \u2227 p \u2227 q) \u2227 (p \u2227 stmarker m \u2227 q \u21d4 stmarker m \u2227 p \u2227 q)", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = REVERSE (x::REVERSE l)", "SURJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (IMAGE f s)", "PMATCH_ROW (p :\u03b2 -> \u03b3) (g :\u03b2 -> bool) (r :\u03b2 -> \u03b1) (i :\u03b3) = SOME (y :\u03b1) \u21d2 \u2203(x :\u03b2). PMATCH_ROW_COND p g i x \u2227 y = r x", "\u2200(x :\u03b1) (sos :(\u03b1 -> bool) -> bool). BIGUNION sos x \u21d4 \u2203(s :\u03b1 -> bool). x \u2208 s \u2227 s \u2208 sos", "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s \u2229 t) = PREIMAGE f s \u2229 PREIMAGE f t", "\u2200(s :\u03b1 -> bool). (\u2203(x :\u03b1). x \u2208 s) \u21d4 s \u2260 (\u2205 :\u03b1 -> bool)", "(diag (A :\u03b1 -> bool))\u1d40 = diag A", "\u2200(f :\u03b1 -> bool) (n :num) (x :\u03b1). EVERY f (REPLICATE n x) \u21d4 n = (0 :num) \u2228 f x", "{x | x = (y :\u03b1)} = {y}", "transitive ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). CURRY (UNCURRY f) = f", "\u2200(e :\u03b1) (l1 :\u03b1 list) (l2 :\u03b1 list). MEM e (l1 ++ l2) \u21d4 MEM e l1 \u2228 MEM e l2", "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 y \u227c x \u21d2 x = y", "\u2200(P :\u03b1 -> bool) (L :\u03b1 list) (M :\u03b1 list). FILTER P (L ++ M) = FILTER P L ++ FILTER P M", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 SC R (x :\u03b1) (y :\u03b1) \u21d2 SC Q x y", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEXISTS P l \u21d4 EVERY ($\u00ac \u2218 P) l", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x \u21d2 x') \u2227 (x' \u21d2 y' \u21d2 y) \u21d2 (x' \u21d2 y') \u21d2 x \u21d2 y", "\u2200(l :\u03b1 list) (e :\u03b1) (y :\u03b1). MEM y (FRONT (e::l)) \u21d2 MEM y (e::l)", "(\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l1 \u21d4 l2 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l2 \u21d4 l1 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l1 ++ l2 \u21d4 l2 = ([] :\u03b1 list)) \u2227 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 = l1 ++ l2 \u21d4 l1 = ([] :\u03b1 list)", "\u2200(x :\u03b1). ALL_DISTINCT [x]", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). CARD (x INSERT s) = if x \u2208 s then CARD s else SUC (CARD s)", "\u2200(m :num) (n :num). m \u2264 n \u2297 m", "\u2200(l :\u03b1 list) (l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u227c l \u2227 l2 \u227c l \u21d2 l1 \u227c l2 \u2228 l2 \u227c l1", "\u2200(A :bool). A \u21d2 \u00acA \u21d2 F", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). set (MAP f l) = IMAGE f (set l)", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u2229 t = if x \u2208 t then x INSERT s \u2229 t else s \u2229 t", "\u2200(ls :\u03b1 list) (n :num). n < LENGTH ls \u21d2 TAKE (n + (1 :num)) ls = SNOC (EL n ls) (TAKE n ls)", "OPTION_MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (SOME (x :\u03b2)) (SOME (y :\u03b3)) = SOME (f x y) \u2227 OPTION_MAP2 f (SOME x) (NONE :\u03b3 option) = (NONE :\u03b1 option) \u2227 OPTION_MAP2 f (NONE :\u03b2 option) (SOME y) = (NONE :\u03b1 option) \u2227 OPTION_MAP2 f (NONE :\u03b2 option) (NONE :\u03b3 option) = (NONE :\u03b1 option)", "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b2 -> \u03b2 -> bool) (v1 :\u03b1 # \u03b2) (v2 :\u03b1 # \u03b2) (R1' :\u03b1 -> \u03b1 -> bool) (R2' :\u03b2 -> \u03b2 -> bool) (v1' :\u03b1 # \u03b2) (v2' :\u03b1 # \u03b2). v1 = v1' \u2227 v2 = v2' \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u21d2 (R1 a c \u21d4 R1' a c)) \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u2227 a = c \u21d2 (R2 b d \u21d4 R2' b d)) \u21d2 ((R1 LEX R2) v1 v2 \u21d4 (R1' LEX R2') v1' v2')", "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (D :\u03b1 -> bool) (P :\u03b1 -> \u03b2 -> bool) (M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (x :\u03b1). f = WFREC R M \u2227 WF R \u2227 INDUCTIVE_INVARIANT_ON R D P M \u2227 D x \u21d2 P x (f x)", "\u2200(x :bool) (y :\u03b1 -> bool). (K x :\u03b1 -> bool) \u2286 y \u21d4 \u00acx \u2228 \ud835\udd4c(:\u03b1) \u2286 y", "(OPTREL (R :\u03b1 -> \u03b2 -> bool) (SOME (x :\u03b1)) (NONE :\u03b2 option) \u21d4 F) \u2227 (OPTREL R (NONE :\u03b1 option) (SOME (y :\u03b2)) \u21d4 F) \u2227 (OPTREL R (NONE :\u03b1 option) (NONE :\u03b2 option) \u21d4 T) \u2227 (OPTREL R (SOME x) (SOME y) \u21d4 R x y)", "\u2200(s :\u03b1 -> bool). SING s \u21d2 FINITE s", "\u2200(s :\u03b1 + \u03b2) (s' :\u03b1 + \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). s = s' \u2227 (\u2200(a :\u03b1). s' = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). s' = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q s \u21d4 SUM_ALL P' Q' s')", "\u2200(f :\u03b1 -> \u03b2) (M :(\u03b1 -> bool) -> bool). IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). s DIFF (x INSERT t) = s DELETE x DIFF t", "\u2200(v :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool). (\u2200(x :\u03b2). \u00acg x) \u21d2 (PMATCH_ROW_COND_EX v p g \u21d4 F)", "(\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y) \u21d2 (IMAGE f (s1 :\u03b1 -> bool) = IMAGE f (s2 :\u03b1 -> bool) \u21d4 s1 = s2)", "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u1d40 \u21d4 transitive R", "\u2200(t :bool). T \u2228 t \u21d4 T", "\u2200(t :bool). t \u2227 F \u21d4 F", "\u2200(t :bool). T \u2227 t \u21d4 t", "\u2200(f :\u03b1 -> \u03b2 # bool). (\u2200(x :\u03b1). \u00acSND (f x)) \u21d2 GSPEC f = (\u2205 :\u03b2 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool). equivalence R \u21d2 R\u1d40 = R", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). RC R x y \u21d2 RC R (f x) (f y)", "SND (p :\u03b2 # \u03b1) = (y :\u03b1) \u21d4 \u2203(x :\u03b2). p = (x,y)", "\u2200(P :num -> bool). P (0 :num) \u2227 (\u2200(n :num). P n \u21d2 P (SUC n)) \u21d2 \u2200(n :num). P n", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 option -> bool) (SOME x)) \u2227 ((\u2200(x :\u03b1). \u00acP x) \u21d2 Q (NONE :\u03b1 option)) \u21d2 Q ($some P)", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH l)) l = HD l", "\u2200(n1 :num) (n2 :num) (x :\u03b1). n1 < n2 \u21d2 EL n1 (REPLICATE n2 x) = x", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). n < LENGTH l1 \u21d2 EL n (l1 ++ l2) = EL n l1", "\u2200(f :\u03b1 -> \u03b2) (t :\u03b2 -> bool) (sp :\u03b1 -> bool). PREIMAGE f (COMPL t) \u2229 sp = sp DIFF PREIMAGE f t", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 \u2200(f :\u03b1 -> \u03b2). f x \u2208 IMAGE f s", "\u2200(l1 :\u03b1 list) (h :\u03b1) (l2 :\u03b1 list) (l3 :\u03b1 list). l1 ++ h::l2 ++ l3 = l1 ++ h::(l2 ++ l3)", "\u2200(n :num). count n = if n = (0 :num) then (\u2205 :num -> bool) else (let (p :num) = PRE n in p INSERT count p)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 COMPL s \u21d4 x \u2209 s", "\u2200(l :\u03b1 list) (n :num). LENGTH l \u2264 n \u21d2 DROP n l = ([] :\u03b1 list)", "\u2200(P :\u03b1 -> bool) (B :(\u03b1 -> bool) -> bool). BIGINTER (P INSERT B) = P \u2229 BIGINTER B", "\u2200(xs :\u03b1 list) (ys :\u03b2 list) (P :\u03b1 -> \u03b2 -> bool) (x :\u03b1). LIST_REL P xs ys \u2227 MEM x xs \u21d2 \u2203(y :\u03b2). MEM y ys \u2227 P x y", "longest_prefix (\u2205 :\u03b1 list -> bool) = ([] :\u03b1 list)", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 SC R (f x) (f y)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2227 t \u2286 s \u21d2 countable t", "\u2200(ls :num list). SUM ls = (0 :num) \u21d4 \u2200(x :num). MEM x ls \u21d2 x = (0 :num)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 DISJOINT t s", "\u2200(n :num). n \u2264 LENGTH (l1 :\u03b1 list) \u21d2 TAKE n (l1 ++ (l2 :\u03b1 list)) = TAKE n l1", "\u2200(xs :\u03b1 list) (k :num) (n :num). TAKE k (DROP n xs) = DROP n (TAKE (k + n) xs)", "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 (FILTER P2 l) \u21d4 EVERY (\u03bb(x :\u03b1). P2 x \u21d2 P1 x) l", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 EL n l = HD (SEG (1 :num) n l)", "\u2200(x :\u03b1 option). (option_CASE x x (SOME :\u03b1 -> \u03b1 option) :\u03b1 option) = x", "\u2200(R :\u03b1 -> \u03b1 -> bool). WeakOrder R \u21d2 Order R", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). DISJOINT (s \u222a t) u \u21d4 DISJOINT s u \u2227 DISJOINT t u", "(s :\u03b1 -> bool) \u2286 (t :\u03b1 -> bool) \u21d2 s \u222a (t DIFF s) = t \u2227 t DIFF s \u222a s = t", "(\u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT (BIGUNION s) t \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT s' t) \u2227 \u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT t (BIGUNION s) \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT t s'", "(\u2200(x :\u03b1) (y :\u03b2). (R1 :\u03b1 -> \u03b2 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b2 -> bool) x y) \u21d2 LIST_REL R1 (l1 :\u03b1 list) (l2 :\u03b2 list) \u21d2 LIST_REL R2 l1 l2", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R^= x y \u2227 R^= y z \u21d2 R^= x z", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] l", "\u2200(n :num) (x :\u03b1). REVERSE (REPLICATE n x) = REPLICATE n x", "(y :\u03b1) \u2208 {x | (P :\u03b1 -> bool) x} \u21d4 P y", "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). EXISTS P (SNOC x l) \u21d4 P x \u2228 EXISTS P l", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list). PMATCH_EQUIV_ROWS v rows rows", "\u2200(I :num -> bool) (J :num -> bool) (n :\u03b1). I \u2260 (\u2205 :num -> bool) \u2227 J \u2260 (\u2205 :num -> bool) \u2227 I \u2286 J \u21d2 MIN_SET J \u2264 MIN_SET I", "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 RC R x y \u21d2 P y", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEVERY P l \u21d4 EXISTS ($\u00ac \u2218 P) l", "\u2200(m :num) (l :\u03b1 list) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1) (l :\u03b3 list). FOLDR f e (MAP g l) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e l", "\u2200(P :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list) (v1 :\u03b1) (v2 :\u03b2) (n :num). P v1 v2 \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)", "\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (ys :\u03b2 list) (n :num). LIST_REL P xs ys \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)", "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (TAKE m l) \u21d2 EXISTS P l", "RC ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "transitive (R1 :\u03b1 -> \u03b1 -> bool) \u2227 transitive (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 transitive (R1 LEX R2)", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). P x \u2227 Q x) l \u21d4 EVERY P l \u2227 EVERY Q l", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u2260 l2 \u21d2 \u2200(h1 :\u03b1) (h2 :\u03b1). h1::l1 \u2260 h2::l2", "\u2200(y :\u03b1) (l :\u03b1 list). MEM y l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F l", "\u2200(x :\u03b1) (y :\u03b1). {x} = {y} \u21d4 x = y", "\u2200(P :unit -> bool). P () \u21d2 \u2200(x :unit). P x", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). FINITE (s DIFF t)", "\u2200(m :num) (n :num) (l :\u03b1 list). m + n = LENGTH l \u21d2 BUTLASTN m l ++ DROP n l = l", "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list). LENGTH l1 = LENGTH l2 \u21d2 LENGTH (ZIP (l1,l2)) = LENGTH l1 \u2227 LENGTH (ZIP (l1,l2)) = LENGTH l2", "\u2200(x :\u03b1) (xs :\u03b1 list). LENGTH (FRONT (x::xs)) = LENGTH xs", "\u2200(s :\u03b1 -> bool). COMPL s \u2229 s = (\u2205 :\u03b1 -> bool) \u2227 COMPL s \u222a s = \ud835\udd4c(:\u03b1)", "UNZIP ([] :(\u03b1 # \u03b2) list) = (([] :\u03b1 list),([] :\u03b2 list)) \u2227 UNZIP (((x :\u03b1),(y :\u03b2))::(t :(\u03b1 # \u03b2) list)) = (let ((L1 :\u03b1 list),(L2 :\u03b2 list)) = UNZIP t in (x::L1,y::L2))", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). DISJOINT (s DELETE x) t \u21d4 DISJOINT (t DELETE x) s", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b1) (s :\u03b3 -> bool). IMAGE f (IMAGE g s) = IMAGE (f \u2218 g) s", "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b2). P \u00d7 (x INSERT Q) = P \u00d7 {x} \u222a P \u00d7 Q", "\u2200(f :\u03b1 -> \u03b2) (n :num) (l :\u03b1 list). MAP f (TAKE n l) = TAKE n (MAP f l)", "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2203(y :\u03b1). y \u2208 IMAGE f s \u2227 P y) \u21d4 \u2203(x :\u03b2). x \u2208 s \u2227 P (f x)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 REST s \u21d4 x \u2208 s \u2227 x \u2260 CHOICE s", "REPLICATE (x :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 x = (0 :num)", "\u2200(n :num). n < SUC n", "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE y = s DELETE y DELETE x", "((p :bool) \u21d4 \u00ac(q :bool)) \u21d4 (p \u2228 q) \u2227 (\u00acq \u2228 \u00acp)", "NULL ((l1 :\u03b1 list) ++ (l2 :\u03b1 list)) \u21d4 NULL l1 \u2227 NULL l2", "IS_SOME (OPTION_MAP (f :\u03b1 -> \u03b2) (x :\u03b1 option)) \u21d4 IS_SOME x", "\u2200(M :\u03b1 option) (M' :\u03b1 option) (v :\u03b2) (f :\u03b1 -> \u03b2). M = M' \u2227 (M' = (NONE :\u03b1 option) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(x :\u03b1). M' = SOME x \u21d2 f x = (f' :\u03b1 -> \u03b2) x) \u21d2 (option_CASE M v f :\u03b2) = (option_CASE M' v' f' :\u03b2)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (f' :\u03b1 -> \u03b2) (s' :\u03b1 -> bool). s = s' \u2227 (\u2200(x :\u03b1). x \u2208 s' \u21d2 f x = f' x) \u21d2 IMAGE f s = IMAGE f' s'", "\u2200(x :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). x \u2208 P \u21d2 x \u2286 BIGUNION P", "\u2200(f :\u03b1 -> \u03b2 -> \u03b3) (x :\u03b1) (y :\u03b2). UNCURRY f (x,y) = f x y", "\u2200(sp :\u03b1 -> bool) (s :(\u03b1 -> bool) -> bool). (\u2200(t :\u03b1 -> bool). t \u2208 s \u21d2 t \u2286 sp) \u2227 s \u2260 (\u2205 :(\u03b1 -> bool) -> bool) \u21d2 BIGINTER s \u2286 sp", "(\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u222a s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u222a (\u2205 :\u03b1 -> bool) = s", "\u2200(ls :\u03b1 list). ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (l1 :\u03b2 list) (l2 :\u03b2 list). FOLDL f e (l1 ++ l2) = FOLDL f (FOLDL f e l1) l2", "\u2200(R :\u03b1 -> \u03b1 -> bool). WF R \u21d4 \u2200(x :\u03b1). WFP R x", "\u2200(l :\u03b1 list list list). FLAT (FLAT l) = FLAT (MAP (FLAT :\u03b1 list list -> \u03b1 list) l)", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). MEM x l \u2227 P x \u21d2 Q x) \u2227 EVERY P l \u21d2 EVERY Q l", "(x1 :num) \u2297 (y1 :num) = (x2 :num) \u2297 (y2 :num) \u21d4 x1 = x2 \u2227 y1 = y2", "(x :\u03b1) \u2208 RDOM ((R1 :\u03b1 -> \u03b2 -> bool) \u222a\u1d63 (R2 :\u03b1 -> \u03b2 -> bool)) \u21d4 x \u2208 RDOM R1 \u2228 x \u2208 RDOM R2", "\u2200(y :\u03b1) (x :\u03b2) (P :\u03b1 -> bool). P y \u2227 x = (f :\u03b1 -> \u03b2) y \u21d2 x \u2208 {f x | P x}", "((if (P :bool) then (X :\u03b1 option) else (NONE :\u03b1 option)) = (NONE :\u03b1 option) \u21d4 P \u21d2 IS_NONE X) \u2227 ((if P then (NONE :\u03b1 option) else X) = (NONE :\u03b1 option) \u21d4 IS_SOME X \u21d2 P) \u2227 ((if P then X else (NONE :\u03b1 option)) = SOME (x :\u03b1) \u21d4 P \u2227 X = SOME x) \u2227 ((if P then (NONE :\u03b1 option) else X) = SOME x \u21d4 \u00acP \u2227 X = SOME x)", "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INL x :\u03b1 + \u03b2) \u2208 (t :\u03b1 + \u03b2 -> bool)) \u21d2 INJ (INL :\u03b1 -> \u03b1 + \u03b2) s t", "\u2200(m :num) (n :num). m < n \u21d2 SUC m < SUC n", "PMATCH_ROW (p :\u03b2 -> \u03b3) (g :\u03b2 -> bool) (r :\u03b2 -> \u03b1) (i :\u03b3) \u2260 (NONE :\u03b1 option) \u21d4 PMATCH_ROW_COND_EX i p g", "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = (NONE :\u03b1 option) \u21d4 \u2200(n :num). G (FUNPOW f n s)", "\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P l) = FILTER P (MAP f l)", "\u2200(s :\u03b1 -> bool). COMPL (COMPL s) = s", "(y :\u03b1) \u2208 RRANGE (R :\u03b2 -> \u03b1 -> bool) \u21d4 \u2203(x :\u03b2). R x y", "LIST_REL (P :\u03b1 -> \u03b2 -> bool) (REPLICATE (n :num) (x :\u03b1)) (REPLICATE n (y :\u03b2)) \u21d4 n > (0 :num) \u21d2 P x y", "\u2200(s :\u03b1 -> bool) (t :\u03b3 -> bool) (u :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b3). BIJ f s t) \u2227 (\u2203(g :\u03b3 -> \u03b2). BIJ g t u) \u21d2 \u2203(h :\u03b1 -> \u03b2). BIJ h s u", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d4 ($= :\u03b1 -> \u03b1 -> bool) \u2286\u1d63 R", "DATATYPE ((sum :(\u03b1 -> \u03b1 + \u03b2) -> (\u03b2 -> \u03b1 + \u03b2) -> \u03b3) (INL :\u03b1 -> \u03b1 + \u03b2) (INR :\u03b2 -> \u03b1 + \u03b2))", "GENLIST (f :num -> \u03b1) (SUC (n :num)) = f (0 :num)::GENLIST (f \u2218 SUC) n", "\u2200(n :num) (l1 :\u03b1 list). n \u2264 LENGTH l1 \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ l2", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (l :\u03b1 list). MAP f (SNOC x l) = SNOC (f x) (MAP f l)", "INVOL $\u00ac", "\u2200(f :\u03b1 -> num) (x :\u03b1) (y :\u03b1). measure f x y \u21d4 f x < f y", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b1 -> \u03b2). f (EXT_POINT f g) = g (EXT_POINT f g) \u21d4 f = g", "\u2200(t :bool). t \u2228 F \u21d4 t", "\u2200(l :\u03b1 list). \u00acNULL l \u21d4 \u2203(e :\u03b1). MEM e l", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool) (l :\u03b1 list). FOLDR f e (FILTER P l) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e l", "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool) \u21d2 \u2200(t :\u03b1 -> bool). t \u2208 partition R s \u21d2 \u2200(x :\u03b1) (y :\u03b1). x \u2208 t \u2227 y \u2208 t \u21d2 R x y", "\u2200(v :\u03b1) (rs1 :(\u03b1 -> \u03b2 option) list) (rs2 :(\u03b1 -> \u03b2 option) list) (i :num). i < LENGTH rs1 \u21d2 (PMATCH_ROW_REDUNDANT v (rs1 ++ rs2) i \u21d4 PMATCH_ROW_REDUNDANT v rs1 i)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). IS_SUFFIX l1 l2 \u21d4 REVERSE l2 \u227c REVERSE l1", "\u2200(f :\u03b1 # \u03b2 -> \u03b3). UNCURRY (CURRY f) = f", "EL (NUMERAL (BIT1 (n :num))) ((l :\u03b1)::(ls :\u03b1 list)) = EL (PRE (NUMERAL (BIT1 n))) ls \u2227 EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls", "\u2200(a1 :\u03b1 list) (a0 :\u03b1). a0::a1 \u2260 ([] :\u03b1 list)", "\u2200(x :num) (y :num). x \u2297 y = (0 :num) \u21d4 x = (0 :num) \u2227 y = (0 :num)", "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\u207a x y \u2227 R\u207a y z \u21d2 R\u207a x z", "\u2200(v_old :\u03b1) (v_new :\u03b2) (rows_old :(\u03b1 -> \u03b3 option) list) (rows_new :(\u03b2 -> \u03b3 option) list) (r_old :\u03b1 -> \u03b3 option) (r_new :\u03b2 -> \u03b3 option). r_old v_old = r_new v_new \u21d2 PMATCH v_old rows_old = PMATCH v_new rows_new \u21d2 PMATCH v_old (r_old::rows_old) = PMATCH v_new (r_new::rows_new)", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2286 s \u21d2 FINITE t", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 INJ f s (IMAGE f s)", "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x \u2208 y INSERT s \u21d4 x = y \u2228 x \u2208 s", "\u2200(v :\u03b1) (rows1 :(\u03b1 -> \u03b2 option) list) (rows2 :(\u03b1 -> \u03b2 option) list). PMATCH_EQUIV_ROWS v rows1 rows2 \u21d4 PMATCH_EQUIV_ROWS v rows2 rows1", "(antisymmetric (R1 :\u03b1 -> \u03b1 -> bool) \u21d2 antisymmetric (R1 \u2229\u1d63 (R2 :\u03b1 -> \u03b1 -> bool))) \u2227 (antisymmetric R2 \u21d2 antisymmetric (R1 \u2229\u1d63 R2))", "\u2200(s :\u03b1 -> bool) (M :\u03b1 -> num). (\u2203(x :\u03b1). x \u2208 s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 \u2200(y :\u03b1). y \u2208 s \u21d2 M x \u2264 M y", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u2229 t) \u2286 IMAGE f s \u2229 IMAGE f t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = COMPL (COMPL s \u222a COMPL t)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). WF R \u2227 (\u2200(x :\u03b1) (y :\u03b1). P x y \u21d2 R x y) \u21d2 WF P", "\u2200(f1 :num -> \u03b1 -> bool) (f1' :num -> \u03b1 -> bool) (f2 :num -> \u03b1 -> bool) (f2' :num -> \u03b1 -> bool). ind_type$INJP f1 f2 = ind_type$INJP f1' f2' \u21d4 f1 = f1' \u2227 f2 = f2'", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 \u2203(u :\u03b1). R x u \u2227 R\ua673 u y", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a t = t \u222a s", "\u2200(x :\u03b1) (y :\u03b1 list) (a :\u03b1) (b :\u03b1 list). SNOC x y = SNOC a b \u21d4 x = a \u2227 y = b", "\u2200(n :num). TAKE n ([] :\u03b1 list) = ([] :\u03b1 list)", "DROP (n :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 n) a", "((a :\u03b1),(b :\u03b2)) \u2208 {(y,(x :\u03b2)) | (P :\u03b1 -> bool) y} \u21d4 P a \u2227 b = x", "\u2200(l :\u03b1 list list). FLAT (REVERSE l) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))", "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). FILTER P (FILTER Q l) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l", "\u2200(x :\u03b1 option). (option_CASE x (NONE :\u03b1 option) (SOME :\u03b1 -> \u03b1 option) :\u03b1 option) = x", "FINITE (\u2205 :\u03b1 -> bool)", "\u2200(s :\u03b1 -> bool) (e :\u03b1) (s2 :\u03b1 -> bool). s DELETE e \u2286 s2 \u21d4 s \u2286 e INSERT s2", "\ud835\udd4c(:\u03b1 -> bool) = POW \ud835\udd4c(:\u03b1)", "NULL ([] :\u03b1 list) \u2227 \u2200(h :\u03b1) (t :\u03b1 list). \u00acNULL (h::t)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1). R^= x x", "\u2200(v :\u03b1). IS_REDUNDANT_ROWS_INFO v ([] :(\u03b1 -> \u03b2 option) list) T ([] :bool list)", "\u2200(f :\u03b1 -> \u03b2) (s :(\u03b2 -> bool) -> bool). PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)", "\u2200(f :'z -> 'z). IDEM f \u21d4 \u2200(x :'z). f (f x) = f x", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s DELETE x", "(OPTION_MAP (f :\u03b2 -> \u03b1) (x :\u03b2 option) = (NONE :\u03b1 option) \u21d4 x = (NONE :\u03b2 option)) \u2227 ((NONE :\u03b1 option) = OPTION_MAP f x \u21d4 x = (NONE :\u03b2 option))", "\u2200(x :\u03b1) (y :\u03b1 list) (z :\u03b1 list). z \u227c SNOC x y \u21d4 z \u227c y \u2228 z = SNOC x y", "\u2200(c :num) (i :\u03b1) (r :num -> num -> \u03b1 -> bool). ind_type$ZCONSTR c i r \u2260 (ind_type$ZBOT :num -> \u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). \u2203(fn :\u03b1 # \u03b2 -> \u03b3). \u2200(x :\u03b1) (y :\u03b2). fn (x,y) = f x y", "(set (l :\u03b1 list) = (\u2205 :\u03b1 -> bool) \u21d4 l = ([] :\u03b1 list)) \u2227 ((\u2205 :\u03b1 -> bool) = set l \u21d4 l = ([] :\u03b1 list))", "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 p", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b3 -> bool). PREIMAGE f (PREIMAGE g s) = PREIMAGE (g \u2218 f) s", "\u2200(x :\u03b1) (n :num) (ys :\u03b1 list). LENGTH (LUPDATE x n ys) = LENGTH ys", "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u222a s = \ud835\udd4c(:\u03b1)) \u2227 \u2200(s :\u03b1 -> bool). s \u222a \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)", "\u2200(M :\u03b2 # \u03b3) (M' :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1). M = M' \u2227 (\u2200(x :\u03b2) (y :\u03b3). M' = (x,y) \u21d2 f x y = (f' :\u03b2 -> \u03b3 -> \u03b1) x y) \u21d2 (pair_CASE M f :\u03b1) = (pair_CASE M' f' :\u03b1)", "\u2200(R :\u03b1 -> \u03b1 -> bool). (RC R)\u1d40 = RC R\u1d40", "\u2200(n :num). SUC n \u2260 (0 :num)", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (LASTN n l) = ([] :\u03b1 list)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a t = (\u2205 :\u03b1 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool) \u2227 t = (\u2205 :\u03b1 -> bool)", "\u2200(s :num -> bool). (\u2203(n :num). n \u2208 s) \u21d4 \u2203(n :num). n \u2208 s \u2227 \u2200(m :num). m \u2208 s \u21d2 n \u2264 m", "((\u2203(opt :\u03b1 option). (P :\u03b1 option -> bool) opt) \u21d4 P (NONE :\u03b1 option)) \u2228 \u2203(x :\u03b1). P (SOME x)", "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EVERY P (l1 ++ l2) \u21d4 EVERY P l1 \u2227 EVERY P l2", "\u2200(v :\u03b1) (rs :(\u03b1 -> \u03b2 option) list). (EVERY (\u03bb(r :\u03b1 -> \u03b2 option). r v = (NONE :\u03b2 option)) rs \u21d2 F) \u21d2 PMATCH_IS_EXHAUSTIVE v rs", "(s1 :\u03b1 -> bool) \u2286 (s2 :\u03b1 -> bool) \u21d2 REL_RESTRICT (R :\u03b1 -> \u03b1 -> bool) s1 \u2286\u1d63 REL_RESTRICT R s2", "nsnd (n :num) \u2264 n", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\u207a x z", "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 (\u2205 :\u03b1 -> bool))", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t DIFF t = s DIFF t", "\u2200(c :bool) (x :bool). (if c then x else F) \u21d4 c \u2227 x", "(R :\u03b1 -> \u03b2 -> bool) \u2218\u1d63 ($= :\u03b1 -> \u03b1 -> bool) = R", "\u2200(p :\u03b1 # \u03b2) (f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4). FST ((f ## g) p) = f (FST p)", "\u2200(n :num). count n DELETE n = count n", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a (s DIFF t) = s", "PMATCH_ROW (p :\u03b2 -> \u03b3) (g :\u03b2 -> bool) (r :\u03b2 -> \u03b1) (v :\u03b3) \u2260 (NONE :\u03b1 option) \u21d2 PMATCH v (PMATCH_ROW p g r::(rs :(\u03b3 -> \u03b1 option) list)) = r (@(x :\u03b2). PMATCH_ROW_COND p g v x)", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b4) (x :\u03b1) (y :\u03b3). (f ## g) (x,y) = (f x,g y)", "\u2200(n :num). ALL_DISTINCT (COUNT_LIST n)", "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = [(x :\u03b2)] \u21d4 \u2203(x0 :\u03b1). l = [x0] \u2227 x = f x0", "\u2200(y :\u03b1 -> \u03b2 -> bool) (z :\u03b1 -> \u03b2 -> bool). y = z \u21d4 y \u2286\u1d63 z \u2227 z \u2286\u1d63 y", "LIST_BIND ((l1 :\u03b2 list) ++ (l2 :\u03b2 list)) (f :\u03b2 -> \u03b1 list) = LIST_BIND l1 f ++ LIST_BIND l2 f", "IDEM (SC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "\u2200(n :num) (l2 :\u03b1 list). n \u2264 LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). LASTN n (l1 ++ l2) = LASTN n l2", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 {y} \u21d4 x = y", "\u2200(t1 :\u03b1) (t2 :\u03b1). (if T then t1 else t2) = t1", "\u2200(o1 :\u03b1 option) (o2 :\u03b1 option) (f1 :\u03b1 -> \u03b2 option) (f2 :\u03b1 -> \u03b2 option). o1 = o2 \u2227 (\u2200(x :\u03b1). o2 = SOME x \u21d2 f1 x = f2 x) \u21d2 OPTION_BIND o1 f1 = OPTION_BIND o2 f2", "\u2200(L :num list). SUM L = SUM_ACC L (0 :num)", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\u1d40 \u21d4 reflexive R", "(\u2200(x :\u03b1) (y :\u03b2) (z :\u03b1). (if (P :bool) then (INR x :\u03b2 + \u03b1) else (INL y :\u03b2 + \u03b1)) = (INR z :\u03b2 + \u03b1) \u21d4 P \u2227 z = x) \u2227 (\u2200(x :\u03b3) (y :\u03b4) (z :\u03b4). (if P then (INR x :\u03b4 + \u03b3) else (INL y :\u03b4 + \u03b3)) = (INL z :\u03b4 + \u03b3) \u21d4 \u00acP \u2227 z = y) \u2227 (\u2200(x :\u03b5) (y :\u03b6) (z :\u03b5). (if P then (INL x :\u03b5 + \u03b6) else (INR y :\u03b5 + \u03b6)) = (INL z :\u03b5 + \u03b6) \u21d4 P \u2227 z = x) \u2227 \u2200(x :\u03b7) (y :\u03b8) (z :\u03b8). (if P then (INL x :\u03b7 + \u03b8) else (INR y :\u03b7 + \u03b8)) = (INR z :\u03b7 + \u03b8) \u21d4 \u00acP \u2227 z = y", "\u2200(h :\u03b1) (l1 :\u03b1 list) (l2 :\u03b1 list). LAST (l1 ++ h::l2) = LAST (h::l2)", "trichotomous (STRORD (R :\u03b1 -> \u03b1 -> bool)) \u21d4 trichotomous R", "\u2200(l :\u03b1 list) (x :\u03b1) (y :\u03b1) (i :num). MEM x (LUPDATE y i l) \u21d4 i < LENGTH l \u2227 x = y \u2228 \u2203(j :num). j < LENGTH l \u2227 i \u2260 j \u2227 EL j l = x", "numeral$iiSUC ZERO = BIT2 ZERO \u2227 numeral$iiSUC (BIT1 (n :num)) = BIT1 (SUC n) \u2227 numeral$iiSUC (BIT2 n) = BIT2 (SUC n)", "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 (A \u21d2 F) \u21d2 \u00acB \u21d2 F", "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). total R \u21d2 total (inv_image R f)", "numeral$texp_help (n :num) (0 :num) = (2 :num) ** (n + (1 :num))", "BIGUNION (\u2205 :(\u03b1 -> bool) -> bool) = (\u2205 :\u03b1 -> bool)", "\u2200(P :\u03b1 -> \u03b2 -> bool). (\u2203(x :\u03b1) (y :\u03b2). P x y) \u21d4 \u2203((x :\u03b1),(y :\u03b2)). P x y", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 t \u21d2 DISJOINT s u", "PMATCH_ROW_COND_EX (i :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool) \u21d4 \u2203(x :\u03b2). i = p x \u2227 g x", "FILTER (P :\u03b1 -> bool) ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 (\u2200(h :\u03b1). P h \u21d2 FILTER P (h::(l :\u03b1 list)) = h::FILTER P l) \u2227 \u2200(h :\u03b1). \u00acP h \u21d2 FILTER P (h::l) = FILTER P l", "\u2200(c :bool) (x :bool). (if c then x else T) \u21d4 c \u21d2 x", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u2229 t \u21d4 x \u2208 s \u2227 x \u2208 t", "IDEM (STRORD :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "(\u2200(x :\u03b1) (y :\u03b2). (P :\u03b1 -> \u03b2 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b2 -> bool) x y) \u21d2 OPTREL P (x :\u03b1 option) (y :\u03b2 option) \u21d2 OPTREL Q x y", "(\u2200(x :num). pair_to_num (num_to_pair x) = x) \u2227 \u2200(x :num) (y :num). num_to_pair (pair_to_num (x,y)) = (x,y)", "\u2200(n :num). (0 :num) < n \u21d4 count n \u2260 (\u2205 :num -> bool)", "\u2200(ls :\u03b1 list) (n :num). n < LENGTH ls \u21d2 DROP n ls = EL n ls::DROP (n + (1 :num)) ls", "(2 :num) * tri (n :num) = n * (n + (1 :num))", "(x :\u03b1) \u2208 BIGINTER (B :(\u03b1 -> bool) -> bool) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P", "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x \u2286 s", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). x \u2208 s \u21d4 MEM x (SET_TO_LIST s)", "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (x :\u03b1). s1 \u2286 s2 \u21d2 s1 DELETE x \u2286 s2 DELETE x", "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t", "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 POW s1 \u2286 POW s2", "MAX_SET (\u2205 :num -> bool) = (0 :num) \u2227 MAX_SET {(e :num)} = e", "OPTION_MAP (f :\u03b1 -> \u03b2) (x :\u03b1 option) = (option_CASE x (NONE :\u03b2 option) ((SOME :\u03b2 -> \u03b2 option) \u2218 f) :\u03b2 option)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 RC R x y \u2228 R\u207a x y", "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\ua673 x z", "\u2200(x :\u03b1) (y :\u03b2). (INR y :\u03b1 + \u03b2) \u2260 (INL x :\u03b1 + \u03b2)", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = x INSERT s \u222a t", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 DROP n l = EL n l::DROP (SUC n) l", "\u2200(s :\u03b1 -> bool). FINITE s \u21d4 s HAS_SIZE CARD s", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (LASTN n l) = n", "\u2200(opt :\u03b1 option). IS_SOME opt \u21d4 \u2203(x :\u03b1). opt = SOME x", "\u2200(x :\u03b1) (sos :(\u03b1 -> bool) -> bool). x \u2208 BIGUNION sos \u21d4 \u2203(s :\u03b1 -> bool). x \u2208 s \u2227 s \u2208 sos", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2228 Q x} = {x | P x} \u222a {x | Q x}", "([] :\u03b1 list) \u2208 (s :\u03b1 list -> bool) \u21d2 longest_prefix s = ([] :\u03b1 list)", "\u2200(R :\u03b1 -> \u03b1 -> bool). SC (SC R) = SC R", "\u2200(a :\u03b1 -> bool) (b :\u03b2 -> bool) (c :\u03b2 -> bool). FUNSET a (b \u2229 c) = FUNSET a b \u2229 FUNSET a c", "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(x :\u03b1). x \u2209 s", "\u2200(l :\u03b1 list list). LENGTH (FLAT l) = SUM (MAP (LENGTH :\u03b1 list -> num) l)", "\u2200(n :num) (m :num) (l :\u03b1 list). m \u2264 n \u21d2 TAKE m l ++ TAKE (n \u2212 m) (DROP m l) = TAKE n l", "\u2200(x :\u03b1) (l :\u03b1 list). \u00acNULL (SNOC x l)", "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 FINITE s \u21d2 CARD (IMAGE f s) = CARD s", "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(l :\u03b1 list). P l \u21d2 \u2200(a :\u03b1). P (a::l)) \u21d2 \u2200(l :\u03b1 list). P l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2286 s", "\u2200(l :\u03b1 list). BUTLASTN (LENGTH l) l = ([] :\u03b1 list)", "\u2200(P :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list). LIST_REL P l1 l2 \u21d2 LENGTH l1 = LENGTH l2", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f (COMPL s) = COMPL (PREIMAGE f s)", "symmetric (R :\u03b1 -> \u03b1 -> bool)^=", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (DROP m l)", "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). BIJ f s t) \u21d4 \u2203(g :\u03b2 -> \u03b1). BIJ g t s", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d2 t = IMAGE f s", "\u2200(l1 :\u03b1 list) (x :\u03b1) (l2 :\u03b1 list). l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)", "CURRY (f :\u03b1 # \u03b2 -> \u03b3) = CURRY (g :\u03b1 # \u03b2 -> \u03b3) \u21d4 f = g", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 TAKE n l = BUTLASTN (LENGTH l \u2212 n) l", "\u2200(x :\u03b1). \ud835\udd4c(:\u03b1) x", "\u2200(m :num) (n :num). TAKE n (TAKE m (l :\u03b1 list)) = TAKE (MIN n m) l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u222a t) = IMAGE f s \u222a IMAGE f t", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\u207a x y \u21d2 f x = f y", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t", "\u2200(A :\u03b1 -> bool) (B :\u03b1 -> bool) (x :\u03b1). A \u222a B DELETE x = A DELETE x \u222a (B DELETE x)", "(\u2200(l :\u03b1 list). BUTLASTN (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b2) (l :\u03b2 list). BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R\ua673 x y", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 TAKE n (REVERSE l) = REVERSE (LASTN n l)", "\u2200(xs :\u03b1 option list) (n :num) (f :\u03b1 -> \u03b2) (h :\u03b1). LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) = MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 x INSERT s DELETE x = s", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 RC R = R", "(OPTION_BIND (p :\u03b1 option) (f :\u03b1 -> \u03b2 option) = (NONE :\u03b2 option) \u21d4 p = (NONE :\u03b1 option) \u2228 \u2203(x :\u03b1). p = SOME x \u2227 f x = (NONE :\u03b2 option)) \u2227 (OPTION_BIND p f = SOME (y :\u03b2) \u21d4 \u2203(x :\u03b1). p = SOME x \u2227 f x = SOME y)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set l1 \u222a set l2 = set (l1 ++ l2)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 \u2203(u :\u03b1). R\ua673 x u \u2227 R\ua673 u y", "MIN (0 :num) (x :num) = (0 :num) \u2227 MIN x (0 :num) = (0 :num) \u2227 MIN (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then x else y)", "\u2200(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (x' \u21d2 x) \u2227 (y' \u21d2 y) \u21d2 (if c then x' else y') \u21d2 if c then x else y", "\u2200(P :\u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 s \u222a t \u21d2 P x) \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 P x) \u2227 \u2200(x :\u03b1). x \u2208 t \u21d2 P x", "PMATCH_ROW (p :\u03b2 -> \u03b3) (g :\u03b2 -> bool) (r :\u03b2 -> \u03b1) (i :\u03b3) = (NONE :\u03b1 option) \u21d4 \u2200(x :\u03b2). \u00acPMATCH_ROW_COND p g i x", "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1) (l :\u03b2 list). FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 \u2218 f2) l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2286 u \u21d2 s \u2286 u", "(\u2200(R :\u03b1 -> \u03b2 -> bool) (x :\u03b1) (y :\u03b2 option). OPTREL R (SOME x) y \u21d4 \u2203(z :\u03b2). y = SOME z \u2227 R x z) \u2227 \u2200(R :\u03b3 -> \u03b4 -> bool) (x :\u03b3 option) (y :\u03b4). OPTREL R x (SOME y) \u21d4 \u2203(z :\u03b3). x = SOME z \u2227 R z y", "\u2200(m :num) (n :num). m < SUC n \u21d2 m = n \u2228 m < n", "tri (n :num) = n * (n + (1 :num)) DIV (2 :num)", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1) (l :\u03b1 list). FOLDR f e (SNOC x l) = FOLDR f (f x e) l", "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list). LENGTH l1 = LENGTH l2 \u21d2 (ZIP (l1,l2) = ([] :(\u03b1 # \u03b2) list) \u21d4 l1 = ([] :\u03b1 list) \u2227 l2 = ([] :\u03b2 list))", "{x | x \u2208 (y :\u03b1 -> bool)} = y", "\u2200(n :num). n \u2260 (0 :num) \u21d2 COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n \u2212 (1 :num)))", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). WF R \u21d2 R x y \u21d2 x \u2260 y", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a (t \u222a u) = s \u222a t \u222a u", "\u2200(m :num) (n :num). m < SUC n \u21d4 m = n \u2228 m < n", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 \u2203(x :\u03b1). x \u2209 s \u2227 x INSERT s \u2286 t", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t DELETE x \u21d4 x \u2209 s \u2227 s \u2286 t", "(\u2200(l :\u03b1 list). DROP (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). DROP (SUC n) (x::l) = DROP n l", "\u2200(n :num) (f :num -> \u03b1). (0 :num) < n \u21d2 HD (GENLIST f n) = f (0 :num)", "\u2200(x :\u03b1 list) (y :\u03b2 list). LIST_REL (R :\u03b1 -> \u03b2 -> bool) x y \u21d2 LENGTH x = LENGTH y", "(l1 :\u03b1 list) ++ (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]", "\u2200(b :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (x :\u03b1) (y :\u03b2). INJ b s t \u2227 x \u2209 s \u2227 y \u2209 t \u21d2 INJ b\u2987x \u21a6 y\u2988 (x INSERT s) (y INSERT t)", "\u2200(n :num) (x :\u03b1) (l :\u03b1 list). ELL (SUC n) (SNOC x l) = ELL n l", "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). SEG n m (SNOC x l) = SEG n m l", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). (IMAGE f s = (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)) \u2227 ((\u2205 :\u03b2 -> bool) = IMAGE f s \u21d4 s = (\u2205 :\u03b1 -> bool))", "\u2200(L :(\u03b1 # \u03b2) list). UNZIP L = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) L,MAP (SND :\u03b1 # \u03b2 -> \u03b2) L)", "\u2200(p :\u03b1 # \u03b2) (p' :\u03b1 # \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). p = p' \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (P x \u21d4 P' x)) \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (Q y \u21d4 Q' y)) \u21d2 (PROD_ALL P Q p \u21d4 PROD_ALL P' Q' p')", "SET_TO_LIST (\u2205 :\u03b1 -> bool) = ([] :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool) (t :\u03b3 -> bool). BIGUNION (IMAGE f s) \u00d7 t = BIGUNION (IMAGE (\u03bb(n :\u03b1). f n \u00d7 t) s)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool) (v :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 s \u2227 v \u2286 t \u21d2 DISJOINT u v", "FST (p :\u03b1 # \u03b2) = (x :\u03b1) \u21d4 \u2203(y :\u03b2). p = (x,y)", "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u21d2 LENGTH x \u2264 LENGTH y", "\u2200(x :\u03b1). one_CASE () x = x", "\u2200(A :\u03b1 -> bool) (B :\u03b2 -> bool) (C :\u03b1 -> bool) (D :\u03b2 -> bool). A \u00d7 B \u2229 (C \u00d7 D) = A \u2229 C \u00d7 (B \u2229 D)", "\u2200(x :\u03b1) (y :\u03b1). {y} x \u21d4 x = y", "WeakOrder ($RSUBSET :(\u03b1 -> \u03b2 -> bool) -> (\u03b1 -> \u03b2 -> bool) -> bool)", "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2203(f :\u03b1 -> \u03b1). (\u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d2 x = y) \u2227 \u2203(y :\u03b1). \u2200(x :\u03b1). f x \u2260 y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1). R\u207a x z \u21d2 R x z \u2228 \u2203(y :\u03b1). R\u207a x y \u2227 R y z", "\u2200(R :\u03b1 -> \u03b1 -> bool) (RTC' :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). RTC' x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 RTC' y z \u21d2 RTC' x z) \u21d2 \u2200(a0 :\u03b1) (a1 :\u03b1). R\ua673 a0 a1 \u21d2 RTC' a0 a1", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT s \u2260 (\u2205 :\u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2). PREIMAGE f \ud835\udd4c(:\u03b2) = \ud835\udd4c(:\u03b1)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F l", "IDEM (RC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)", "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION P \u2286 X \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 Y \u2286 X", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1). IMAGE f {x} = {f x}", "((\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b2 -> bool) \u21d4 R = (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)) \u2227 R \u2286\u1d63 (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)", "\u2200(x :\u03b1 + \u03b2). ISL x \u2228 ISR x", "transitive (R :\u03b1 -> \u03b1 -> bool) \u21d4 R \u2218\u1d63 R \u2286\u1d63 R", "\u00acF \u21d4 T", "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acp", "WF $<", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). BIJ f s t \u2227 BIJ g t u \u21d2 BIJ (g \u2218 f) s u", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 s DIFF t \u2260 (\u2205 :\u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2) (v :\u03b3) (p :\u03b2 -> \u03b3) (g :\u03b2 -> bool) (p' :\u03b1 -> \u03b3) (g' :\u03b1 -> bool). \u00acPMATCH_ROW_COND_EX v p g \u21d2 (\u2200(x :\u03b1). p' x = p (f x)) \u21d2 (PMATCH_ROW_COND_EX v p' g' \u21d4 PMATCH_ROW_COND_EX v p' (\u03bb(x :\u03b1). g' x \u2227 \u00acg (f x)))", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list list). MAP f (FLAT l) = FLAT (MAP (MAP f) l)", "\u2200(m :num) (n :num). SUC m = SUC n \u21d2 m = n", "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2209 s \u21d2 s DELETE x = s", "\u2200(l1 :\u03b1 list) (x :\u03b1) (l2 :\u03b1 list). SNOC x l1 ++ l2 = l1 ++ x::l2", "pairwise (R :\u03b1 -> \u03b1 -> bool) ((s1 :\u03b1 -> bool) \u222a (s2 :\u03b1 -> bool)) \u21d4 pairwise R s1 \u2227 pairwise R s2 \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 s1 \u2227 y \u2208 s2 \u21d2 R x y \u2227 R y x", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u2229 t = s", "\u2200(l :\u03b1 list). REVERSE l = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l", "\u2200(x :\u03b1 # \u03b2). \u2203(q :\u03b1) (r :\u03b2). x = (q,r)", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). BIGINTER {P; Q} = P \u2229 Q", "\u2200(m :\u03b1) (n :\u03b1). (\u03bb(x :\u03b1) (y :\u03b1). y = (f :\u03b1 -> \u03b1) x)\ua673 (f m) n \u21d4 (\u03bb(x :\u03b1) (y :\u03b1). y = f x)\u207a m n", "\u2200(xs :\u03b1 list) (n :num) (k :num). DROP n (TAKE k xs) = TAKE (k \u2212 n) (DROP n xs)", "\u2200(n :num) (l2 :\u03b1 list). n < LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). ELL n (l1 ++ l2) = ELL n l2", "(\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b1 -> bool) \u2227 (R \u2286\u1d63 (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u21d4 R = (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool))", "\u2200(P :\u03b1 -> bool) (ls :\u03b1 list). EXISTS ($\u00ac \u2218 P) ls \u21d2 LENGTH (FILTER P ls) < LENGTH ls", "LIST_BIND (l :\u03b1 list) (\u03bb(x :\u03b1). [x]) = l", "(some(x :bool). \u00acx) = SOME F", "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s DELETE x \u2286 t", "\u2200(P :\u03b1 + \u03b2 -> bool). (\u2200(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2227 (\u2200(y :\u03b2). P (INR y :\u03b1 + \u03b2)) \u21d2 \u2200(s :\u03b1 + \u03b2). P s", "\u2200(P :\u03b1 -> bool) (a :\u03b1) (s :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 a INSERT s \u21d2 P x) \u21d4 P a \u2227 \u2200(x :\u03b1). x \u2208 s \u21d2 P x", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EVERY P (l :\u03b1 list) \u21d2 EVERY Q l", "(LIST_REL (R :\u03b1 -> \u03b2 -> bool) ([] :\u03b1 list) (y :\u03b2 list) \u21d4 y = ([] :\u03b2 list)) \u2227 (LIST_REL R (x :\u03b1 list) ([] :\u03b2 list) \u21d4 x = ([] :\u03b1 list))", "\u2200(l :bool list). OR_EL l \u21d4 FOLDL $\\/ F l", "\u2200(R :\u03b1 -> \u03b1 -> bool). antisymmetric (RC R) \u21d4 antisymmetric R", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 f x = f y", "\u2200(x :\u03b1) (s :\u03b1 -> bool). PREIMAGE (K x :\u03b2 -> \u03b1) s = if x \u2208 s then \ud835\udd4c(:\u03b2) else (\u2205 :\u03b2 -> bool)", "\u2200(xs :\u03b1 list) (i :num) (n :num) (x :\u03b1). oEL n (LUPDATE x i xs) = if i \u2260 n then oEL n xs else if i < LENGTH xs then SOME x else (NONE :\u03b1 option)", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\ua673", "(list_CASE (x :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). x = a::l \u2227 f a l = v'", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n (REVERSE l) = REVERSE (TAKE n l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u2227 t \u2286 s \u21d4 s = t", "(p :bool) \u2227 (q :bool) \u21d2 q", "\u2200(P :\u03b1 -> bool) (ls :\u03b1 list). dropWhile P ls = ([] :\u03b1 list) \u21d4 EVERY P ls", "\u2200(p :\u03b1 -> bool) (q :\u03b1 -> bool). p \u2229 q \u222a COMPL p \u2229 q = q", "((p :bool) \u21d4 (q :bool) \u21d2 (r :bool)) \u21d4 (p \u2228 q) \u2227 (p \u2228 \u00acr) \u2227 (\u00acq \u2228 r \u2228 \u00acp)", "(pair_CASE ((x :\u03b2),(y :\u03b3)) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = f x y", "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGUNION (s1 \u222a s2) = BIGUNION s1 \u222a BIGUNION s2", "FINITE (s :\u03b1 -> bool) \u2227 SURJ (f :\u03b1 -> \u03b2) s (t :\u03b2 -> bool) \u21d2 FINITE t", "OPTION_MAP (f :\u03b3 -> \u03b2) (OPTION_MAP (g :\u03b1 -> \u03b3) (x :\u03b1 option)) = OPTION_MAP (f \u2218 g) x", "\u2200(f :num -> \u03b1) (n :num). set (GENLIST f n) = IMAGE f (count n)", "\u2200(m :num) (n :num). m = n \u2228 m < n \u21d2 m < SUC n", "REVERSE (l :\u03b1 list) = [(e :\u03b1)] \u21d4 l = [e]", "\u2200(n :num). SUM_SET {n} = n", "\u2200(f1 :num -> num -> \u03b1 -> bool) (f2 :num -> num -> \u03b1 -> bool). ind_type$INJF f1 = ind_type$INJF f2 \u21d4 f1 = f2", "LIST_REL (R :\u03b1 -> \u03b2 -> bool) ((h :\u03b1)::(t :\u03b1 list)) (xs :\u03b2 list) \u21d4 \u2203(h' :\u03b2) (t' :\u03b2 list). xs = h'::t' \u2227 R h h' \u2227 LIST_REL R t t'", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). DROP n (SNOC x l) = SNOC x (DROP n l)", "\u2200(x :\u03b1) (y :\u03b2). FST (x,y) = x", "is_measure_maximal (m :\u03b1 -> num) {(x :\u03b1)} (y :\u03b1) \u21d4 y = x", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 \u00acEVERY (\u03bb(x :\u03b1). \u00acP x) l", "\u2200(x :\u03b1 option). IS_NONE x \u21d4 x = (NONE :\u03b1 option)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (y \u21d2 x \u21d2 x') \u2227 (x' \u21d2 y \u21d2 y') \u21d2 x \u2227 y \u21d2 x' \u2227 y'", "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool) \u21d2 (\u2205 :\u03b1 -> bool) \u2209 partition R s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 RC R x y", "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a \u227c b ++ c \u21d2 a \u227c b \u2228 b \u227c a", "\u2200(n :num). set (COUNT_LIST n) = count n", "\u2200(x :\u03b1 option option) (y :\u03b1). OPTION_JOIN x = SOME y \u21d4 x = SOME (SOME y)", "\u00ac(A :bool) \u21d2 F \u21d4 A", "\u2200(s :\u03b1 -> bool). REST s \u2286 s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). symmetric R \u21d2 symmetric (inv_image R f)", "\u2200(R :\u03b1 -> \u03b1 -> bool). RC (RC R) = RC R", "PRE (0 :num) = (0 :num) \u2227 \u2200(m :num). PRE (SUC m) = m", "\u2200(l :\u03b1 list). TAKE (LENGTH l) l = l", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2) (ls :\u03b1 list). ALL_DISTINCT ls \u21d2 (MEM x (ZIP (ls,MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x))", "LIST_BIND (l :\u03b1 list list) (\u03bb(x :\u03b1 list). x) = FLAT l \u2227 LIST_BIND l (I :\u03b1 list -> \u03b1 list) = FLAT l", "\u2200(v_old :\u03b1) (v_new :\u03b2) (rows_old :(\u03b1 -> \u03b3 option) list) (rows_new :(\u03b2 -> \u03b3 option) list) (r_old :\u03b1 -> \u03b3 option). r_old v_old = (NONE :\u03b3 option) \u21d2 PMATCH v_old rows_old = PMATCH v_new rows_new \u21d2 PMATCH v_old (r_old::rows_old) = PMATCH v_new rows_new", "\u2200(x1 :\u03b1 option) (x2 :\u03b1 option) (y1 :\u03b2 option) (y2 :\u03b2 option) (f1 :\u03b1 -> \u03b2 -> \u03b3) (f2 :\u03b1 -> \u03b2 -> \u03b3). x1 = x2 \u2227 y1 = y2 \u2227 (\u2200(x :\u03b1) (y :\u03b2). x2 = SOME x \u2227 y2 = SOME y \u21d2 f1 x y = f2 x y) \u21d2 OPTION_MAP2 f1 x1 y1 = OPTION_MAP2 f2 x2 y2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = REVERSE l2 \u21d4 l2 = REVERSE l1", "\u2200(x :\u03b1) (y :\u03b2) (l :(\u03b1 # \u03b2) list). MEM (x,y) l \u21d2 \u2203(z :\u03b1 # \u03b2). x = FST z \u2227 MEM z l", "$? (UNCURRY (\u03bb(x :\u03b1). (P :\u03b1 -> \u03b2 -> bool) x)) \u21d4 \u2203(x :\u03b1). $? (P x)", "\u2200(s :\u03b1 -> bool). s \u2286 \ud835\udd4c(:\u03b1)", "\u2200(f :\u03b1 -> num) (g :\u03b1 -> num) (ls :\u03b1 list). SUM (MAP (\u03bb(x :\u03b1). f x + g x) ls) = SUM (MAP f ls) + SUM (MAP g ls)", "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 -> \u03b2 -> bool) (FST p) (SND p)) \u21d4 \u2200(p1 :\u03b1) (p2 :\u03b2). P p1 p2", "\u2200(P :\u03b1 -> bool) (L :\u03b1 list) (x :\u03b1). MEM x (FILTER P L) \u21d4 P x \u2227 MEM x L", "\u2200(j :num) (n :num) (h :\u03b1) (t :\u03b1 list). (0 :num) < j \u2227 n + j \u2264 LENGTH t + (1 :num) \u21d2 SEG n j (h::t) = SEG n (j \u2212 (1 :num)) t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t = s \u2229 COMPL t", "($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(h :\u03b1) (t :\u03b1 list). TL (h::t) = t", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT l) = PRE (LENGTH l)", "\u2200(l :\u03b1 list). l = ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). l = h::t", "((p :bool) \u21d4 ((q :bool) \u21d4 (r :bool))) \u21d4 (p \u2228 q \u2228 r) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (q \u2228 \u00acr \u2228 \u00acp) \u2227 (r \u2228 \u00acq \u2228 \u00acp)", "\ud835\udd4c(:\u03b1) \u2260 (\u2205 :\u03b1 -> bool)", "(((f :(\u03b1 -> \u03b2) option) <*> SOME (x :\u03b1)) :\u03b2 option) = ((SOME (\u03bb(f :\u03b1 -> \u03b2). f x) <*> f) :\u03b2 option)", "((a :\u03b1),(b :\u03b2)) \u2208 {((x :\u03b1),y) | (P :\u03b2 -> bool) y} \u21d4 P b \u2227 a = x", "\u2200(x :\u03b1 + \u03b2). \u00acISL x \u21d4 ISR x", "\u2200(n :num). LENGTH (FLAT (REPLICATE n (ls :\u03b1 list))) = n * LENGTH ls", "LIST_BIND (MAP (f :\u03b3 -> \u03b2) (l :\u03b3 list)) (g :\u03b2 -> \u03b1 list) = LIST_BIND l (g \u2218 f)", "\u2200(f :\u03b1 -> \u03b2). (\u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d2 x = y) \u21d2 \u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (IMAGE f s)", "\u2200(n :num) (f :num -> \u03b1). NULL (GENLIST f n) \u21d4 n = (0 :num)", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 RC R (x :\u03b1) (y :\u03b1) \u21d2 RC Q x y", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). P \u2286 Q \u21d2 \u2200(x :\u03b1). x \u2208 P \u21d2 x \u2208 Q", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT x INSERT s = x INSERT s", "\u2200(l :\u03b1 list). REVERSE (REVERSE l) = l", "ind_type$ISO (\u03bb(x :\u03b1). x) (\u03bb(x :\u03b1). x)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 s \u2286 t \u2227 t \u2286 s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). P x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 R y z \u21d2 P x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 P x y", "EVERY (P :\u03b1 -> bool) (FLAT (ls :\u03b1 list list)) \u21d4 EVERY (EVERY P) ls", "(\u2200(l :\u03b1 list). LASTN (0 :num) l = ([] :\u03b1 list)) \u2227 \u2200(n :num) (x :\u03b2) (l :\u03b2 list). LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)", "((\u2200(n :num). \u00ac(P :num -> bool) n) \u21d2 (Q :num option -> bool) (NONE :num option)) \u2227 (\u2200(n :num). P n \u2227 (\u2200(m :num). m < n \u21d2 \u00acP m) \u21d2 Q (SOME n)) \u21d2 Q ($OLEAST P)", "(\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l) \u2227 \u2200(l :\u03b2 list). ([] :\u03b2 list) ++ l = l", "\u2200(c :bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). c) l \u21d4 l = ([] :\u03b1 list) \u2228 c", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2260 t \u21d4 \u2203(x :\u03b1). x \u2208 t \u21d4 x \u2209 s", "PMATCH (v :\u03b2) (rows :(\u03b2 -> \u03b1 option) list) = PMATCH v (SNOC (PMATCH_ROW (\u03bb(_0 :\u03b2). _0) (\u03bb(_0 :\u03b2). T) (\u03bb(_0 :\u03b2). (ARB :\u03b1))) rows)", "\u2200(x :\u03b1 # \u03b2) (l :(\u03b1 # \u03b2) list). UNZIP (SNOC x l) = (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))", "\u2200(X :\u03b1). (P :bool) \u21d4 Case X \u21d2 P", "(\u2200(l :\u03b1 list). (P :\u03b1 list -> bool) l) \u21d4 P ([] :\u03b1 list) \u2227 \u2200(h :\u03b1) (t :\u03b1 list). P (h::t)", "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). BIJ f (\u2205 :\u03b1 -> bool) s \u21d4 s = (\u2205 :\u03b2 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). BIJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2200(y :\u03b1). y \u2208 IMAGE f s \u21d2 P y) \u21d4 \u2200(x :\u03b2). x \u2208 s \u21d2 P (f x)", "\u2200(s :\u03b1 -> bool). INJ (\u03bb(x :\u03b1). x) s s", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 INJ f (s DELETE e) (t DELETE f e)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). \u00acP x) l \u21d2 SPLITP P l = (l,([] :\u03b1 list))", "\u2200(x :\u03b1 -> bool) (y :bool). x \u2286 (K y :\u03b1 -> bool) \u21d4 x \u2286 (\u2205 :\u03b1 -> bool) \u2228 y", "\u2200(a1 :\u03b1) (a2 :\u03b1). ind_type$INJA a1 = ind_type$INJA a2 \u21d4 a1 = a2", "\u2200(R :\u03b1 -> \u03b1 -> bool). (SC R)\u1d40 = SC R \u2227 SC R\u1d40 = SC R", "\u2200(s :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION (s INSERT P) = s \u222a BIGUNION P", "\u2200(t :bool). T \u21d2 t \u21d4 t", "\u2200(B :\u03b1 -> bool) (C :\u03b1 -> \u03b1) (R :\u03b1 -> \u03b1 -> bool). WF R \u2227 (\u2200(s :\u03b1). B s \u21d2 R (C s) s) \u21d2 \u2200(P :\u03b1 -> bool). (\u2200(s :\u03b1). (B s \u21d2 P (C s)) \u21d2 P s) \u21d2 \u2200(v :\u03b1). P v", "WF (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool)", "ZIP (([] :\u03b3 list),([] :\u03b4 list)) = ([] :(\u03b3 # \u03b4) list) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b2) (l2 :\u03b2 list). ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)", "\u2200(x :\u03b1) (L :\u03b1 list list). MEM x (FLAT L) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l", "GSPEC (f :\u03b2 -> \u03b1 # bool) = IMAGE ((FST :\u03b1 # bool -> \u03b1) \u2218 f) ((SND :\u03b1 # bool -> bool) \u2218 f)", "\u2200(adjacent' :\u03b1 list -> \u03b1 -> \u03b1 -> bool). (\u2200(a :\u03b1) (b :\u03b1) (t :\u03b1 list). adjacent' (a::b::t) a b) \u2227 (\u2200(a :\u03b1) (b :\u03b1) (h :\u03b1) (t :\u03b1 list). adjacent' t a b \u21d2 adjacent' (h::t) a b) \u21d2 \u2200(a0 :\u03b1 list) (a1 :\u03b1) (a2 :\u03b1). adjacent a0 a1 a2 \u21d2 adjacent' a0 a1 a2", "\u2200(m :num) (n :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 BUTLASTN n (BUTLASTN m l) = BUTLASTN (n + m) l", "trichotomous (RC (R :\u03b1 -> \u03b1 -> bool)) \u21d4 trichotomous R", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (REVERSE l) = REVERSE (DROP n l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t = (\u2205 :\u03b1 -> bool) \u21d4 s \u2286 t", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 t \u2229 s = s", "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2). MAP (f \u2218 g) = MAP f \u2218 MAP g", "(\u2200(x :unit). (P :unit -> bool) x) \u21d4 P ()", "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = b \u21d4 a = f b", "OPTION_CHOICE (m1 :\u03b1 option) (m2 :\u03b1 option) = (NONE :\u03b1 option) \u21d4 m1 = (NONE :\u03b1 option) \u2227 m2 = (NONE :\u03b1 option)", "\u2200(l :\u03b1 list) (n :num). LENGTH l = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 \u2203(u :\u03b1). R\ua673 x u \u2227 R u y", "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t \u2286 s) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2229 s \u2286 s", "reflexive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(xs :\u03b1 list) (n :num) (y :\u03b1). oEL n xs = SOME y \u21d4 n < LENGTH xs \u2227 y = EL n xs", "\u2200(s :\u03b2 -> bool). FUNSET (\u2205 :\u03b1 -> bool) s = \ud835\udd4c(:\u03b1 -> \u03b2)", "\u2200(l1 :\u03b1 list list) (l2 :\u03b1 list list). FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2", "FLAT ([] :\u03b1 list list) = ([] :\u03b1 list) \u2227 FLAT (([] :\u03b2 list)::(t :\u03b2 list list)) = FLAT t \u2227 FLAT (((h :\u03b3)::(t1 :\u03b3 list))::(t2 :\u03b3 list list)) = h::FLAT (t1::t2)", "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). FILTER P (SNOC x l) = if P x then SNOC x (FILTER P l) else FILTER P l", "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) \u2260 {x}", "(\u2203(l :\u03b1 list). (P :\u03b1 list -> bool) l) \u21d4 P ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). P (h::t)", "ind_type$ISO (f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b1) \u21d2 (\u2200(P :\u03b1 -> bool). (\u2200(x :\u03b1). P x) \u21d4 \u2200(x :\u03b2). P (g x)) \u2227 (\u2200(P :\u03b1 -> bool). (\u2203(x :\u03b1). P x) \u21d4 \u2203(x :\u03b2). P (g x)) \u2227 \u2200(a :\u03b1) (b :\u03b2). a = g b \u21d4 f a = b", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (b :\u03b2). ITSET f (\u2205 :\u03b1 -> bool) b = b", "(\u2200(x :\u03b1) (xs :\u03b1 list). FRONT (x::xs) = ([] :\u03b1 list) \u21d4 xs = ([] :\u03b1 list)) \u2227 (\u2200(x :\u03b1) (xs :\u03b1 list). ([] :\u03b1 list) = FRONT (x::xs) \u21d4 xs = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (xs :\u03b1 list). NULL (FRONT (x::xs)) \u21d4 NULL xs", "(0 :num) < SUC (0 :num)", "\u2200(e :\u03b1) (l :\u03b1 list) (h :\u03b1). MEM e l \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool) (l :\u03b2 list). FOLDL f e (FILTER P l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e l", "\u2200(x :\u03b1 list). ([] :\u03b1 list) \u227c x \u2227 (x \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list))", "\u2200(x :\u03b1). FINITE {x}", "\u2200(f :(\u03b1 -> bool) -> bool) (g :(\u03b1 -> bool) -> bool). f \u2286 g \u21d2 BIGUNION f \u2286 BIGUNION g", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = REVERSE l2 \u21d4 l1 = l2", "\u2200(a1 :\u03b1 list) (a0 :\u03b1). ([] :\u03b1 list) \u2260 a0::a1", "DROP (0 :num) (l :\u03b1 list) = l", "\u2200(l :\u03b1 list) (n1 :num) (n2 :num). ALL_DISTINCT l \u2227 n1 < LENGTH l \u2227 n2 < LENGTH l \u21d2 (EL n1 l = EL n2 l \u21d4 n1 = n2)", "\u2200(ls :\u03b1 list list). set (FLAT ls) = BIGUNION (set (MAP (set :\u03b1 list -> \u03b1 -> bool) ls))", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). MEM x (SET_TO_LIST s) \u21d4 x \u2208 s", "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4) (z :\u03b1 + \u03b2). SUM_MAP f g z = (sum_CASE z ((INL :\u03b3 -> \u03b3 + \u03b4) \u2218 f) ((INR :\u03b4 -> \u03b3 + \u03b4) \u2218 g) :\u03b3 + \u03b4)", "(\u2205 :\u03b1 -> bool) \u2260 \ud835\udd4c(:\u03b1)", "\u2200(ls :\u03b1 list) (n :num). ALL_DISTINCT ls \u21d2 ALL_DISTINCT (DROP n ls)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u00ac\u2203(x :\u03b1). x \u2208 s \u2227 x \u2208 t", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2227 Q x} = {x | P x} \u2229 {x | Q x}", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l \u2260 ([] :\u03b1 list) \u21d4 \u2203(x :\u03b1). MEM x l \u2227 P x", "\u2200(n :num) (l :\u03b1 list). TAKE n l ++ DROP n l = l", "\u2200(x :\u03b1) (s :\u03b1 -> bool). COMPL s x \u21d4 x \u2209 s", "\u2200(l :\u03b1 list). LENGTH (REVERSE l) = LENGTH l", "MAP (f :num -> \u03b1) (COUNT_LIST (n :num)) = GENLIST f n", "{(x,y) | (P :\u03b1 -> \u03b2 -> bool) x y} = UNCURRY P", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (x' :\u03b1). (x \u2208 s \u21d4 x' \u2208 s) \u21d4 (x \u2208 s DELETE x' \u21d4 x' \u2208 s DELETE x)", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (s :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' s", "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2227 p \u21d4 p \u2227 stmarker m) \u2227 (p \u2227 q \u2227 stmarker m \u21d4 (p \u2227 q) \u2227 stmarker m) \u2227 ((p \u2227 stmarker m) \u2227 q \u21d4 (p \u2227 q) \u2227 stmarker m)", "(LEAST(n :num). n = (x :num)) = x \u2227 (LEAST(n :num). x = n) = x", "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (l :\u03b2 list). FOLDL f e (REVERSE l) = FOLDR (\u03bb(x :\u03b2) (y :\u03b1). f y x) e l", "(Case (X :\u03b1) \u2227 (Y :bool) \u21d4 Y) \u2227 (Y \u2227 Case X \u21d4 Y) \u2227 (Case X \u21d2 Y \u21d4 Y)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2286 u \u21d4 s \u2286 u \u2227 t \u2286 u", "\u2200(pl :(\u03b1 # \u03b2) list). LENGTH (FST (UNZIP pl)) = LENGTH pl \u2227 LENGTH (SND (UNZIP pl)) = LENGTH pl", "\u2200(p :\u03b1 -> bool). p (UNIV_POINT p) \u21d4 \u2200(x :\u03b1). p x", "DATATYPE ((list :\u03b1 list -> (\u03b1 -> \u03b1 list -> \u03b1 list) -> bool) ([] :\u03b1 list) (CONS :\u03b1 -> \u03b1 list -> \u03b1 list))", "LIST_BIND (LIST_BIND (l :\u03b3 list) (g :\u03b3 -> \u03b2 list)) (f :\u03b2 -> \u03b1 list) = LIST_BIND l (flip (LIST_BIND :\u03b2 list -> (\u03b2 -> \u03b1 list) -> \u03b1 list) f \u2218 g)", "\u2200(l :bool list). AND_EL l \u21d4 FOLDR $/\\ T l", "(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)", "\u2200(m :num) (n :num). m \u2208 count n \u21d4 m < n", "\u2200(l :\u03b1 list) (i :num). MAP (f :\u03b1 -> \u03b2) (DROP i l) = DROP i (MAP f l)", "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (s3 :\u03b1 -> bool). s1 \u2286 s2 DIFF s3 \u21d4 s1 \u2286 s2 \u2227 DISJOINT s1 s3", "\u2200(m :num) (n :num). SUC m = SUC n \u21d4 m = n", "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u207a", "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 DROP n (DROP m l) = DROP (n + m) l", "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u21d4 DISJOINT s s", "\u2200(x :\u03b1) (y :\u03b2). {x} \u00d7 {y} = {(x,y)}", "(\u2200(x :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x x) \u21d2 \u2200(x :\u03b1 option). OPTREL R x x", "(0 :num) \u2297 (0 :num) = (0 :num)", "\u2200(v :unit). v = ()", "\u2200(ss :\u03b1 + \u03b2). (\u2203(x :\u03b1). ss = (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). ss = (INR y :\u03b1 + \u03b2)", "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). P x) \u21d2 WF R", "\u2200(x :\u03b1). {x} DELETE x = (\u2205 :\u03b1 -> bool)", "\u2200(s :\u03b1 -> bool). INFINITE s \u21d4 \u2200(t :\u03b1 -> bool). FINITE t \u21d2 t \u2286 s \u21d2 t \u2282 s", "\u2200(R :\u03b1 -> \u03b1 -> bool). diamond R \u21d2 diamond (RC R)", "OPTION_MCOMP (g :\u03b3 -> \u03b4 option) (SOME :\u03b3 -> \u03b3 option) = g \u2227 OPTION_MCOMP (SOME :\u03b2 -> \u03b2 option) (f :\u03b1 -> \u03b2 option) = f", "\u2200(x :\u03b1) (y :\u03b2). SND (x,y) = y", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). TAKE n (SNOC x l) = TAKE n l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (s0 :\u03b1 -> bool) (t0 :\u03b2 -> bool). INJ f s t \u2227 s0 \u2286 s \u2227 t \u2286 t0 \u21d2 INJ f s0 t0", "\u2200(n :num) (x :\u03b1). REPLICATE n x = GENLIST (K x :num -> \u03b1) n", "($= :\u03b2 -> \u03b2 -> bool) \u2218\u1d63 (R :\u03b1 -> \u03b2 -> bool) = R", "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 transitive (RC R)", "\u2200(t :bool). t \u21d2 t \u21d4 T", "\u2200(v :\u03b1) (v' :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (rows' :(\u03b1 -> \u03b2 option) list) (r :\u03b1 -> \u03b2 option) (r' :\u03b1 -> \u03b2 option). v = v' \u2227 r v' = r' v' \u2227 PMATCH v' rows = PMATCH v' rows' \u21d2 PMATCH v (r::rows) = PMATCH v' (r'::rows')", "((A :\u03b1 -> bool) \u2229 (B :\u03b1 -> bool) = A \u21d4 A \u2286 B) \u2227 (A \u2229 B = B \u21d4 B \u2286 A)", "LENGTH (STRONGEST_REDUNDANT_ROWS_INFO (v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list)) = LENGTH rows", "(R1 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R2 :\u03b1 -> \u03b2 -> bool) \u2227 (S1 :\u03b3 -> \u03b1 -> bool) \u2286\u1d63 (S2 :\u03b3 -> \u03b1 -> bool) \u21d2 R1 \u2218\u1d63 S1 \u2286\u1d63 R2 \u2218\u1d63 S2", "\u2200(opt1 :\u03b1 option) (opt2 :\u03b1 option) (f1 :\u03b1 -> \u03b2) (f2 :\u03b1 -> \u03b2). opt1 = opt2 \u2227 (\u2200(x :\u03b1). opt2 = SOME x \u21d2 f1 x = f2 x) \u21d2 OPTION_MAP f1 opt1 = OPTION_MAP f2 opt2", "\u2200(m :num) (n :num). m < n \u21d2 m \u2260 n", "\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool)\ua673 x y \u21d2 R^= x y", "STRORD (R :\u03b1 -> \u03b1 -> bool) = R \u2229\u1d63 RCOMPL ($= :\u03b1 -> \u03b1 -> bool)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE x = s DELETE x", "\u2200(R :\u03b1 -> \u03b1 -> bool). WeakOrder R \u21d2 RC (STRORD R) = R", "CARD (\u2205 :\u03b1 -> bool) = (0 :num)", "\u2200(m :num) (n :num). m = n \u21d2 \u00ac(m < n)", "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool). irreflexive R2 \u2227 R1 \u2286\u1d63 R2 \u21d2 irreflexive R1", "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u21d2 (s DELETE x = (\u2205 :\u03b1 -> bool) \u21d4 s = {x})", "\u2200(n :num) (m :num) (l :\u03b1 list). DROP n (DROP m l) = DROP (n + m) l", "\u2200(opt :\u03b1 option) (opt' :\u03b1 option) (P :\u03b1 -> bool) (P' :\u03b1 -> bool). opt = opt' \u2227 (\u2200(x :\u03b1). opt' = SOME x \u21d2 (P x \u21d4 P' x)) \u21d2 (OPTION_ALL P opt \u21d4 OPTION_ALL P' opt')", "\ud835\udd4c(:bool) = {T; F}", "((A :\u03b1 -> bool) \u222a (B :\u03b1 -> bool)) \u2229 A = A \u2227 (B \u222a A) \u2229 A = A \u2227 A \u2229 (A \u222a B) = A \u2227 A \u2229 (B \u222a A) = A", "\u2200(f' :\u03b1 -> \u03b2 -> \u03b3) (f :\u03b1 -> \u03b2 -> \u03b3) (M' :\u03b1 # \u03b2) (M :\u03b1 # \u03b2). M = M' \u2227 (\u2200(x :\u03b1) (y :\u03b2). M' = (x,y) \u21d2 f x y = f' x y) \u21d2 UNCURRY f M = UNCURRY f' M'", "\u2200(v :\u03b1) (rows1a :(\u03b1 -> \u03b2 option) list) (rows1b :(\u03b1 -> \u03b2 option) list) (rows2a :(\u03b1 -> \u03b2 option) list) (rows2b :(\u03b1 -> \u03b2 option) list). PMATCH_EQUIV_ROWS v rows1a rows1b \u21d2 PMATCH_EQUIV_ROWS v rows2a rows2b \u21d2 PMATCH_EQUIV_ROWS v (rows1a ++ rows2a) (rows1b ++ rows2b)", "\u2200(t :bool). t \u2228 T \u21d4 T", "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). (x INSERT s) DELETE y = if x = y then s DELETE y else x INSERT s DELETE y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (b :\u03b1). Q b \u2227 (\u2200(x :\u03b1) (y :\u03b1). R x y \u2227 Q y \u21d2 Q x) \u21d2 \u2200(x :\u03b1). R\ua673 x b \u21d2 Q x", "\u2200(a :\u03b1 list) (b :\u03b2 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH b \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d)", "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). (\u2200(n :num). PRIM_REC_FUN x f (0 :num) n = x) \u2227 \u2200(m :num) (n :num). PRIM_REC_FUN x f (SUC m) n = f (PRIM_REC_FUN x f m (PRE n)) n", "(\u2200(s :\u03b1). (P :\u03b1 -> bool) s \u21d4 (Q :\u03b1 -> bool) s) \u21d2 ((\u2200(s :\u03b1). P s) \u21d4 \u2200(s :\u03b1). Q s)", "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF (y \u222a z) = x DIFF y DIFF z", "(OLEAST(n :num). n = (x :num)) = SOME x \u2227 (OLEAST(n :num). x = n) = SOME x \u2227 (OLEAST(n :num). F) = (NONE :num option) \u2227 (OLEAST(n :num). T) = SOME (0 :num)", "\u2200(n :num). \u00ac(n < n)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). LENGTH (FILTER P l) \u2264 LENGTH l", "\u2200(P :num -> bool) (n :num). EVERY P (COUNT_LIST n) \u21d4 \u2200(m :num). m < n \u21d2 P m", "\u2200(m :num) (n :num). count n m \u21d4 m < n", "(\u2200(P :\u03b1 -> bool). PREFIX P ([] :\u03b1 list) = ([] :\u03b1 list)) \u2227 \u2200(P :\u03b2 -> bool) (x :\u03b2) (l :\u03b2 list). PREFIX P (x::l) = if P x then x::PREFIX P l else ([] :\u03b2 list)", "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). LAST (x::y::z) = LAST (y::z)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n l = EL (PRE (LENGTH l \u2212 n)) l", "\u2200(x :\u03b1). DISJOINT {x} (\u2205 :\u03b1 -> bool)", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (BUTLASTN n l) = LENGTH l \u2212 n", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 PROD_ALL P Q (p :\u03b1 # \u03b2) \u21d2 PROD_ALL P' Q' p", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). IS_SUFFIX l1 l2 \u2227 IS_SUFFIX l2 l3 \u21d2 IS_SUFFIX l1 l3", "DATATYPE ((pair :(\u03b1 -> \u03b2 -> \u03b1 # \u03b2) -> \u03b3) ($, :\u03b1 -> \u03b2 -> \u03b1 # \u03b2))", "INJ (LINV_OPT (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool)) (IMAGE f s) (IMAGE (SOME :\u03b2 -> \u03b2 option) s)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2228 countable t \u21d2 countable (s \u2229 t)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (u :\u03b1 -> bool) (t :\u03b2 -> bool). s \u2286 u \u2227 IMAGE f u \u2286 t \u21d2 IMAGE f s \u2286 t", "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\ua673", "\u2200(X :\u03b1 -> bool) (Y :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). Y \u2208 P \u2227 DISJOINT Y X \u21d2 DISJOINT X (BIGINTER P) \u2227 DISJOINT (BIGINTER P) X", "(0 :num) = LENGTH (l :\u03b1 list) \u21d4 l = ([] :\u03b1 list)", "(option_CASE (x :\u03b1 option) (e :\u03b2) (f :\u03b1 -> \u03b2) :\u03b2) = if IS_SOME x then f (THE x) else e", "\u2200(s :\u03b1 -> bool). DISJOINT s s \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool) (a :\u03b1) (b :\u03b1). R\ua673 a b \u21d4 \u2200(Q :\u03b1 -> bool). Q a \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R y z \u21d2 Q z) \u21d2 Q b", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). RC R x y \u21d2 R\ua673 x y", "\u2200(m :num) (n :num). m < n \u21d2 m < SUC n", "BIGINTER (\u2205 :(\u03b1 -> bool) -> bool) = \ud835\udd4c(:\u03b1)", "(\u00ac(A :bool) \u21d2 F) \u21d2 (A \u21d2 F) \u21d2 F", "\u2200(f :\u03b1 -> \u03b2 # \u03b3) (a :\u03b2 -> bool) (b :\u03b3 -> bool). PREIMAGE f (a \u00d7 b) = PREIMAGE ((FST :\u03b2 # \u03b3 -> \u03b2) \u2218 f) a \u2229 PREIMAGE ((SND :\u03b2 # \u03b3 -> \u03b3) \u2218 f) b", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 option). OPTION_MAP f x = (NONE :\u03b2 option) \u21d4 x = (NONE :\u03b1 option)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). x \u2208 t \u21d2 g x \u2208 s) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 g (f x) = x) \u2227 \u2200(x :\u03b2). x \u2208 t \u21d2 f (g x) = x", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (n :num) (x :\u03b1). n < LENGTH l1 \u21d2 LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2", "(some(x :\u03b1). x = (y :\u03b1)) = SOME y \u2227 (some(x :\u03b1). y = x) = SOME y", "(\u2200(x :\u03b1). FRONT [x] = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). FRONT (x::y::z) = x::FRONT (y::z)", "ZRECSPACE (ind_type$ZBOT :num -> \u03b1 -> bool) \u2227 \u2200(c :num) (i :\u03b1) (r :num -> num -> \u03b1 -> bool). (\u2200(n :num). ZRECSPACE (r n)) \u21d2 ZRECSPACE (ind_type$ZCONSTR c i r)", "\u2200(m :num) (n :num). MEM m (COUNT_LIST n) \u21d4 m < n", "\u2200(P :\u03b1 -> \u03b2 -> bool). (\u2200(x :\u03b1) (y :\u03b2). P x y) \u21d4 \u2200((x :\u03b1),(y :\u03b2)). P x y", "\u2200(P :\u03b1 -> bool) (x :\u03b1). x \u2208 P \u21d4 P x", "BIGINTER (B :(\u03b1 -> bool) -> bool) (x :\u03b1) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P", "LIST_REL (P :\u03b1 -> \u03b2 -> bool) (GENLIST (f :num -> \u03b1) (l :num)) (GENLIST (g :num -> \u03b2) l) \u21d4 \u2200(i :num). i < l \u21d2 P (f i) (g i)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). SURJ f s t \u21d4 IMAGE f s = t", "\u2200(f :\u03b1 -> \u03b2) (g :num -> \u03b1) (n :num). MAP f (GENLIST g n) = GENLIST (f \u2218 g) n", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list) (a :\u03b1). MEM a l \u21d2 MEM (f a) (MAP f l)", "BIGUNION (IMAGE (f :\u03b2 -> \u03b1 -> bool) (set (ls :\u03b2 list))) \u2286 (s :\u03b1 -> bool) \u21d4 \u2200(x :\u03b2). MEM x ls \u21d2 f x \u2286 s", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2286 s \u21d2 s DIFF (s DIFF t) = t", "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). e \u2208 POW set \u21d4 e \u2286 set", "FINITE \ud835\udd4c(:\u03b1 # \u03b2) \u21d4 FINITE \ud835\udd4c(:\u03b1) \u2227 FINITE \ud835\udd4c(:\u03b2)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). FINITE s \u2227 BIJ f s t \u21d2 CARD s = CARD t", "{x | T} = \ud835\udd4c(:\u03b1)", "COMPL (\u2205 :\u03b1 -> bool) = \ud835\udd4c(:\u03b1)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 t", "\u2200(s :\u03b1 -> bool). (\u2203(f :num -> \u03b1). BIJ f \ud835\udd4c(:num) s) \u21d2 countable s", "\u2200(a0 :\u03b1) (a1 :\u03b1 list) (a0' :\u03b1) (a1' :\u03b1 list). a0::a1 = a0'::a1' \u21d4 a0 = a0' \u2227 a1 = a1'", "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGINTER (s1 \u222a s2) = BIGINTER s1 \u2229 BIGINTER s2", "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b3 -> bool) (t :\u03b1 -> bool). s \u00d7 BIGUNION (IMAGE f t) = BIGUNION (IMAGE (\u03bb(n :\u03b1). s \u00d7 f n) t)", "PMATCH_EQUIV_ROWS (v :\u03b1) (rows1 :(\u03b1 -> \u03b2 option) list) (rows2 :(\u03b1 -> \u03b2 option) list) \u21d2 PMATCH v rows1 = PMATCH v rows2", "\u2200(l :\u03b1 list) (x :\u03b1). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 countable s", "\u2200(l :\u03b1 list). FINITE (set l)", "\u2200(f :\u03b1 -> num) (x :\u03b1) (ls :\u03b1 list). MEM x ls \u21d2 f x \u2264 SUM (MAP f ls)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 x INSERT s", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 BUTLASTN n (FRONT l) = FRONT (BUTLASTN n l)", "\u2200(v :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool) (p' :\u03b3 -> \u03b1) (g' :\u03b3 -> bool) (RES :bool). PMATCH_ROW_COND_EX v p g \u21d2 (\u2200(x :\u03b2). g x \u21d2 ((\u2203(x' :\u03b3). p' x' = p x \u2227 g' x') \u21d4 RES)) \u21d2 (PMATCH_ROW_COND_EX v p' g' \u21d4 RES)", "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) DELETE x = (\u2205 :\u03b1 -> bool)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2229 s = s DIFF t", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n \u2212 LENGTH l1) l2", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u2229 u) = s \u2229 t \u2229 u", "\u2200(P :\u03b1 list -> bool). (\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d2 P l) \u21d4 P ([] :\u03b1 list)", "ASSOC ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list)", "PMATCH_ROW_REDUNDANT (v :\u03b1) ([] :(\u03b1 -> \u03b2 option) list) (i :num) \u21d4 F", "\u2200(ZRECSPACE' :(num -> \u03b1 -> bool) -> bool). ZRECSPACE' (ind_type$ZBOT :num -> \u03b1 -> bool) \u2227 (\u2200(c :num) (i :\u03b1) (r :num -> num -> \u03b1 -> bool). (\u2200(n :num). ZRECSPACE' (r n)) \u21d2 ZRECSPACE' (ind_type$ZCONSTR c i r)) \u21d2 \u2200(a0 :num -> \u03b1 -> bool). ZRECSPACE a0 \u21d2 ZRECSPACE' a0", "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list). LENGTH l1 = LENGTH l2 \u21d2 \u2200(x1 :\u03b1) (x2 :\u03b2). ZIP (SNOC x1 l1,SNOC x2 l2) = SNOC (x1,x2) (ZIP (l1,l2))", "\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)", "\u2200(e :\u03b1). \u2203(fn :unit -> \u03b1). fn () = e", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 FRONT l ++ [LAST l] = l", "\u2200(l :\u03b1 list) (n :num). n < LENGTH l \u21d2 LAST (DROP n l) = LAST l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). BUTLASTN n (x::l) = x::BUTLASTN n l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). DISJOINT s t \u21d2 DISJOINT (PREIMAGE f s) (PREIMAGE f t)", "(\u2203(ls :\u03b1 list). (P :\u03b1 list -> bool) ls) \u21d4 \u2203(n :num) (f :num -> \u03b1). P (GENLIST f n)", "nub ([] :\u03b1 list) = ([] :\u03b1 list)", "WF (R :\u03b1 -> \u03b1 -> bool)\u207a \u21d4 WF R", "\u2200(n :num). countable (count n)", "{x | (y :\u03b1) = x} = {y}", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = l ++ [x]", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2209 t", "GENLIST (f :num -> \u03b1) (0 :num) = ([] :\u03b1 list) \u2227 GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :\u03b1 list)", "\u2200(s :\u03b1) (x :\u03b1 -> bool). x \u2282 {s} \u21d4 x = (\u2205 :\u03b1 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R\u1d40 \u21d4 symmetric R", "\u2200(t1 :\u03b1) (t2 :\u03b1). (if F then t1 else t2) = t2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set (l1 ++ l2) = set l1 \u222a set l2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 \u227c l1 \u21d4 \u2203(l :\u03b1 list). l1 = l2 ++ l", "\u2200(R :\u03b1 -> \u03b1 -> bool). irreflexive R\u1d40 \u21d4 irreflexive R", "\u2200(s :\u03b1 -> bool). CHOICE s \u2209 REST s", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2", "\u2200(L :\u03b1 list) (n :num). LEN L n = LENGTH L + n", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x \u21d2 y' \u21d2 y) \u2227 (\u00acy' \u21d2 x \u21d2 x') \u21d2 (x' \u21d2 y') \u21d2 x \u21d2 y", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u2200(e :\u03b1). MEM e l \u21d2 P e", "\u2200(n1 :num) (n2 :num). count n1 = count n2 \u21d4 n1 = n2", "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l", "\u2200(e :\u03b1) (l :\u03b1 list). LIST_ELEM_COUNT e l > (0 :num) \u21d4 MEM e l", "\u2200(t :bool). t \u2228 t \u21d4 t", "(\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y) \u21d2 (DISJOINT (IMAGE f (s1 :\u03b1 -> bool)) (IMAGE f (s2 :\u03b1 -> bool)) \u21d4 DISJOINT s1 s2)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (y \u21d2 x' \u21d2 x) \u2227 (x' \u21d2 y' \u21d2 y) \u21d2 x' \u2227 y' \u21d2 x \u2227 y", "\u2200(n :num). DROP n ([] :\u03b1 list) = ([] :\u03b1 list)", "\u2200(s :\u03b1 -> bool). s \u2282 \ud835\udd4c(:\u03b1) \u21d4 \u2203(x :\u03b1). x \u2209 s", "(Q :\u03b1 option -> bool) ($some (P :\u03b1 -> bool)) \u21d2 (\u2203(x :\u03b1). P x \u2227 Q (SOME x)) \u2228 (\u2200(x :\u03b1). \u00acP x) \u2227 Q (NONE :\u03b1 option)", "transitive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). INJ f s t \u2227 INJ g t u \u21d2 INJ (g \u2218 f) s u", "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). IMAGE f s y \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s", "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). SURJ f s t \u2227 SURJ g t u \u21d2 SURJ (g \u2218 f) s u", "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = f b \u21d4 a = b", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3", "$OLEAST (P :num -> bool) = (NONE :num option) \u21d4 \u2200(n :num). \u00acP n", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n \u2212 LENGTH l1) l2", "\u2200(ls :\u03b1 list) (f :\u03b2 -> \u03b1). EVERY (\u03bb(x :\u03b1). \u2203(y :\u03b2). x = f y) ls \u21d2 \u2203(l :\u03b2 list). ls = MAP f l", "\u2200(opt :\u03b1 option). (\u2203(x :\u03b1). opt = SOME x) \u2228 opt = (NONE :\u03b1 option)", "SURJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2203(g :\u03b2 -> \u03b1). INJ g t s \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 f (g y) = y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R y z \u21d2 R\u207a x z", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u2227 INFINITE s \u21d2 INFINITE t", "\u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). SNOC x1 l1 = SNOC x2 l2 \u21d2 LENGTH l1 = LENGTH l2", "\u2200(x :\u03b1) (l :\u03b1 list). TL (SNOC x l) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)", "\u2200(P :\u03b1 list -> bool) (n :num). (\u2200(l :\u03b1 list). LENGTH l = SUC n \u21d2 P l) \u21d4 \u2200(l :\u03b1 list). LENGTH l = n \u21d2 (\u03bb(l :\u03b1 list). \u2200(x :\u03b1). P (x::l)) l", "(x :\u03b1) \u2208 RDOM (RRESTRICT (R :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool)) \u21d4 x \u2208 RDOM R \u2227 x \u2208 s", "\u2200(x :\u03b1) (l :\u03b1 list). FRONT (SNOC x l) = l", "\u2200(l :\u03b1 list) (x :\u03b1). MEM x (REVERSE l) \u21d4 MEM x l", "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l", "\u2200(l :\u03b1 list) (m :num) (x :\u03b1). MEM x (DROP m l) \u21d2 MEM x l", "\u2200(x :\u03b1 + \u03b2). ISR x \u21d2 (INR (OUTR x) :\u03b1 + \u03b2) = x", "(([(f :\u03b2 -> \u03b1)] <*> (l :\u03b2 list)) :\u03b1 list) = MAP f l", "\u2200(n :num) (x :\u03b1). SNOC x (REPLICATE n x) = REPLICATE (SUC n) x", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). x INSERT s = {y} \u21d4 x = y \u2227 s \u2286 {y}", "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2", "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive (RC R)", "(R1 :\u03b3 -> \u03b2 -> bool) \u2218\u1d63 (R2 :\u03b4 -> \u03b3 -> bool) \u2218\u1d63 (R3 :\u03b1 -> \u03b4 -> bool) = (R1 \u2218\u1d63 R2) \u2218\u1d63 R3", "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). ELL n (SNOC x l) = ELL (PRE n) l", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). ALL_DISTINCT (l1 ++ l2) \u21d4 ALL_DISTINCT l1 \u2227 ALL_DISTINCT l2 \u2227 \u2200(e :\u03b1). MEM e l1 \u21d2 \u00acMEM e l2", "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 BUTLASTN (1 :num) l = FRONT l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). BIGUNION {s; t} = s \u222a t", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). \u00acNULL l2 \u21d2 EL (LENGTH l1) (l1 ++ l2) = HD l2", "reflexive ((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) \u21d4 reflexive R1 \u2228 reflexive R2", "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (IMAGE f s) \u21d2 (countable (IMAGE f s) \u21d4 countable s)", "MAP (f :\u03b2 -> \u03b1) (LIST_BIND (l :\u03b3 list) (g :\u03b3 -> \u03b2 list)) = LIST_BIND l (MAP f \u2218 g)", "FUNSET \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) = \ud835\udd4c(:\u03b1 -> \u03b2)", "\u2200(A :bool) (B :bool) (C :bool). A \u2227 B \u21d2 C \u21d4 A \u21d2 B \u21d2 C", "MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)", "REPLICATE (n :num) (a :\u03b1) ++ REPLICATE (m :num) a = REPLICATE (n + m) a", "\u2200(b :bool). \u00acb \u21d2 (b \u21d4 F)", "\u2200(x :\u03b1) (y :\u03b2) (a :\u03b1) (b :\u03b2). (x,y) = (a,b) \u21d4 x = a \u2227 y = b", "\u2200(f :\u03b1 -> \u03b2) (n :num) (x :\u03b1). MAP f (REPLICATE n x) = REPLICATE n (f x)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l", "PMATCH_ROW_COND_EX (i :\u03b1) (p :\u03b2 -> \u03b1) (g :\u03b2 -> bool) \u21d2 PMATCH_ROW p g (r :\u03b2 -> \u03b3) i = SOME (r (@(x :\u03b2). PMATCH_ROW_COND p g i x))", "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). (R1 \u2229\u1d63 R2)\ua673 x y \u21d2 (R1\ua673 \u2229\u1d63 R2\ua673) x y", "\u2200(P :\u03b1 -> bool) (a :\u03b1) (s :\u03b1 -> bool). (\u2203(x :\u03b1). x \u2208 a INSERT s \u2227 P x) \u21d4 P a \u2228 \u2203(x :\u03b1). x \u2208 s \u2227 P x", "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4) (z :\u03b1 + \u03b2). SUM_MAP f g z = if ISL z then (INL (f (OUTL z)) :\u03b3 + \u03b4) else (INR (g (OUTR z)) :\u03b3 + \u03b4)", "\u2200(l :\u03b1 list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))", "\u2200(f1 :\u03b1 -> \u03b2) (f2 :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f1 l = MAP f2 l \u21d4 \u2200(e :\u03b1). MEM e l \u21d2 f1 e = f2 e", "($= :\u03b1 -> \u03b1 -> bool)\u1d40 = ($= :\u03b1 -> \u03b1 -> bool)", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n (REVERSE l) = ELL (PRE (LENGTH l \u2212 n)) l", "\u2200(x :\u03b1) (s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2260 x INSERT s", "(\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acSHORTLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 SHORTLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (SHORTLEX R (h1::t1) (h2::t2) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))", "(\u2200(v :\u03b1). PMATCH_IS_EXHAUSTIVE v ([] :(\u03b1 -> \u03b2 option) list) \u21d4 F) \u2227 \u2200(v :\u03b3) (r :\u03b3 -> \u03b4 option) (rs :(\u03b3 -> \u03b4 option) list). PMATCH_IS_EXHAUSTIVE v (r::rs) \u21d4 r v \u2260 (NONE :\u03b4 option) \u2228 PMATCH_IS_EXHAUSTIVE v rs", "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2229 s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u2229 \ud835\udd4c(:\u03b1) = s", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 f \u2208 FUNSET s t \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 \u2203!(x :\u03b1). x \u2208 s \u2227 y = f x", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n l = TAKE (LENGTH l \u2212 n) l", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). IS_SUFFIX (REVERSE l1) (REVERSE l2) \u21d4 l2 \u227c l1", "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). x \u2208 s DELETE y \u21d4 x \u2208 s \u2227 x \u2260 y", "\u2200(ls :\u03b1 list) (n :num). n \u2264 LENGTH ls \u21d2 REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls \u2212 n) ls)", "\u2200(f :\u03b1 -> \u03b2). PREIMAGE f (\u2205 :\u03b2 -> bool) = (\u2205 :\u03b1 -> bool)", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f (REVERSE l) = REVERSE (MAP f l)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s \u222a t) x \u21d4 x \u2208 s \u2228 x \u2208 t", "\u2200(n :num). LENGTH (COUNT_LIST n) = n", "(\u2203(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2203(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) l2 l1", "\u2200(s :\u03b1 -> bool) (x :\u03b1). COMPL (x INSERT s) = COMPL s DELETE x", "\u2200(t :bool). t \u21d2 T \u21d4 T", "countable (\u2205 :\u03b1 -> bool)", "\u2200(R :\u03b1 -> \u03b1 -> bool). Order R \u21d4 StrongOrder (STRORD R)", "\u2200(x :bool) (x' :bool) (y :bool) (y' :bool). (x \u21d2 y \u21d2 y') \u2227 (\u00acy' \u21d2 x' \u21d2 x) \u21d2 (x \u21d2 y) \u21d2 x' \u21d2 y'", "(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (TAKE m l)", "IS_SOME (OPTION_BIND (x :\u03b1 option) (g :\u03b1 -> \u03b2 option)) \u21d2 IS_SOME x", "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R\ua673 (x :\u03b1) (y :\u03b1) \u21d2 Q\ua673 x y", "\u2200(x :\u03b1 list). x \u227c x", "count (0 :num) = (\u2205 :num -> bool)", "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EXISTS P (l :\u03b1 list) \u21d2 EXISTS Q l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 s \u2229 t = s", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y", "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). T) xs = xs", "\u2200(s :\u03b1 -> bool). (\u03bb(x :\u03b1). x) PERMUTES s", "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n \u2212 LENGTH l1) l2", "\u2200(s :\u03b1 -> bool). INFINITE s \u21d2 \u2200(t :\u03b1 -> bool). s \u2286 t \u21d2 INFINITE t", "(option_CASE (NONE :\u03b1 option) :\u03b2 -> (\u03b1 -> \u03b2) -> \u03b2) = (\u03bb(v :\u03b2) (f :\u03b1 -> \u03b2). v) \u2227 (option_CASE (SOME (x :\u03b1)) :\u03b2 -> (\u03b1 -> \u03b2) -> \u03b2) = (\u03bb(v :\u03b2) (f :\u03b1 -> \u03b2). f x)", "\u2200(t :bool). t \u21d2 F \u21d4 \u00act", "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool) (l :\u03b1 list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). FUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q", "\ud835\udd4c(:\u03b1 + \u03b2) = IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b1) \u222a IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b2)", "\u2200(x :\u03b1) (s :\u03b1 -> bool). s \u2286 x INSERT s", "\u2200(l :\u03b1 list) (x :\u03b1). l \u2260 x::l \u2227 x::l \u2260 l", "PROD_SET (\u2205 :num -> bool) = (1 :num) \u2227 \u2200(x :num) (s :num -> bool). FINITE s \u21d2 PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). PREIMAGE f s x \u21d4 f x \u2208 s", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n l = LASTN (LENGTH l \u2212 n) l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (TAKE n l) = n", "(0 :num) < (n :num) \u21d2 DROP n ((x :\u03b1)::(xs :\u03b1 list)) = DROP (n \u2212 (1 :num)) xs", "\u2200(l :bool list). AND_EL l \u21d4 FOLDL $/\\ T l", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l = ([] :\u03b1 list) \u21d4 EVERY (\u03bb(x :\u03b1). \u00acP x) l", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (p :bool) (infos :bool list). FST (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos) \u21d4 p \u2227 EVERY (\u03bb(r :\u03b1 -> \u03b2 option). r v = (NONE :\u03b2 option)) rows", "\u2200(s :\u03b1 -> bool). s \u2229 s = s", "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF y DIFF z = x DIFF z DIFF y", "\u2200(c :bool) (x :bool) (x' :bool) (y :bool) (y' :bool). (c \u21d2 x' \u21d2 x) \u2227 (\u00acc \u21d2 y' \u21d2 y) \u21d2 (if c then x' else y') \u21d2 if c then x else y", "\u2200(x :\u03b1). SING {x}", "((a :\u03b1),(b :\u03b1)) \u2208 {(x,x) | (P :\u03b1 -> bool) x} \u21d4 P a \u2227 a = b", "\u2200(M :\u03b1 list) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). M = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)", "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l \u2260 ([] :\u03b1 list)", "\u2200(g :\u03b1 -> \u03b1 -> \u03b1) (f :\u03b2 -> \u03b1 -> \u03b1). FCOMM g f \u21d2 \u2200(e :\u03b1). LEFT_ID g e \u21d2 \u2200(l :\u03b2 list list). FOLDR f e (FLAT l) = FOLDR g e (MAP (FOLDR f e) l)", "\u2200(m :num) (n :num). m < SUC n \u21d2 m \u2260 n \u21d2 m < n", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2282 t \u2227 t \u2282 u \u21d2 s \u2282 u", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). FINITE s \u2227 FINITE t \u21d2 CARD (s \u222a t) = CARD s + CARD t \u2212 CARD (s \u2229 t)", "\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2286 s \u21d4 s = \ud835\udd4c(:\u03b1)", "\u2200(v :\u03b1) (rows :(\u03b1 -> \u03b2 option) list) (p :bool) (infos :bool list). LENGTH (SND (STRONGEST_REDUNDANT_ROWS_INFO_AUX v rows p infos)) = LENGTH rows + LENGTH infos", "LIST_REL (R :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) ((h :\u03b2)::(t :\u03b2 list)) \u21d4 \u2203(h' :\u03b1) (t' :\u03b1 list). xs = h'::t' \u2227 R h' h \u2227 LIST_REL R t' t", "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 R\ua673 x y \u21d2 P y", "((p :bool) \u21d4 if (q :bool) then (r :bool) else (s :bool)) \u21d4 (p \u2228 q \u2228 \u00acs) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (p \u2228 \u00acr \u2228 \u00acs) \u2227 (\u00acq \u2228 r \u2228 \u00acp) \u2227 (q \u2228 s \u2228 \u00acp)", "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u21d4 \u2203(t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t", "PMATCH_ROW_REDUNDANT (v :\u03b1) ((r :\u03b1 -> \u03b2 option)::(rs :(\u03b1 -> \u03b2 option) list)) (0 :num) \u21d4 r v = (NONE :\u03b2 option)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (s DIFF t) \u2227 DISJOINT (s DIFF t) t", "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool) (y :\u03b2). y \u2208 BIGUNION (IMAGE f s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 y \u2208 f x", "(\u2200(e :\u03b1). LIST_ELEM_COUNT e ([] :\u03b1 list) = (0 :num)) \u2227 (\u2200(e :\u03b2) (l1 :\u03b2 list) (l2 :\u03b2 list). LIST_ELEM_COUNT e (l1 ++ l2) = LIST_ELEM_COUNT e l1 + LIST_ELEM_COUNT e l2) \u2227 (\u2200(e :\u03b3) (h :\u03b3) (l :\u03b3 list). h = e \u21d2 LIST_ELEM_COUNT e (h::l) = SUC (LIST_ELEM_COUNT e l)) \u2227 \u2200(e :\u03b4) (h :\u03b4) (l :\u03b4 list). h \u2260 e \u21d2 LIST_ELEM_COUNT e (h::l) = LIST_ELEM_COUNT e l", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s \u2229 t) x \u21d4 x \u2208 s \u2227 x \u2208 t", "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EXISTS P (l1 ++ l2) \u21d4 EXISTS P l1 \u2228 EXISTS P l2", "\u2200(ls :\u03b1 list) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (ls,ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls", "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0", "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R \u21d2 SC R = R", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). SHORTLEX (R :\u03b1 -> \u03b1 -> bool) l1 l2 \u21d2 LENGTH l1 \u2264 LENGTH l2", "\u2200(f :\u03b2 -> \u03b1 -> \u03b2) (e :\u03b2) (x :\u03b1) (l :\u03b1 list). FOLDL f e (SNOC x l) = f (FOLDL f e l) x", "\u2200(P :(\u03b1 -> bool) -> bool). P (\u2205 :\u03b1 -> bool) \u2227 (\u2200(s :\u03b1 -> bool). FINITE s \u2227 P s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)) \u21d2 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 P s", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 FINITE (REST s)", "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(f :num -> \u03b1) (b :num). BIJ f (count b) s", "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EVERY P l1 \u21d2 dropWhile P (l1 ++ l2) = dropWhile P l2", "(OPTION_IGNORE_BIND (m1 :\u03b1 option) (m2 :\u03b2 option) = (NONE :\u03b2 option) \u21d4 m1 = (NONE :\u03b1 option) \u2228 m2 = (NONE :\u03b2 option)) \u2227 (OPTION_IGNORE_BIND m1 m2 = SOME (y :\u03b2) \u21d4 \u2203(x :\u03b1). m1 = SOME x \u2227 m2 = SOME y)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u00acEXISTS (\u03bb(x :\u03b1). \u00acP x) l", "\u2200(s :\u03b1 -> bool). s = \ud835\udd4c(:\u03b1) \u21d2 \u2200(v :\u03b1). v \u2208 s", "\u2200(n :num). SUC (m :num) = n \u21d2 m < n", "((if (P :bool) then SOME (x :\u03b1) else (NONE :\u03b1 option)) = (NONE :\u03b1 option) \u21d4 \u00acP) \u2227 ((if P then (NONE :\u03b1 option) else SOME x) = (NONE :\u03b1 option) \u21d4 P) \u2227 ((if P then SOME x else (NONE :\u03b1 option)) = SOME (y :\u03b1) \u21d4 P \u2227 x = y) \u2227 ((if P then (NONE :\u03b1 option) else SOME x) = SOME y \u21d4 \u00acP \u2227 x = y)", "(some(x :bool). x) = SOME T", "REDUNDANT_ROWS_INFOS_CONJ ([] :bool list) ([] :bool list) = ([] :bool list) \u2227 REDUNDANT_ROWS_INFOS_CONJ ((i1 :bool)::(is1 :bool list)) ((i2 :bool)::(is2 :bool list)) = (i1 \u2227 i2)::REDUNDANT_ROWS_INFOS_CONJ is1 is2", "\u2200(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)", "\u2200(x :\u03b1 recspace) (y :\u03b1 recspace). dest_rec x = dest_rec y \u21d4 x = y", "((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) ((a :\u03b1),(b :\u03b2)) ((c :\u03b1),(d :\u03b2)) \u21d4 R1 a c \u2228 a = c \u2227 R2 b d", "(\u2200(l :\u03b1 list). ([] :\u03b1 list) \u227c l \u21d4 T) \u2227 (\u2200(x :\u03b1) (l :\u03b1 list). x::l \u227c ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). x2::l2 \u227c x1::l1 \u21d4 x1 = x2 \u2227 l2 \u227c l1", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n (REVERSE l) = REVERSE (BUTLASTN n l)", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f l) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). s \u2286 t \u21d2 PREIMAGE f s \u2286 PREIMAGE f t", "PROD_ALL (P :\u03b1 -> bool) (Q :\u03b2 -> bool) ((x :\u03b1),(y :\u03b2)) \u21d4 P x \u2227 Q y", "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\u207a x y \u21d2 R\ua673 x y", "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). BUTLASTN (LENGTH l2) (l1 ++ l2) = l1", "\u2200(l :\u03b1 list). LENGTH l = FOLDR (\u03bb(x :\u03b1) (l' :num). SUC l') (0 :num) l", "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n l = DROP (LENGTH l \u2212 n) l", "\u2200(t :bool). F \u2228 t \u21d4 t", "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). IMAGE f (PREIMAGE f s) \u2286 s", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 s \u2286 t \u2227 \u2203(y :\u03b1). y \u2208 t \u2227 y \u2209 s", "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z", "\u2200(m :num) (n :num) (l :\u03b1 list). m \u2264 n \u2227 n \u2264 LENGTH l \u21d2 BUTLASTN m (LASTN n l) = LASTN (n \u2212 m) (BUTLASTN m l)", "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). f \u2208 DFUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x", "(\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x :\u03b1) (h :\u03b1) (t :\u03b1 list). MEM x (h::t) \u21d4 x = h \u2228 MEM x t", "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d4 s DELETE x = s", "((INL (a :\u03b1) :\u03b1 + \u03b2) \u2208 (A :\u03b1 -> bool) \u2294 (B :\u03b2 -> bool) \u21d4 a \u2208 A) \u2227 ((INR (b :\u03b2) :\u03b1 + \u03b2) \u2208 A \u2294 B \u21d4 b \u2208 B)", "WF (\u03bb(x :num) (y :num). y = SUC x)", "\u2200(L :num list) (n :num). SUM_ACC L n = SUM L + n", "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 s \u2282 \ud835\udd4c(:\u03b1)", "\u2200(ls :\u03b1 list list). FLAT ls = ([] :\u03b1 list) \u21d4 EVERY ($= ([] :\u03b1 list)) ls", "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). INJ f (\u2205 :\u03b1 -> bool) s) \u2227 \u2200(s :\u03b1 -> bool). INJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). (MAP f l = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))", "\u2200(l :num list). SUM l = FOLDR $+ (0 :num) l", "\u2200(R :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list) (n :num). LIST_REL R l1 l2 \u21d2 LIST_REL R (DROP n l1) (DROP n l2)", "(some(x :\u03b1). F) = (NONE :\u03b1 option)", "\u2200(f :\u03b1 -> \u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2", "\u2200(g :\u03b1 -> \u03b1 -> \u03b1) (f :\u03b2 -> \u03b1 -> \u03b1). FCOMM g f \u21d2 \u2200(e :\u03b1). LEFT_ID g e \u21d2 \u2200(l1 :\u03b2 list) (l2 :\u03b2 list). FOLDR f e (l1 ++ l2) = g (FOLDR f e l1) (FOLDR f e l2)", "\u2205 (x :\u03b1) \u21d4 F", "\u2200(R :\u03b1 -> \u03b1 -> bool). WeakLinearOrder R \u21d4 WeakOrder R \u2227 \u2200(a :\u03b1) (b :\u03b1). R a b \u2228 R b a", "\u2200(R :\u03b1 -> \u03b2 -> bool) (R' :\u03b3 -> \u03b1 -> bool). (R \u2218\u1d63 R')\u1d40 = R'\u1d40 \u2218\u1d63 R\u1d40", "\u2200(x :\u03b1) (l :\u03b1 list). x::l = [x] ++ l", "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b2 list). f x::l') ([] :\u03b2 list) l", "\u2200(x :\u03b1). x \u2208 \ud835\udd4c(:\u03b1)", "\ud835\udd4c(:\u03b1 + \u03b2) = \ud835\udd4c(:\u03b1) \u2294 \ud835\udd4c(:\u03b2)", "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (g :\u03b1 -> bool). (s DIFF t) \u2229 g = s \u2229 g DIFF t", "\u2200(Q :num -> bool) (P :num -> bool). (\u2203(n :num). P n) \u2227 (\u2200(n :num). (\u2200(m :num). m < n \u21d2 \u00acP m) \u2227 P n \u21d2 Q n) \u21d2 Q ($LEAST P)", "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). F) xs = ([] :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). TAKE (LENGTH l1) (l1 ++ l2) = l1", "\u2200(l :\u03b1 list list). FLAT l = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l", "(\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acLLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 LLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (LLEX R (h1::t1) (h2::t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)", "\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). f \u2208 FUNSET s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)", "\u2200(b :bool). b \u21d2 (b \u21d4 T)", "\u2200(l :\u03b1 list) (x :\u03b1). ELL (0 :num) (SNOC x l) = x", "\u2200(ls :\u03b1 list). ls \u2260 ([] :\u03b1 list) \u21d2 MAP (f :\u03b1 -> \u03b2) (FRONT ls) = FRONT (MAP f ls)", "\u2200(n :num). (0 :num) < SUC n", "IMAGE (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool) = {(z :\u03b1)} \u21d4 s \u2260 (\u2205 :\u03b2 -> bool) \u2227 \u2200(x :\u03b2). x \u2208 s \u21d2 f x = z", "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l :\u03b1 list). FOLDR f e l = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (a :\u03b1). IS_SUFFIX l1 l2 \u21d2 IS_SUFFIX (a::l1) l2", "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 P \u21d4 P x", "\u2200(R :\u03b1 -> \u03b1 -> bool). StrongOrder R \u21d2 Order R", "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 MEM (EL n l) l", "\u2200(x :\u03b1) (y :\u03b1) (P :\u03b1 -> bool). x \u2208 y INSERT P \u21d4 x = y \u2228 x \u2260 y \u2227 x \u2208 P", "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = SOME (s' :\u03b1) \u21d2 \u00acG s'", "symmetric (R1 :\u03b1 -> \u03b1 -> bool) \u2227 symmetric (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 symmetric (R1 LEX R2)", "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). PREFIX P l \u227c l", "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). (\u2203(t :\u03b2 -> bool). INJ f s t) \u21d2 BIJ f s (IMAGE f s)", "\u2200(s :\u03b1 -> bool). s DIFF \ud835\udd4c(:\u03b1) = (\u2205 :\u03b1 -> bool)", "\u2200(t :bool). t \u2227 t \u21d4 t", "(\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool)) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 (P :\u03b1 -> bool) x) \u21d2 P (CHOICE s)"]