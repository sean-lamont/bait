{"\u2200(s :\u03b1 -> bool). CHOICE s \u2209 REST s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$bool$ IN @ C$pred_set$ CHOICE Vs @ C$pred_set$ REST Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). CHOICE s \u2209 REST s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.SUBSET_transitive, pred_setTheory.SUBSET_ADD, boolTheory.EXISTS_UNIQUE_REFL, pred_setTheory.DELETE_INTER, pred_setTheory.IN_REST]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 s \u2286 t \u2227 t \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$min$ = Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ SUBSET Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 s \u2286 t \u2227 t \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_IMP_THM, pred_setTheory.SUBSET_ANTISYM_EQ, pred_setTheory.SUBSET_ANTISYM_EQ, boolTheory.LEFT_AND_OVER_OR, boolTheory.itself_case_thm]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b2) (a :\u03b1) (b :\u03b2). (x,y) = (a,b) \u21d4 x = a \u2227 y = b": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ @ C$min$ = @ @ C$pair$ , Vx Vy @ @ C$pair$ , Va Vb @ @ C$bool$ /\\ @ @ C$min$ = Vx Va @ @ C$min$ = Vy Vb"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b2) (a :\u03b1) (b :\u03b2). (x,y) = (a,b) \u21d4 x = a \u2227 y = b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.DATATYPE_BOOL, pairTheory.PAIR_EQ, boolTheory.COND_EXPAND_OR, boolTheory.LEFT_AND_OVER_OR, boolTheory.RIGHT_EXISTS_AND_THM]", "reward": 5}]], "\u2200(m :num). m < SUC m \u2227 m < SUC (SUC m)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vm @ C$num$ SUC Vm @ @ C$prim_rec$ < Vm @ C$num$ SUC @ C$num$ SUC Vm"}, "plain": {"assumptions": [], "goal": "\u2200(m :num). m < SUC m \u2227 m < SUC (SUC m)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LET_THM, arithmeticTheory.LESS_MONO_EQ, prim_recTheory.LESS_MONO, numTheory.INV_SUC, boolTheory.LEFT_AND_CONG]", "reward": 5}]], "\u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). SNOC x1 l1 = SNOC x2 l2 \u21d2 LENGTH l1 = LENGTH l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx1 @ C$bool$ ! | Vl1 @ C$bool$ ! | Vx2 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$min$ = @ @ C$list$ SNOC Vx1 Vl1 @ @ C$list$ SNOC Vx2 Vl2 @ @ C$min$ = @ C$list$ LENGTH Vl1 @ C$list$ LENGTH Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). SNOC x1 l1 = SNOC x2 l2 \u21d2 LENGTH l1 = LENGTH l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, listTheory.PAD_RIGHT, listTheory.LAST_DEF, listTheory.EQ_LIST, listTheory.LENGTH_GENLIST]", "reward": 5}]], "\u2200(m :num) (n :num). m < SUC n \u21d2 m = n \u2228 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vm @ C$num$ SUC Vn @ @ C$bool$ \\/ @ @ C$min$ = Vm Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < SUC n \u21d2 m = n \u2228 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[numTheory.num_TY_DEF, boolTheory.literal_case_THM, boolTheory.SWAP_FORALL_THM, boolTheory.PEIRCE, boolTheory.FORALL_DEF]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). ([] :\u03b1 list) \u2260 SNOC x l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ C$bool$ ~ @ @ C$min$ = C$list$ NIL @ @ C$list$ SNOC Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). ([] :\u03b1 list) \u2260 SNOC x l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.DROP_nil, boolTheory.MONO_EXISTS, listTheory.lazy_list_case_compute, listTheory.LENGTH_LEN, listTheory.LENGTH_EQ_SUM]", "reward": 5}]], "\u00ac\u00ac(p :bool) \u21d2 p": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ C$bool$ ~ Vp Vp"}, "plain": {"assumptions": [], "goal": "\u00ac\u00ac(p :bool) \u21d2 p"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.RES_SELECT_DEF, boolTheory.RES_EXISTS_DEF, boolTheory.EXISTS_UNIQUE_DEF, boolTheory.LEFT_FORALL_OR_THM, boolTheory.SELECT_REFL]", "reward": 5}]], "\u2200(t :bool). \u00ac\u00act \u21d4 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vt @ @ C$min$ = @ C$bool$ ~ @ C$bool$ ~ Vt Vt"}, "plain": {"assumptions": [], "goal": "\u2200(t :bool). \u00ac\u00act \u21d4 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_IMP_THM, boolTheory.itself_Axiom, boolTheory.OR_IMP_THM, boolTheory.DATATYPE_TAG_DEF, boolTheory.COND_CLAUSES]", "reward": 5}]], "\u2200(l :\u03b1 list). DROP (LENGTH l) l = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH Vl Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). DROP (LENGTH l) l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP_DROP, boolTheory.MONO_EXISTS, boolTheory.MONO_ALL, listTheory.EVERY2_MAP, listTheory.LIST_EQ_MAP_PAIR]", "reward": 5}]], "MAP (\u03bb((x :\u03b1),(y :\u03b2),(z :\u03b3)). x) (funs :(\u03b1 # \u03b2 # \u03b3) list) = MAP (FST :\u03b1 # \u03b2 # \u03b3 -> \u03b1) funs": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP @ C$pair$ UNCURRY | Vx @ C$pair$ UNCURRY | Vy | Vz Vx Vfuns @ @ C$list$ MAP C$pair$ FST Vfuns"}, "plain": {"assumptions": [], "goal": "MAP (\u03bb((x :\u03b1),(y :\u03b2),(z :\u03b3)). x) (funs :(\u03b1 # \u03b2 # \u03b3) list) = MAP (FST :\u03b1 # \u03b2 # \u03b3 -> \u03b1) funs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_CONJ, listTheory.EVERY_SIMP, listTheory.LIST_EQ, pairTheory.ELIM_UNCURRY, listTheory.MAP_CONG]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d2 s \u2286 t \u2227 t \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$min$ = Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ SUBSET Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d2 s \u2286 t \u2227 t \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_EXISTS_IMP_THM, pred_setTheory.SUBSET_applied, boolTheory.SELECT_REFL_2, pred_setTheory.SUBSET_DEF, boolTheory.IMP_F_EQ_F]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (LENGTH l1) (l1 ++ l2) = l2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (LENGTH l1) (l1 ++ l2) = l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH C$list$ NIL @ @ C$list$ APPEND C$list$ NIL Vl2 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list). DROP (LENGTH ([] :\u03b1 list)) (([] :\u03b1 list) \u29fa l2) = l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). DROP (LENGTH (l1 :\u03b1 list)) (l1 \u29fa l2) = l2"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list). DROP (LENGTH (h::(l1 :\u03b1 list))) (h::l1 \u29fa l2) = l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). DROP (LENGTH (l1 :\u03b1 list)) (l1 \u29fa l2) = l2"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list). DROP (LENGTH (h::(l1 :\u03b1 list))) (h::l1 \u29fa l2) = l2"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_LUPDATE, listTheory.DROP_compute, listTheory.LEN_DEF, boolTheory.RES_FORALL_DEF, listTheory.ITSET_eq_FOLDL_SET_TO_LIST]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.CONJ_COMM, listTheory.list_case_eq, listTheory.LIST_REL_SNOC, listTheory.NOT_EVERY, listTheory.LENGTH]", "reward": 5}]], "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 p": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ ==> Vp Vq Vp"}, "plain": {"assumptions": [], "goal": "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 p"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.RES_EXISTS_CONG, boolTheory.LEFT_EXISTS_IMP_THM, boolTheory.RIGHT_AND_FORALL_THM, boolTheory.COND_ABS, boolTheory.FORALL_DEF]", "reward": 5}]], "\u2200(m :num) (n :num). m = n \u2228 m < n \u21d2 m < SUC n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vm Vn @ @ C$prim_rec$ < Vm Vn @ @ C$prim_rec$ < Vm @ C$num$ SUC Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m = n \u2228 m < n \u21d2 m < SUC n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.BOTH_FORALL_OR_THM, prim_recTheory.LESS_0, boolTheory.EQ_CLAUSES, boolTheory.IMP_F_EQ_F, boolTheory.COND_ABS]", "reward": 5}]], "\u2200(n :num). SUC n \u2260 n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). SUC n \u2260 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.FORALL_THM, boolTheory.COND_RAND, boolTheory.NOT_EXISTS_THM, boolTheory.RIGHT_AND_FORALL_THM, boolTheory.COND_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$pred_set$ PSUBSET Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM1, pred_setTheory.PSUBSET_DEF, boolTheory.BOTH_FORALL_OR_THM, boolTheory.OR_INTRO_THM2, boolTheory.RES_EXISTS_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list). FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (l :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::(l :\u03b1 list)) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ @ C$list$ FOLDR C$list$ CONS C$list$ NIL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (l :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::(l :\u03b1 list)) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FRONT_SNOC, listTheory.SINGL_LIST_APPLY_R, listTheory.GENLIST_APPEND, listTheory.LENGTH_LT_SHORTLEX, listTheory.list_Axiom]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.TAKE_nil, listTheory.FOLDL2_FOLDL, listTheory.NULL_APPEND, listTheory.LUPDATE_SNOC, listTheory.LENGTH_FRONT_CONS]", "reward": 5}]], "countable (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ countable C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "countable (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.REL_RESTRICT_DEF, pred_setTheory.BIJ_support, pred_setTheory.HAS_SIZE_0, pred_setTheory.IMAGE_IN]", "reward": 5}]], "countable \ud835\udd4c(:num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ countable C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "countable \ud835\udd4c(:num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.POW_INSERT, pred_setTheory.SUBSET_UNION_ABSORPTION, pred_setTheory.DELETE_INTER, pred_setTheory.FINITE_BIJ_CARD, pred_setTheory.EQ_SUBSET_SUBSET]", "reward": 5}]], "\u2200(A :bool). A \u21d2 \u00acA \u21d2 F": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VA @ @ C$min$ ==> VA @ @ C$min$ ==> @ C$bool$ ~ VA C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u2200(A :bool). A \u21d2 \u00acA \u21d2 F"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_DEF, boolTheory.ETA_THM, boolTheory.ONTO_DEF, boolTheory.LEFT_EXISTS_AND_THM, boolTheory.UNWIND_THM2]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$list$ APPEND Vl1 C$list$ NIL @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list). l1 \u29fa ([] :\u03b1 list) = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ CONS Vh Vl2 @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(l1 :\u03b1 list). l1 \u29fa (l2 :\u03b1 list) = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2"], "goal": "\u2200(h :\u03b1) (l1 :\u03b1 list). l1 \u29fa h::(l2 :\u03b1 list) = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 (h::l2)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l2`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ CONS Vh Vl2 @ @ @ C$list$ FOLDL | Vl' | Vx @ @ C$list$ SNOC Vx Vl' Vl1 @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(l1 :\u03b1 list). l1 \u29fa (l2 :\u03b1 list) = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 l2"], "goal": "\u2200(h :\u03b1) (l1 :\u03b1 list). l1 \u29fa h::(l2 :\u03b1 list) = FOLDL (\u03bb(l' :\u03b1 list) (x :\u03b1). SNOC x l') l1 (h::l2)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.ETA_THM, listTheory.REVERSE_SNOC, listTheory.LENGTH_LT_SHORTLEX, listTheory.GENLIST_ID, listTheory.LIST_BIND_MAP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.RES_FORALL_TRUE, boolTheory.COND_EXPAND, listTheory.EVERY_CONJ, boolTheory.itself_case_thm, listTheory.OPT_MMAP_def]", "reward": 5}]], "\u2200(m :num) (n :num). m < SUC n \u21d4 m = n \u2228 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$prim_rec$ < Vm @ C$num$ SUC Vn @ @ C$bool$ \\/ @ @ C$min$ = Vm Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < SUC n \u21d4 m = n \u2228 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.AND_INTRO_THM, boolTheory.DISJ_IMP_THM, boolTheory.EXISTS_itself, boolTheory.UEXISTS_SIMP, arithmeticTheory.LESS_MONO_EQ]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n (REVERSE l) = REVERSE (TAKE n l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ LASTN Vn @ C$list$ REVERSE Vl @ C$list$ REVERSE @ @ C$list$ TAKE Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n (REVERSE l) = REVERSE (TAKE n l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.LASTN_def, listTheory.LIST_TO_SET_DEF, rich_listTheory.DROP_SEG, arithmeticTheory.MIN_EQ_0, arithmeticTheory.FUNPOW_1]", "reward": 5}]], "\u2200(b :bool). \u00acb \u21d2 (b \u21d4 F)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vb @ @ C$min$ ==> @ C$bool$ ~ Vb @ @ C$min$ = Vb C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u2200(b :bool). \u00acb \u21d2 (b \u21d4 F)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.LET_CONG, boolTheory.UNWIND_THM2, boolTheory.COND_ABS, boolTheory.LEFT_AND_CONG, boolTheory.FORALL_AND_THM]", "reward": 5}]], "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acp": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ \\/ Vp Vq @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acp"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.LEFT_OR_EXISTS_THM, boolTheory.ABS_SIMP, boolTheory.NOT_IMP, boolTheory.AND_DEF, boolTheory.LEFT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). DISJOINT s s \u21d4 s = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vs Vs @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). DISJOINT s s \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RIGHT_EXISTS_IMP_THM, pred_setTheory.DISJOINT_EMPTY_REFL, pred_setTheory.NOT_UNIV_PSUBSET, boolTheory.MONO_AND, boolTheory.COND_ABS]", "reward": 5}]], "\u2200(p :bool) (q :bool) (m :bool). (p \u2227 stmarker m \u21d4 stmarker m \u2227 p) \u2227 ((stmarker m \u2227 p) \u2227 q \u21d4 stmarker m \u2227 p \u2227 q) \u2227 (p \u2227 stmarker m \u2227 q \u21d4 stmarker m \u2227 p \u2227 q)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ C$bool$ ! | Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ /\\ Vp @ C$marker$ stmarker Vm @ @ C$bool$ /\\ @ C$marker$ stmarker Vm Vp @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$marker$ stmarker Vm Vp Vq @ @ C$bool$ /\\ @ C$marker$ stmarker Vm @ @ C$bool$ /\\ Vp Vq @ @ C$min$ = @ @ C$bool$ /\\ Vp @ @ C$bool$ /\\ @ C$marker$ stmarker Vm Vq @ @ C$bool$ /\\ @ C$marker$ stmarker Vm @ @ C$bool$ /\\ Vp Vq"}, "plain": {"assumptions": [], "goal": "\u2200(p :bool) (q :bool) (m :bool). (p \u2227 stmarker m \u21d4 stmarker m \u2227 p) \u2227 ((stmarker m \u2227 p) \u2227 q \u21d4 stmarker m \u2227 p \u2227 q) \u2227 (p \u2227 stmarker m \u2227 q \u21d4 stmarker m \u2227 p \u2227 q)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOTH_EXISTS_IMP_THM, boolTheory.IMP_ANTISYM_AX, boolTheory.BOTH_EXISTS_AND_THM, boolTheory.MONO_OR, boolTheory.FORALL_AND_THM]", "reward": 5}]], "\u2200(l :\u03b1 list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT Vl @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list list). REVERSE (FLAT l) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "REVERSE (FLAT ([] :\u03b1 list list)) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) ([] :\u03b1 list list)))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT Vl @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["REVERSE (FLAT (l :\u03b1 list list)) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"], "goal": "\u2200(h :\u03b1 list). REVERSE (FLAT (h::(l :\u03b1 list list))) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) (h::l)))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT Vl @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ MAP C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["REVERSE (FLAT (l :\u03b1 list list)) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"], "goal": "\u2200(h :\u03b1 list). REVERSE (FLAT (h::(l :\u03b1 list list))) = FLAT (REVERSE (MAP (REVERSE :\u03b1 list -> \u03b1 list) (h::l)))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SET_TO_LIST_CARD, listTheory.HD_DROP, listTheory.MEM_FILTER, listTheory.splitAtPki_APPEND, listTheory.OPT_MMAP_cong]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EVERY2_sym, listTheory.FRONT_CONS_EQ_NIL, listTheory.DISJOINT_GENLIST_PLUS, boolTheory.bool_INDUCT, listTheory.LENGTH_o_REVERSE]", "reward": 5}]], "\u2200(l :\u03b1 list list). FLAT (REVERSE l) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE Vl @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list list). FLAT (REVERSE l) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE C$list$ NIL @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FLAT (REVERSE ([] :\u03b1 list list)) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) ([] :\u03b1 list list)))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE Vl @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FLAT (REVERSE (l :\u03b1 list list)) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"], "goal": "\u2200(h :\u03b1 list). FLAT (REVERSE (h::(l :\u03b1 list list))) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) (h::l)))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE Vl @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ C$list$ REVERSE @ C$list$ FLAT @ @ C$list$ MAP C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FLAT (REVERSE (l :\u03b1 list list)) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) l))"], "goal": "\u2200(h :\u03b1 list). FLAT (REVERSE (h::(l :\u03b1 list list))) = REVERSE (FLAT (MAP (REVERSE :\u03b1 list -> \u03b1 list) (h::l)))"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.SHORTLEX_THM, boolTheory.EQ_SYM, listTheory.oEL_TAKE_E, listTheory.EL_MAP, listTheory.SUM_ACC_DEF]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_EQ_NIL, listTheory.ALL_DISTINCT_SET_TO_LIST, listTheory.list_case_compute, listTheory.LIST_BIND_LIST_BIND, listTheory.LENGTH_MAP]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a t = t \u222a s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ UNION Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a t = t \u222a s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ONTO_DEF, pred_setTheory.UNION_DEF, boolTheory.DISJ_COMM, boolTheory.BOTH_EXISTS_IMP_THM, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(n :num). (0 :num) < SUC n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). (0 :num) < SUC n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.RIGHT_OR_OVER_AND, boolTheory.EXISTS_UNIQUE_REFL, boolTheory.AND1_THM, boolTheory.EQ_SYM_EQ, boolTheory.RES_EXISTS_UNIQUE_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b1 -> \u03b2). f (EXT_POINT f g) = g (EXT_POINT f g) \u21d4 f = g": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ @ C$min$ = @ @ C$min$ = @ Vf @ @ C$normalForms$ EXT_POINT Vf Vg @ Vg @ @ C$normalForms$ EXT_POINT Vf Vg @ @ C$min$ = Vf Vg"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b1 -> \u03b2). f (EXT_POINT f g) = g (EXT_POINT f g) \u21d4 f = g"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.FORALL_BOOL, boolTheory.BETA_THM, boolTheory.ONE_ONE_DEF, boolTheory.LET_DEF, boolTheory.LET_THM]", "reward": 5}]], "\u2200(x :\u03b1 # \u03b2). \u2203(q :\u03b1) (r :\u03b2). x = (q,r)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ? | Vq @ C$bool$ ? | Vr @ @ C$min$ = Vx @ @ C$pair$ , Vq Vr"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 # \u03b2). \u2203(q :\u03b1) (r :\u03b2). x = (q,r)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp_1 @ C$bool$ ! | Vp_2 @ C$bool$ ? | Vq @ C$bool$ ? | Vr @ @ C$min$ = @ @ C$pair$ , Vp_1 Vp_2 @ @ C$pair$ , Vq Vr"}, "plain": {"assumptions": [], "goal": "\u2200(p_1 :\u03b1) (p_2 :\u03b2). \u2203(q :\u03b1) (r :\u03b2). (p_1,p_2) = (q,r)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.BOTH_FORALL_IMP_THM, boolTheory.TRUTH, boolTheory.COND_ABS, boolTheory.EXISTS_SIMP, pairTheory.CLOSED_PAIR_EQ]", "reward": 5}]], "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d4 \u00acNULL l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ C$bool$ ~ @ C$list$ NULL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d4 \u00acNULL l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH C$list$ NIL @ C$bool$ ~ @ C$list$ NULL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(0 :num) < LENGTH ([] :\u03b1 list) \u21d4 \u00acNULL ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ C$bool$ ~ @ C$list$ NULL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(0 :num) < LENGTH (l :\u03b1 list) \u21d4 \u00acNULL l"], "goal": "\u2200(h :\u03b1). (0 :num) < LENGTH (h::(l :\u03b1 list)) \u21d4 \u00acNULL (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ C$bool$ ~ @ C$list$ NULL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(0 :num) < LENGTH (l :\u03b1 list) \u21d4 \u00acNULL l"], "goal": "\u2200(h :\u03b1). (0 :num) < LENGTH (h::(l :\u03b1 list)) \u21d4 \u00acNULL (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.AND1_THM, boolTheory.DISJ_EQ_IMP, boolTheory.JRH_INDUCT_UTIL, listTheory.MAP_FRONT, boolTheory.EQ_SYM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_REVERSE, prim_recTheory.SIMP_REC_THM, listTheory.FOLDL_UNION_BIGUNION, listTheory.TAKE_LENGTH_ID_rwt, prim_recTheory.SIMP_REC_REL_UNIQUE]", "reward": 5}]], "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(t :\u03b1 list). P t \u21d2 \u2200(h :\u03b1). P (h::t)) \u21d2 \u2200(l :\u03b1 list). P l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP C$list$ NIL @ C$bool$ ! | Vt @ @ C$min$ ==> @ VP Vt @ C$bool$ ! | Vh @ VP @ @ C$list$ CONS Vh Vt @ C$bool$ ! | Vl @ VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(t :\u03b1 list). P t \u21d2 \u2200(h :\u03b1). P (h::t)) \u21d2 \u2200(l :\u03b1 list). P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.list_INDUCT0, boolTheory.CONJ_ASSOC, boolTheory.UEXISTS_SIMP, boolTheory.ABS_REP_THM, boolTheory.NOT_DEF]", "reward": 5}]], "\u2200(X :\u03b1). (P :bool) \u21d4 Case X \u21d2 P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VX @ @ C$min$ = VP @ @ C$min$ ==> @ C$marker$ Case VX VP"}, "plain": {"assumptions": [], "goal": "\u2200(X :\u03b1). (P :bool) \u21d4 Case X \u21d2 P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.SELECT_REFL, boolTheory.EQ_TRANS, markerTheory.Case_def, boolTheory.EXISTS_REFL, boolTheory.bool_case_ID]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 countable s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$pred_set$ countable Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 countable s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_INSERT, boolTheory.itself_induction, boolTheory.ONTO_THM, pred_setTheory.COUNTABLE_ALT_BIJ, boolTheory.EXISTS_UNIQUE_REFL]", "reward": 5}]], "\u2200(x :\u03b1). SING {x}": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$pred_set$ SING @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). SING {x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vx' @ @ C$min$ = @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$pred_set$ INSERT Vx' C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2203(x' :\u03b1). {(x :\u03b1)} = {x'}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, pred_setTheory.UNION_applied, pred_setTheory.SING_DEF, boolTheory.EQ_TRANS, pred_setTheory.DELETE_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vx' @ C$bool$ ! | Vx'' @ @ C$min$ = @ @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY Vx'' @ @ @ C$pred_set$ INSERT Vx' C$pred_set$ EMPTY Vx''"}, "plain": {"assumptions": [], "goal": "\u2203(x' :\u03b1). \u2200(x'' :\u03b1). {(x :\u03b1)} x'' \u21d4 {x'} x''"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.DIFF_SUBSET, boolTheory.NOT_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.SUBSET_applied, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EXTENSION, pred_setTheory.UNIV_BOOL, pred_setTheory.IN_DISJOINT, pred_setTheory.EXTENSION, pred_setTheory.UNION_DIFF_EQ]", "reward": 5}]], "(p :bool) \u2227 (q :bool) \u21d2 p": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ Vp Vq Vp"}, "plain": {"assumptions": [], "goal": "(p :bool) \u2227 (q :bool) \u21d2 p"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.IMP_CONJ_THM, boolTheory.RES_EXISTS_FALSE, boolTheory.SWAP_FORALL_THM, boolTheory.EQ_TRANS, boolTheory.AND_CONG]", "reward": 5}]], "(\u2200(l :\u03b1 list). DROP (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). DROP (SUC n) (x::l) = DROP n l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ DROP C$num$ 0 Vl Vl @ C$bool$ ! | Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ DROP Vn Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). DROP (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). DROP (SUC n) (x::l) = DROP n l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FORALL_SIMP, listTheory.SET_TO_LIST_primitive_def, listTheory.FILTER_EQ_NIL, listTheory.nub_EQ0, listTheory.MAP_EQ_EVERY2]", "reward": 5}]], "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(l :\u03b1 list). P l \u21d2 \u2200(a :\u03b1). P (a::l)) \u21d2 \u2200(l :\u03b1 list). P l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP C$list$ NIL @ C$bool$ ! | Vl @ @ C$min$ ==> @ VP Vl @ C$bool$ ! | Va @ VP @ @ C$list$ CONS Va Vl @ C$bool$ ! | Vl @ VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 list -> bool). P ([] :\u03b1 list) \u2227 (\u2200(l :\u03b1 list). P l \u21d2 \u2200(a :\u03b1). P (a::l)) \u21d2 \u2200(l :\u03b1 list). P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ @ C$min$ ==> @ VP Vl @ C$bool$ ! | Va @ VP @ @ C$list$ CONS Va Vl", "@ VP C$list$ NIL"], "goal": "@ VP Vl"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list). (P :\u03b1 list -> bool) l \u21d2 \u2200(a :\u03b1). P (a::l)", "(P :\u03b1 list -> bool) ([] :\u03b1 list)"], "goal": "(P :\u03b1 list -> bool) (l :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LET_DEF, boolTheory.EXISTS_UNIQUE_DEF, boolTheory.DISJ_ASSOC, boolTheory.SELECT_REFL_2, boolTheory.LEFT_FORALL_IMP_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ @ C$min$ ==> @ VP Vl @ C$bool$ ! | Va @ VP @ @ C$list$ CONS Va Vl", "@ VP C$list$ NIL"], "goal": "@ VP C$list$ NIL"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list). (P :\u03b1 list -> bool) l \u21d2 \u2200(a :\u03b1). P (a::l)", "(P :\u03b1 list -> bool) ([] :\u03b1 list)"], "goal": "(P :\u03b1 list -> bool) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ VP Vl", "@ C$bool$ ! | Vl @ @ C$min$ ==> @ VP Vl @ C$bool$ ! | Va @ VP @ @ C$list$ CONS Va Vl", "@ VP C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(P :\u03b1 list -> bool) (l :\u03b1 list)", "\u2200(l :\u03b1 list). (P :\u03b1 list -> bool) l \u21d2 \u2200(a :\u03b1). P (a::l)", "(P :\u03b1 list -> bool) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). (P :\u03b1 list -> bool) (h::(l :\u03b1 list))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ VP Vl", "@ C$bool$ ! | Vl @ @ C$min$ ==> @ VP Vl @ C$bool$ ! | Va @ VP @ @ C$list$ CONS Va Vl", "@ VP C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(P :\u03b1 list -> bool) (l :\u03b1 list)", "\u2200(l :\u03b1 list). (P :\u03b1 list -> bool) l \u21d2 \u2200(a :\u03b1). P (a::l)", "(P :\u03b1 list -> bool) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). (P :\u03b1 list -> bool) (h::(l :\u03b1 list))"}}], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.itself_induction, boolTheory.CONJ_ASSOC, listTheory.NULL_DEF, boolTheory.NOT_AND, boolTheory.UNWIND_FORALL_THM2]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[boolTheory.COND_EXPAND_IMP, listTheory.FOLDL, listTheory.MAP2_DEF, boolTheory.bool_case_ID, boolTheory.EQ_EXT]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR $/\\ T (MAP P l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR $/\\ T (MAP P l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP C$list$ NIL @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). EVERY P ([] :\u03b1 list) \u21d4 FOLDR $/\\ T (MAP P ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EVERY P (l :\u03b1 list) \u21d4 FOLDR $/\\ T (MAP P l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EVERY P (h::(l :\u03b1 list)) \u21d4 FOLDR $/\\ T (MAP P (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T @ @ C$list$ MAP VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EVERY P (l :\u03b1 list) \u21d4 FOLDR $/\\ T (MAP P l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EVERY P (h::(l :\u03b1 list)) \u21d4 FOLDR $/\\ T (MAP P (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LRC_MEM, boolTheory.EXISTS_UNIQUE_REFL, listTheory.LAST_CONS, listTheory.LIST_TO_SET_FLAT, listTheory.nub_append]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.oEL_def, listTheory.FILTER_EQ_NIL, listTheory.MEM_SPLIT, listTheory.NULL_FILTER, listTheory.MAP_EQ_f]", "reward": 5}]], "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EXISTS P (l :\u03b1 list) \u21d2 EXISTS Q l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VQ Vx @ @ C$min$ ==> @ @ C$list$ EXISTS VP Vl @ @ C$list$ EXISTS VQ Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EXISTS P (l :\u03b1 list) \u21d2 EXISTS Q l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.EVERY_CONJ, boolTheory.ABS_SIMP, listTheory.EXISTS_MEM, boolTheory.DATATYPE_TAG_DEF, boolTheory.IN_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list list). FLAT l = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ FLAT Vl @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list list). FLAT l = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ FLAT C$list$ NIL @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FLAT ([] :\u03b1 list list) = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) ([] :\u03b1 list list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT Vl @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FLAT (l :\u03b1 list list) = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1 list). FLAT (h::(l :\u03b1 list list)) = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT Vl @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FLAT (l :\u03b1 list list) = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1 list). FLAT (h::(l :\u03b1 list list)) = FOLDR ($++ :\u03b1 list -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.EVERY_MEM_MONO, listTheory.ALL_DISTINCT_MAP, listTheory.MEM_SPLIT, listTheory.oHD_thm, listTheory.SET_TO_LIST_IND]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.DATATYPE_TAG_THM, boolTheory.EXISTS_DEF, listTheory.EVERY2_LUPDATE_same, boolTheory.CONJ_ASSOC, listTheory.OPT_MMAP_cong]", "reward": 5}]], "\u2200(P :\u03b1 # \u03b2 -> bool). (\u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)) \u21d2 \u2200(p :\u03b1 # \u03b2). P p": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vp_1 @ C$bool$ ! | Vp_2 @ VP @ @ C$pair$ , Vp_1 Vp_2 @ C$bool$ ! | Vp @ VP Vp"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 # \u03b2 -> bool). (\u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)) \u21d2 \u2200(p :\u03b1 # \u03b2). P p"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.itself_case_thm, boolTheory.MONO_EXISTS, boolTheory.RIGHT_OR_OVER_AND, pairTheory.ABS_PAIR_THM, boolTheory.UNWIND_FORALL_THM2]", "reward": 5}]], "\u2200(x :\u03b1 list) (l :\u03b1 list list). FLAT (SNOC x l) = FLAT l ++ x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ SNOC Vx Vl @ @ C$list$ APPEND @ C$list$ FLAT Vl Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list) (l :\u03b1 list list). FLAT (SNOC x l) = FLAT l ++ x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.MAP_ID, boolTheory.LET_DEF, listTheory.ZIP_UNZIP, listTheory.EL_ZIP, listTheory.LIST_APPLY_o]", "reward": 5}]], "\u2200(S :\u03b1 -> bool). FINITE S \u21d2 \u2200(t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f S t \u2227 FINITE t \u21d2 CARD S = CARD t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VS @ @ C$min$ ==> @ C$pred_set$ FINITE VS @ C$bool$ ! | Vt @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$pred_set$ BIJ Vf VS Vt @ C$pred_set$ FINITE Vt @ @ C$min$ = @ C$pred_set$ CARD VS @ C$pred_set$ CARD Vt"}, "plain": {"assumptions": [], "goal": "\u2200(S :\u03b1 -> bool). FINITE S \u21d2 \u2200(t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f S t \u2227 FINITE t \u21d2 CARD S = CARD t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.FINITE_BIJ_CARD, pred_setTheory.GSPEC_PAIR_ETA, pred_setTheory.SPECIFICATION, boolTheory.EQ_SYM, boolTheory.OR_IMP_THM]", "reward": 5}]], "\u2200(b :bool). b \u21d2 (b \u21d4 T)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vb @ @ C$min$ ==> Vb @ @ C$min$ = Vb C$bool$ T"}, "plain": {"assumptions": [], "goal": "\u2200(b :bool). b \u21d2 (b \u21d4 T)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.IMP_CONG, boolTheory.LEFT_AND_OVER_OR, boolTheory.EQ_REFL, boolTheory.RES_FORALL_TRUE, boolTheory.ONTO_THM]", "reward": 5}]], "(\u2200(f :\u03b1 -> \u03b2 -> \u03b3). MAP2 f ([] :\u03b1 list) ([] :\u03b2 list) = ([] :\u03b3 list)) \u2227 \u2200(f :\u03b4 -> \u03b5 -> \u03b6) (h1 :\u03b4) (t1 :\u03b4 list) (h2 :\u03b5) (t2 :\u03b5 list). MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vf @ @ C$min$ = @ @ @ C$list$ MAP2 Vf C$list$ NIL C$list$ NIL C$list$ NIL @ C$bool$ ! | Vf @ C$bool$ ! | Vh1 @ C$bool$ ! | Vt1 @ C$bool$ ! | Vh2 @ C$bool$ ! | Vt2 @ @ C$min$ = @ @ @ C$list$ MAP2 Vf @ @ C$list$ CONS Vh1 Vt1 @ @ C$list$ CONS Vh2 Vt2 @ @ C$list$ CONS @ @ Vf Vh1 Vh2 @ @ @ C$list$ MAP2 Vf Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "(\u2200(f :\u03b1 -> \u03b2 -> \u03b3). MAP2 f ([] :\u03b1 list) ([] :\u03b2 list) = ([] :\u03b3 list)) \u2227 \u2200(f :\u03b4 -> \u03b5 -> \u03b6) (h1 :\u03b4) (t1 :\u03b4 list) (h2 :\u03b5) (t2 :\u03b5 list). MAP2 f (h1::t1) (h2::t2) = f h1 h2::MAP2 f t1 t2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.PULL_EXISTS, boolTheory.OR_CLAUSES, listTheory.FLAT, listTheory.MAP2_DEF, boolTheory.LEFT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). TAKE (LENGTH l1) (l1 ++ l2) = l1": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). TAKE (LENGTH l1) (l1 ++ l2) = l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FORALL_AND_THM, listTheory.LIST_TO_SET_FLAT, listTheory.LIST_TO_SET_MAP, listTheory.LIST_REL_cases, listTheory.TAKE_APPEND1]", "reward": 5}]], "\u2200(x :\u03b1). x \u2209 (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ~ @ @ C$bool$ IN Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x \u2209 (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, boolTheory.IMP_DISJ_THM, boolTheory.ETA_THM, pred_setTheory.PAIR_IN_GSPEC_same, pred_setTheory.EMPTY_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT l) = PRE (LENGTH l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT Vl @ C$prim_rec$ PRE @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT l) = PRE (LENGTH l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT C$list$ NIL @ C$prim_rec$ PRE @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT ([] :\u03b1 list)) = PRE (LENGTH ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT Vl @ C$prim_rec$ PRE @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vh Vl @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT l) = PRE (LENGTH l)"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT (h::l)) = PRE (LENGTH (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT Vl @ C$prim_rec$ PRE @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vh Vl @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT l) = PRE (LENGTH l)"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 LENGTH (FRONT (h::l)) = PRE (LENGTH (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.isPREFIX, listTheory.SET_TO_LIST_EMPTY, boolTheory.COND_RATOR, listTheory.LLEX_EL_THM, listTheory.NOT_NIL_EQ_LENGTH_NOT_0]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LLEX_EL_THM, listTheory.UNZIP_ZIP, listTheory.list_TY_DEF, listTheory.NULL_LENGTH, listTheory.PAD_RIGHT]", "reward": 5}]], "\u2200(n :num) (l1 :\u03b1 list). n \u2264 LENGTH l1 \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ l2": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl1 @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l1 :\u03b1 list). n \u2264 LENGTH l1 \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH C$list$ NIL @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn C$list$ NIL Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). n \u2264 LENGTH ([] :\u03b1 list) \u21d2 \u2200(l2 :\u03b1 list). DROP n (([] :\u03b1 list) \u29fa l2) = DROP n ([] :\u03b1 list) \u29fa l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num). n \u2264 LENGTH (l1 :\u03b1 list) \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 \u29fa l2) = DROP n l1 \u29fa l2"], "goal": "\u2200(h :\u03b1) (n :num). n \u2264 LENGTH (h::(l1 :\u03b1 list)) \u21d2 \u2200(l2 :\u03b1 list). DROP n (h::l1 \u29fa l2) = DROP n (h::l1) \u29fa l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num). n \u2264 LENGTH (l1 :\u03b1 list) \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 \u29fa l2) = DROP n l1 \u29fa l2"], "goal": "\u2200(h :\u03b1) (n :num). n \u2264 LENGTH (h::(l1 :\u03b1 list)) \u21d2 \u2200(l2 :\u03b1 list). DROP n (h::l1 \u29fa l2) = DROP n (h::l1) \u29fa l2"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, arithmeticTheory.LESS_MULT2, arithmeticTheory.LESS_EQ_0, arithmeticTheory.NOT_LT_ZERO_EQ_ZERO, listTheory.SNOC_APPEND]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= Vn @ C$num$ SUC @ C$list$ LENGTH Vl1", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 Vl2"], "goal": "@ @ C$min$ = @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl1 Vl2 @ @ C$list$ APPEND @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl1 Vl2"}, "plain": {"assumptions": ["(n :num) \u2264 SUC (LENGTH (l1 :\u03b1 list))", "\u2200(n :num). n \u2264 LENGTH (l1 :\u03b1 list) \u21d2 \u2200(l2 :\u03b1 list). DROP n (l1 \u29fa l2) = DROP n l1 \u29fa l2"], "goal": "(if (n :num) = (0 :num) then (h :\u03b1)::((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) else DROP (n \u2212 (1 :num)) l1 \u29fa l2) = (if n = (0 :num) then h::l1 else DROP (n \u2212 (1 :num)) l1) \u29fa l2"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.isPREFIX_THM, arithmeticTheory.ABS_DIFF_LE_SUM, listTheory.DROP_def, listTheory.SUM, listTheory.TAKE_DROP]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.EXISTS_SNOC, listTheory.MAP_MAP_o, arithmeticTheory.EVEN_ODD, listTheory.SNOC_APPEND, listTheory.GENLIST_GENLIST_AUX]", "reward": 5}]], "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 = h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l2 \u21d2 h1::l1 = h2::l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vh1 @ C$bool$ ! | Vh2 @ @ C$min$ ==> @ @ C$min$ = Vh1 Vh2 @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$min$ = Vl1 Vl2 @ @ C$min$ = @ @ C$list$ CONS Vh1 Vl1 @ @ C$list$ CONS Vh2 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 = h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l2 \u21d2 h1::l1 = h2::l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.itself_TY_DEF, boolTheory.SELECT_UNIQUE, boolTheory.FORALL_BOOL, boolTheory.RES_EXISTS_UNIQUE_DEF, boolTheory.RIGHT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (l :\u03b2 list). EVERY P (MAP f l) \u21d4 EVERY (P \u2218 f) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vf @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf Vl @ @ C$list$ EVERY @ @ C$combin$ o VP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (l :\u03b2 list). EVERY P (MAP f l) \u21d4 EVERY (P \u2218 f) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf C$list$ NIL @ @ C$list$ EVERY @ @ C$combin$ o VP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1). EVERY P (MAP f ([] :\u03b2 list)) \u21d4 EVERY (P \u2218 f) ([] :\u03b2 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf Vl @ @ C$list$ EVERY @ @ C$combin$ o VP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY @ @ C$combin$ o VP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1). EVERY P (MAP f (l :\u03b2 list)) \u21d4 EVERY (P \u2218 f) l"], "goal": "\u2200(h :\u03b2) (P :\u03b1 -> bool) (f :\u03b2 -> \u03b1). EVERY P (MAP f (h::(l :\u03b2 list))) \u21d4 EVERY (P \u2218 f) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf Vl @ @ C$list$ EVERY @ @ C$combin$ o VP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY @ @ C$combin$ o VP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1). EVERY P (MAP f (l :\u03b2 list)) \u21d4 EVERY (P \u2218 f) l"], "goal": "\u2200(h :\u03b2) (P :\u03b1 -> bool) (f :\u03b2 -> \u03b1). EVERY P (MAP f (h::(l :\u03b2 list))) \u21d4 EVERY (P \u2218 f) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FILTER_EQ_NIL, listTheory.EVERY2_REVERSE, boolTheory.AND1_THM, listTheory.EVERY2_LENGTH, listTheory.MEM_APPEND_lemma]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.SET_TO_LIST_THM, boolTheory.OR_INTRO_THM2, listTheory.FILTER_EQ_APPEND, boolTheory.OR_DEF, listTheory.MAP_LIST_BIND]", "reward": 5}]], "\u2200(n :num). n < SUC n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$prim_rec$ < Vn @ C$num$ SUC Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). n < SUC n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[prim_recTheory.PRE, boolTheory.FORALL_SIMP, boolTheory.ONE_ONE_THM, prim_recTheory.PRE, boolTheory.OR_CLAUSES]", "reward": 5}]], "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). (0 :num) < n \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 C$num$ 0 @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE C$num$ 0 Vl"}, "plain": {"assumptions": [], "goal": "(0 :num) < (0 :num) \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL (0 :num) (x::l) = EL (PRE (0 :num)) l"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE @ C$num$ SUC Vn Vl"}, "plain": {"assumptions": ["(0 :num) < (n :num) \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l"], "goal": "(0 :num) < SUC (n :num) \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL (SUC n) (x::l) = EL (PRE (SUC n)) l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ EL @ C$prim_rec$ PRE @ C$num$ SUC Vn Vl"}, "plain": {"assumptions": ["(0 :num) < (n :num) \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL n (x::l) = EL (PRE n) l"], "goal": "(0 :num) < SUC (n :num) \u21d2 \u2200(x :\u03b1) (l :\u03b1 list). EL (SUC n) (x::l) = EL (PRE (SUC n)) l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.DROP_TAKE, listTheory.UNION_APPEND, listTheory.ITSET_eq_FOLDL_SET_TO_LIST, listTheory.EL_MAP2, boolTheory.CONJ_ASSOC]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.LET_THM, listTheory.REV_REVERSE_LEM, listTheory.EXISTS_NOT_EVERY, listTheory.REVERSE_EQ_NIL, boolTheory.literal_case_DEF]", "reward": 5}]], "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 PROD_ALL P Q (p :\u03b1 # \u03b2) \u21d2 PROD_ALL P' Q' p": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VP' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ VQ Vy @ VQ' Vy @ @ C$min$ ==> @ @ @ C$pair$ PROD_ALL VP VQ Vp @ @ @ C$pair$ PROD_ALL VP' VQ' Vp"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 PROD_ALL P Q (p :\u03b1 # \u03b2) \u21d2 PROD_ALL P' Q' p"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.EQ_TRANS, pairTheory.PROD_ALL_def, boolTheory.PEIRCE, pairTheory.ELIM_UNCURRY, boolTheory.ABS_REP_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 \u2200(x :\u03b1). s x \u21d2 t x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 \u2200(x :\u03b1). s x \u21d2 t x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.FORALL_SIMP, pred_setTheory.EMPTY_DEF, pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "(0 :num) = LENGTH (l :\u03b1 list) \u21d4 l = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$list$ LENGTH Vl @ @ C$min$ = Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(0 :num) = LENGTH (l :\u03b1 list) \u21d4 l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_CONJ, numTheory.ZERO_DEF, listTheory.LENGTH_NIL, listTheory.CONS_11, listTheory.MAP2_APPEND]", "reward": 5}]], "((p :bool) \u21d4 ((q :bool) \u21d4 (r :bool))) \u21d4 (p \u2228 q \u2228 r) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (q \u2228 \u00acr \u2228 \u00acp) \u2227 (r \u2228 \u00acq \u2228 \u00acp)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vp @ @ C$min$ = Vq Vr @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ Vq Vr @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ @ C$bool$ ~ Vr @ C$bool$ ~ Vq @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vq @ @ C$bool$ \\/ @ C$bool$ ~ Vr @ C$bool$ ~ Vp @ @ C$bool$ \\/ Vr @ @ C$bool$ \\/ @ C$bool$ ~ Vq @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "((p :bool) \u21d4 ((q :bool) \u21d4 (r :bool))) \u21d4 (p \u2228 q \u2228 r) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (q \u2228 \u00acr \u2228 \u00acp) \u2227 (r \u2228 \u00acq \u2228 \u00acp)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_COND, boolTheory.AND2_THM, boolTheory.AND2_THM, boolTheory.literal_case_RATOR, boolTheory.MONO_EXISTS]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR $\\/ F (MAP P l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR $\\/ F (MAP P l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP C$list$ NIL @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). EXISTS P ([] :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP P ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EXISTS P (l :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP P l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EXISTS P (h::(l :\u03b1 list)) \u21d4 FOLDR $\\/ F (MAP P (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EXISTS P (l :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP P l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EXISTS P (h::(l :\u03b1 list)) \u21d4 FOLDR $\\/ F (MAP P (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.length_nub_append, listTheory.TAKE_TAKE_MIN, listTheory.FOLDL_EQ_FOLDR, listTheory.LEN_DEF, boolTheory.PULL_EXISTS]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.SNOC, listTheory.EVERY_FLAT, listTheory.oEL_THM, listTheory.SET_TO_LIST_IN_MEM, listTheory.SUM_SNOC]", "reward": 5}]], "\u2200(A :bool) (B :bool) (C :bool). A \u2227 B \u21d2 C \u21d4 A \u21d2 B \u21d2 C": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VA @ C$bool$ ! | VB @ C$bool$ ! | VC @ @ C$min$ = @ @ C$min$ ==> @ @ C$bool$ /\\ VA VB VC @ @ C$min$ ==> VA @ @ C$min$ ==> VB VC"}, "plain": {"assumptions": [], "goal": "\u2200(A :bool) (B :bool) (C :bool). A \u2227 B \u21d2 C \u21d4 A \u21d2 B \u21d2 C"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_F, boolTheory.FUN_EQ_THM, boolTheory.UEXISTS_SIMP, boolTheory.REFL_CLAUSE, boolTheory.DATATYPE_TAG_THM]", "reward": 5}]], "\u2200(n :num). \u00ac(n < (0 :num))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ~ @ @ C$prim_rec$ < Vn C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). \u00ac(n < (0 :num))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_COND, boolTheory.RIGHT_FORALL_OR_THM, boolTheory.EXISTS_UNIQUE_REFL, boolTheory.bool_INDUCT, numTheory.INDUCTION]", "reward": 5}]], "$OLEAST (P :num -> bool) = (NONE :num option) \u21d4 \u2200(n :num). \u00acP n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$while$ OLEAST VP C$option$ NONE @ C$bool$ ! | Vn @ C$bool$ ~ @ VP Vn"}, "plain": {"assumptions": [], "goal": "$OLEAST (P :num -> bool) = (NONE :num option) \u21d4 \u2200(n :num). \u00acP n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, boolTheory.LEFT_FORALL_OR_THM, whileTheory.OLEAST_def, boolTheory.IMP_CLAUSES, boolTheory.MONO_NOT_EQ]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). FILTER P ([] :\u03b1 list) = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). FILTER P (l :\u03b1 list) = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). FILTER P (h::(l :\u03b1 list)) = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' Vl' C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). FILTER P (l :\u03b1 list) = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). FILTER P (h::(l :\u03b1 list)) = FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else l') ([] :\u03b1 list) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.SKOLEM_THM, boolTheory.LEFT_AND_CONG, listTheory.EL_ALL_DISTINCT_EL_EQ, listTheory.MONO_EVERY, listTheory.LIST_BIND_ID]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.LEFT_AND_OVER_OR, listTheory.MEM_dropWhile_IMP, boolTheory.IMP_CONG, listTheory.LENGTH_TAKE, listTheory.SUM_ACC_SUM_LEM]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = REVERSE (x::REVERSE l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ SNOC Vx Vl @ C$list$ REVERSE @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = REVERSE (x::REVERSE l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_CLAUSES, listTheory.MAP_TAKE, listTheory.LENGTH_EQ_NUM, listTheory.ZIP_MAP, boolTheory.DATATYPE_BOOL]", "reward": 5}]], "(0 :num) < SUC (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC C$num$ 0"}, "plain": {"assumptions": [], "goal": "(0 :num) < SUC (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[numTheory.INDUCTION, prim_recTheory.LESS_REFL, numTheory.num_ISO_DEF, prim_recTheory.PRE, prim_recTheory.LESS_REFL]", "reward": 5}]], "\u2200(l :\u03b1 list) (m :num). m = LENGTH l \u21d2 DROP m l = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$min$ = Vm @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vm Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (m :num). m = LENGTH l \u21d2 DROP m l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_BIND_LIST_BIND, boolTheory.BOOL_EQ_DISTINCT, listTheory.MAP_GENLIST, boolTheory.LET_RATOR, boolTheory.EXISTS_itself]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (x :\u03b1). x \u2208 P \u21d4 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx VP @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (x :\u03b1). x \u2208 P \u21d4 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.IN_DEF, boolTheory.EXISTS_SIMP, boolTheory.BOOL_FUN_INDUCT, boolTheory.LEFT_FORALL_OR_THM, boolTheory.literal_case_RAND]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l \u2260 ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ SNOC Vx Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l \u2260 ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.TAKE_APPEND1, listTheory.EVERY_DEF, boolTheory.EXISTS_REFL, listTheory.ALL_DISTINCT_SNOC, listTheory.MAP_EQ_APPEND]", "reward": 5}]], "\u2200(m :num) (n :num). SUC m < n \u21d2 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vm Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). SUC m < n \u21d2 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.NOT_AND, boolTheory.EXISTS_UNIQUE_DEF, boolTheory.RIGHT_FORALL_OR_THM, boolTheory.IMP_CONG, boolTheory.RES_FORALL_DEF]", "reward": 5}]], "\u2200(m :num) (n :num). m < n \u21d2 m \u2260 n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ C$bool$ ~ @ @ C$min$ = Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < n \u21d2 m \u2260 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.NOT_IMP, boolTheory.LET_DEF, prim_recTheory.LESS_SUC_REFL, boolTheory.EQ_TRANS, boolTheory.BETA_THM]", "reward": 5}]], "((p :bool) \u21d4 \u00ac(q :bool)) \u21d4 (p \u2228 q) \u2227 (\u00acq \u2228 \u00acp)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vp @ C$bool$ ~ Vq @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp Vq @ @ C$bool$ \\/ @ C$bool$ ~ Vq @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "((p :bool) \u21d4 \u00ac(q :bool)) \u21d4 (p \u2228 q) \u2227 (\u00acq \u2228 \u00acp)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.EXISTS_UNIQUE_DEF, boolTheory.F_IMP, boolTheory.NOT_F, boolTheory.MONO_AND, boolTheory.LEFT_AND_FORALL_THM]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). x::l = [x] ++ l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ CONS Vx Vl @ @ C$list$ APPEND @ @ C$list$ CONS Vx C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). x::l = [x] ++ l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SUM_IMAGE_LIST_TO_SET_upper_bound, listTheory.MAP2_NIL, boolTheory.SELECT_REFL_2, boolTheory.ONE_ONE_THM, listTheory.MAP_FLAT]", "reward": 5}]], "\u2200(m :num) (n :num). (\u03bb(x :num) (y :num). y = SUC x)\u207a m (SUC n) \u21d4 (\u03bb(x :num) (y :num). y = SUC x)\ua673 m n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vm @ C$num$ SUC Vn @ @ @ C$relation$ RTC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). (\u03bb(x :num) (y :num). y = SUC x)\u207a m (SUC n) \u21d4 (\u03bb(x :num) (y :num). y = SUC x)\ua673 m n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.inv_image_thm, relationTheory.O_DEF, relationTheory.RESTRICT_LEMMA, relationTheory.INVOL_ONE_ONE, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list list). MAP f (FLAT l) = FLAT (MAP (MAP f) l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list list). MAP f (FLAT l) = FLAT (MAP (MAP f) l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.datatype_list, listTheory.LIST_GUARD_def, listTheory.MAP_FLAT, listTheory.oEL_DROP, listTheory.isPREFIX_CONSR]", "reward": 5}]], "(p :bool) \u2227 (q :bool) \u21d2 q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ Vp Vq Vq"}, "plain": {"assumptions": [], "goal": "(p :bool) \u2227 (q :bool) \u21d2 q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.NOT_EXISTS_THM, boolTheory.ABS_SIMP, boolTheory.FORALL_BOOL, boolTheory.NOT_CLAUSES, boolTheory.MONO_NOT]", "reward": 5}]], "(R :\u03b1 -> \u03b1 -> bool)\ua673 (x :\u03b1) x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ @ C$relation$ RTC VR Vx Vx"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool)\ua673 (x :\u03b1) x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.TC_DEF, relationTheory.RTC_def, relationTheory.total_def, relationTheory.RTC_def, relationTheory.SC_DEF]", "reward": 5}]], "\u2200(m :num) (n :num). m < n \u21d2 SUC m < SUC n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ @ C$prim_rec$ < @ C$num$ SUC Vm @ C$num$ SUC Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < n \u21d2 SUC m < SUC n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.NOT_IMP, boolTheory.EQ_IMP_THM, boolTheory.FORALL_itself, boolTheory.NOT_F, boolTheory.ABS_SIMP]", "reward": 5}]], "\u2200(P :num -> bool). P (0 :num) \u2227 (\u2200(n :num). P n \u21d2 P (SUC n)) \u21d2 \u2200(n :num). P n": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP C$num$ 0 @ C$bool$ ! | Vn @ @ C$min$ ==> @ VP Vn @ VP @ C$num$ SUC Vn @ C$bool$ ! | Vn @ VP Vn"}, "plain": {"assumptions": [], "goal": "\u2200(P :num -> bool). P (0 :num) \u2227 (\u2200(n :num). P n \u21d2 P (SUC n)) \u21d2 \u2200(n :num). P n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ VP Vn @ VP @ C$num$ SUC Vn", "@ VP C$num$ 0"], "goal": "@ VP Vn"}, "plain": {"assumptions": ["\u2200(n :num). (P :num -> bool) n \u21d2 P (SUC n)", "(P :num -> bool) (0 :num)"], "goal": "(P :num -> bool) (n :num)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_OR_EXISTS_THM, boolTheory.SWAP_FORALL_THM, boolTheory.EQ_IMP_THM, boolTheory.FUN_EQ_THM, boolTheory.RIGHT_AND_OVER_OR]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ VP Vn @ VP @ C$num$ SUC Vn", "@ VP C$num$ 0"], "goal": "@ VP C$num$ 0"}, "plain": {"assumptions": ["\u2200(n :num). (P :num -> bool) n \u21d2 P (SUC n)", "(P :num -> bool) (0 :num)"], "goal": "(P :num -> bool) (0 :num)"}}, {"polished": {"assumptions": ["@ VP Vn", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ VP Vn @ VP @ C$num$ SUC Vn", "@ VP C$num$ 0"], "goal": "@ VP @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(P :num -> bool) (n :num)", "\u2200(n :num). (P :num -> bool) n \u21d2 P (SUC n)", "(P :num -> bool) (0 :num)"], "goal": "(P :num -> bool) (SUC (n :num))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ VP Vn", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ VP Vn @ VP @ C$num$ SUC Vn", "@ VP C$num$ 0"], "goal": "@ VP @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(P :num -> bool) (n :num)", "\u2200(n :num). (P :num -> bool) n \u21d2 P (SUC n)", "(P :num -> bool) (0 :num)"], "goal": "(P :num -> bool) (SUC (n :num))"}}], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.EXISTS_THM, boolTheory.T_DEF, numTheory.num_ISO_DEF, boolTheory.SWAP_EXISTS_THM, numTheory.INV_SUC]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[boolTheory.ONTO_THM, numTheory.num_ISO_DEF, boolTheory.NOT_IMP, boolTheory.EQ_IMP_THM, boolTheory.NOT_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list). REVERSE l = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ REVERSE Vl @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). REVERSE l = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ REVERSE C$list$ NIL @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "REVERSE ([] :\u03b1 list) = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ REVERSE Vl @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["REVERSE (l :\u03b1 list) = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1). REVERSE (h::(l :\u03b1 list)) = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ REVERSE Vl @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ SNOC C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["REVERSE (l :\u03b1 list) = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) l"], "goal": "\u2200(h :\u03b1). REVERSE (h::(l :\u03b1 list)) = FOLDR (SNOC :\u03b1 -> \u03b1 list -> \u03b1 list) ([] :\u03b1 list) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_FILTER, listTheory.LENGTH_EQ_NIL, listTheory.LENGTH_dropWhile_LESS_EQ, listTheory.REVERSE_APPEND, listTheory.LENGTH_LT_SHORTLEX]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_BIND_LIST_BIND, listTheory.LUPDATE_SEM, listTheory.LAST_CONS, listTheory.INDEX_OF_def, boolTheory.EXISTS_OR_THM]", "reward": 5}]], "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 \u2260 h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). h1::l1 \u2260 h2::l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vh1 @ C$bool$ ! | Vh2 @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vh1 Vh2 @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh1 Vl1 @ @ C$list$ CONS Vh2 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(h1 :\u03b1) (h2 :\u03b1). h1 \u2260 h2 \u21d2 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). h1::l1 \u2260 h2::l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.UNWIND_THM2, listTheory.CONS_11, listTheory.APPEND, listTheory.MAP2_DEF, boolTheory.BOUNDED_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e [x] = f x e": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ CONS Vx C$list$ NIL @ @ Vf Vx Ve"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e [x] = f x e"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LLEX_def, listTheory.ZIP_def, listTheory.MAP_CONG, boolTheory.NOT_EXISTS_THM, listTheory.TL_GENLIST]", "reward": 5}]], "(\u2200(l :\u03b1 list). TAKE (0 :num) l = ([] :\u03b1 list)) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). TAKE (SUC n) (x::l) = x::TAKE n l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 Vl C$list$ NIL @ C$bool$ ! | Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vx Vl @ @ C$list$ CONS Vx @ @ C$list$ TAKE Vn Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). TAKE (0 :num) l = ([] :\u03b1 list)) \u2227 \u2200(n :num) (x :\u03b1) (l :\u03b1 list). TAKE (SUC n) (x::l) = x::TAKE n l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.WF_SHORTLEX, listTheory.TL_GENLIST, boolTheory.NOT_F, listTheory.UNIQUE_LENGTH_FILTER, boolTheory.UNWIND_THM1]", "reward": 5}]], "((p :bool) \u21d4 (q :bool) \u2228 (r :bool)) \u21d4 (p \u2228 \u00acq) \u2227 (p \u2228 \u00acr) \u2227 (q \u2228 r \u2228 \u00acp)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vp @ @ C$bool$ \\/ Vq Vr @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ C$bool$ ~ Vq @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ C$bool$ ~ Vr @ @ C$bool$ \\/ Vq @ @ C$bool$ \\/ Vr @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "((p :bool) \u21d4 (q :bool) \u2228 (r :bool)) \u21d4 (p \u2228 \u00acq) \u2227 (p \u2228 \u00acr) \u2227 (q \u2228 r \u2228 \u00acp)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.RES_EXISTS_FALSE, boolTheory.literal_case_THM, boolTheory.literal_case_RATOR, boolTheory.EXISTS_DEF, boolTheory.IMP_DISJ_THM]", "reward": 5}]], "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) \u2260 {x}": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ~ @ @ C$min$ = C$pred_set$ EMPTY @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) \u2260 {x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_SUBSET, boolTheory.RIGHT_FORALL_OR_THM, pred_setTheory.NOT_INSERT_EMPTY, pred_setTheory.INTER_UNIV, boolTheory.EXISTS_SIMP]", "reward": 5}]], "DATATYPE ((pair :(\u03b1 -> \u03b2 -> \u03b1 # \u03b2) -> \u03b3) ($, :\u03b1 -> \u03b2 -> \u03b1 # \u03b2))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ DATATYPE @ Vpair C$pair$ ,"}, "plain": {"assumptions": [], "goal": "DATATYPE ((pair :(\u03b1 -> \u03b2 -> \u03b1 # \u03b2) -> \u03b3) ($, :\u03b1 -> \u03b2 -> \u03b1 # \u03b2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.DATATYPE_TAG_DEF, boolTheory.LEFT_OR_OVER_AND, pairTheory.ELIM_UNCURRY, pairTheory.PAIR_MAP, boolTheory.DE_MORGAN_THM]", "reward": 5}]], "(0 :num) \u2297 (0 :num) = (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$numpair$ npair C$num$ 0 C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "(0 :num) \u2297 (0 :num) = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[numpairTheory.invtri0_def, numpairTheory.npair_def, numpairTheory.twotri_formula, numpairTheory.tri_11, numpairTheory.tri_formula]", "reward": 5}]], "\u2200(m :num) (n :num). m < SUC n \u21d2 m \u2260 n \u21d2 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vm @ C$num$ SUC Vn @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vm Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < SUC n \u21d2 m \u2260 n \u21d2 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.SELECT_UNIQUE, boolTheory.MONO_EXISTS, boolTheory.LEFT_AND_FORALL_THM, boolTheory.NOT_AND, prim_recTheory.LESS_0]", "reward": 5}]], "\u2200(l :num list). SUM l = FOLDR $+ (0 :num) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ SUM Vl @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :num list). SUM l = FOLDR $+ (0 :num) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ SUM C$list$ NIL @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUM ([] :num list) = FOLDR $+ (0 :num) ([] :num list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM Vl @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (l :num list) = FOLDR $+ (0 :num) l"], "goal": "\u2200(h :num). SUM (h::(l :num list)) = FOLDR $+ (0 :num) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM Vl @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$arithmetic$ + C$num$ 0 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (l :num list) = FOLDR $+ (0 :num) l"], "goal": "\u2200(h :num). SUM (h::(l :num list)) = FOLDR $+ (0 :num) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.TAKE_APPEND1, arithmeticTheory.ADD_DIV_ADD_DIV, listTheory.TAKE_GENLIST, listTheory.APPEND_ASSOC, arithmeticTheory.EVEN_SUB]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_TAKE, listTheory.LIST_REL_SPLIT2, listTheory.EL_SNOC, listTheory.FILTER_ALL_DISTINCT, boolTheory.ABS_REP_THM]", "reward": 5}]], "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 \u00acA \u21d2 \u00acB \u21d2 F": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ \\/ VA VB C$bool$ F @ @ C$min$ ==> @ C$bool$ ~ VA @ @ C$min$ ==> @ C$bool$ ~ VB C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 \u00acA \u21d2 \u00acB \u21d2 F"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.RES_EXISTS_UNIQUE_DEF, boolTheory.BOTH_EXISTS_IMP_THM, boolTheory.DISJ_COMM, boolTheory.IMP_ANTISYM_AX, boolTheory.AND_IMP_INTRO]", "reward": 5}]], "\u2200(ss :\u03b1 + \u03b2). (\u2203(x :\u03b1). ss = (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). ss = (INR y :\u03b1 + \u03b2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vss @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ @ C$min$ = Vss @ C$sum$ INL Vx @ C$bool$ ? | Vy @ @ C$min$ = Vss @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(ss :\u03b1 + \u03b2). (\u2203(x :\u03b1). ss = (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). ss = (INR y :\u03b1 + \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.bool_case_ID, boolTheory.F_IMP, sumTheory.FORALL_SUM, sumTheory.INR_INL_11, boolTheory.AND_IMP_INTRO]", "reward": 5}]], "\u2200(P :\u03b3 -> \u03b4) (M :\u03b1 # \u03b2) (N :\u03b1 -> \u03b2 -> \u03b3). P (let ((x :\u03b1),(y :\u03b2)) = M in N x y) = (let ((x :\u03b1),(y :\u03b2)) = M in P (N x y))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VM @ C$bool$ ! | VN @ @ C$min$ = @ VP @ @ C$bool$ LET @ C$pair$ UNCURRY | Vx | Vy @ @ VN Vx Vy VM @ @ C$bool$ LET @ C$pair$ UNCURRY | Vx | Vy @ VP @ @ VN Vx Vy VM"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b3 -> \u03b4) (M :\u03b1 # \u03b2) (N :\u03b1 -> \u03b2 -> \u03b3). P (let ((x :\u03b1),(y :\u03b2)) = M in N x y) = (let ((x :\u03b1),(y :\u03b2)) = M in P (N x y))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RES_SELECT_DEF, boolTheory.EQ_REFL, pairTheory.UNCURRY_VAR, boolTheory.MONO_COND, boolTheory.LEFT_OR_OVER_AND]", "reward": 5}]], "\u2200(A :bool). \u00acA \u2227 A \u21d4 F": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VA @ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ~ VA VA C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u2200(A :bool). \u00acA \u2227 A \u21d4 F"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_OR, boolTheory.MONO_IMP, boolTheory.literal_case_RAND, boolTheory.EQ_TRANS, boolTheory.LEFT_FORALL_IMP_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2260 x INSERT s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$min$ = C$pred_set$ EMPTY @ @ C$pred_set$ INSERT Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2260 x INSERT s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_INSERT_EMPTY, pred_setTheory.SUBSET_transitive, boolTheory.OR_IMP_THM, pred_setTheory.transitive_PSUBSET, boolTheory.F_IMP]", "reward": 5}]], "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 (A \u21d2 F) \u21d2 \u00acB \u21d2 F": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ \\/ VA VB C$bool$ F @ @ C$min$ ==> @ @ C$min$ ==> VA C$bool$ F @ @ C$min$ ==> @ C$bool$ ~ VB C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u00ac((A :bool) \u2228 (B :bool)) \u21d2 F \u21d4 (A \u21d2 F) \u21d2 \u00acB \u21d2 F"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_COND, boolTheory.AND_IMP_INTRO, boolTheory.MONO_EXISTS, boolTheory.OR_CONG, boolTheory.ABS_SIMP]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b2 list). f x::l') ([] :\u03b2 list) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ MAP Vf Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$list$ CONS @ Vf Vx Vl' C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). MAP f l = FOLDR (\u03bb(x :\u03b1) (l' :\u03b2 list). f x::l') ([] :\u03b2 list) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, listTheory.FOLDR_CONS, listTheory.MEM_SPLIT, boolTheory.ONTO_THM, listTheory.all_distinct_nub]", "reward": 5}]], "\u2200(m :num) (n :num). SUC m = SUC n \u21d2 m = n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ C$num$ SUC Vm @ C$num$ SUC Vn @ @ C$min$ = Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). SUC m = SUC n \u21d2 m = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RES_EXISTS_CONG, boolTheory.FALSITY, boolTheory.EQ_IMP_THM, boolTheory.UNWIND_THM1, boolTheory.RIGHT_EXISTS_IMP_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool) (l :\u03b1 list). FOLDR f e (FILTER P l) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool) (l :\u03b1 list). FOLDR f e (FILTER P l) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool). FOLDR f e (FILTER P ([] :\u03b1 list)) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool). FOLDR f e (FILTER P (l :\u03b1 list)) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool). FOLDR f e (FILTER P (h::(l :\u03b1 list))) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ @ C$bool$ COND @ VP Vx @ @ Vf Vx Vy Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool). FOLDR f e (FILTER P (l :\u03b1 list)) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (P :\u03b1 -> bool). FOLDR f e (FILTER P (h::(l :\u03b1 list))) = FOLDR (\u03bb(x :\u03b1) (y :\u03b2). if P x then f x y else y) e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FILTER_EQ_CONS, listTheory.SHORTLEX_transitive, boolTheory.BOTH_EXISTS_IMP_THM, listTheory.SUM_MAP_MEM_bound, listTheory.EXISTS_DEF]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LAST_EL, boolTheory.UNWIND_THM2, listTheory.mem_exists_set, listTheory.ALL_DISTINCT_ZIP_SWAP, listTheory.APPEND_LENGTH_EQ]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 s \u2229 t = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs Vt @ @ C$min$ = @ @ C$pred_set$ INTER Vs Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 s \u2229 t = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_PSUBSET_EMPTY, pred_setTheory.SUBSET_INTER_ABSORPTION, pred_setTheory.PAIR_IN_GSPEC_1, pred_setTheory.UNION_COMM, boolTheory.LEFT_OR_OVER_AND]", "reward": 5}]], "nsnd (0 :num) = (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$numpair$ nsnd C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "nsnd (0 :num) = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[numpairTheory.invtri_lower, numpairTheory.tri_LT, numpairTheory.tri_eq_0, numpairTheory.nsnd_def, numpairTheory.nfst_npair]", "reward": 5}]], "\u2200(l :\u03b1 list). l = ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). l = h::t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$bool$ \\/ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ? | Vh @ C$bool$ ? | Vt @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vt"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l = ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). l = h::t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.list_case_eq, boolTheory.FORALL_itself, boolTheory.COND_CLAUSES, boolTheory.literal_case_CONG, boolTheory.OR_ELIM_THM]", "reward": 5}]], "(\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l) \u2227 \u2200(l :\u03b2 list). ([] :\u03b2 list) ++ l = l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ APPEND Vl C$list$ NIL Vl @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL Vl Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l) \u2227 \u2200(l :\u03b2 list). ([] :\u03b2 list) ++ l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.LUPDATE_MAP, listTheory.LAST_EL, listTheory.LEN_LENGTH_LEM, listTheory.NOT_NIL_EQ_LENGTH_NOT_0, listTheory.ALL_DISTINCT_ZIP]", "reward": 5}]], "\u2200(y :\u03b1) (x :\u03b2) (P :\u03b1 -> bool). P y \u2227 x = (f :\u03b1 -> \u03b2) y \u21d2 x \u2208 {f x | P x}": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ C$bool$ ! | Vx @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vy @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ Vf Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b1) (x :\u03b2) (P :\u03b1 -> bool). P y \u2227 x = (f :\u03b1 -> \u03b2) y \u21d2 x \u2208 {f x | P x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ VP Vy"], "goal": "@ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ VP Vx' @ @ C$min$ = @ Vf Vy @ Vf Vx'"}, "plain": {"assumptions": ["(P :\u03b1 -> bool) (y :\u03b1)"], "goal": "\u2203(x' :\u03b1). (P :\u03b1 -> bool) x' \u2227 (f :\u03b1 -> \u03b2) (y :\u03b1) = f x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.PAIR_FST_SND_EQ, pairTheory.C_UNCURRY_L, pred_setTheory.GSPECIFICATION, pairTheory.CURRY_DEF, boolTheory.CONJ_COMM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.GSPECIFICATION, pairTheory.ELIM_UNCURRY, pairTheory.PROD_ALL_THM, pairTheory.FST_PAIR_MAP, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). LENGTH (FILTER P l) \u2264 LENGTH l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP Vl @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). LENGTH (FILTER P l) \u2264 LENGTH l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP Vl @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "LENGTH (FILTER (P :\u03b1 -> bool) (l :\u03b1 list)) \u2264 LENGTH l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_f, arithmeticTheory.INV_PRE_EQ, listTheory.dropWhile_eq_nil, arithmeticTheory.LT_SUB_RCANCEL, listTheory.LENGTH_TAKE_EQ]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP C$list$ NIL @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LENGTH (FILTER (P :\u03b1 -> bool) ([] :\u03b1 list)) \u2264 LENGTH ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP Vl @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LENGTH (FILTER (P :\u03b1 -> bool) (l :\u03b1 list)) \u2264 LENGTH l"], "goal": "\u2200(h :\u03b1). LENGTH (FILTER (P :\u03b1 -> bool) (h::(l :\u03b1 list))) \u2264 LENGTH (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP Vl @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LENGTH (FILTER (P :\u03b1 -> bool) (l :\u03b1 list)) \u2264 LENGTH l"], "goal": "\u2200(h :\u03b1). LENGTH (FILTER (P :\u03b1 -> bool) (h::(l :\u03b1 list))) \u2264 LENGTH (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.MEM_APPEND, listTheory.MEM_ZIP, arithmeticTheory.MOD_TIMES2, listTheory.EL_ZIP, listTheory.PAD_RIGHT]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[arithmeticTheory.LEFT_SUB_DISTRIB, listTheory.NULL_APPEND, listTheory.SHORTLEX_LENGTH_LE, arithmeticTheory.SUB_LESS, arithmeticTheory.BOUNDED_EXISTS_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ @ C$relation$ TC VR Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.TC_DEF, relationTheory.RC_REFLEXIVE, boolTheory.BOOL_EQ_DISTINCT, boolTheory.BOTH_EXISTS_IMP_THM, boolTheory.LCOMM_THM]", "reward": 5}]], "\u2200(n :num). \u00ac(n < n)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ~ @ @ C$prim_rec$ < Vn Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). \u00ac(n < n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, boolTheory.OR_IMP_THM, boolTheory.LET_RATOR, boolTheory.FORALL_DEF, boolTheory.UEXISTS_OR_THM]", "reward": 5}]], "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 \u00acq": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ ==> Vp Vq @ C$bool$ ~ Vq"}, "plain": {"assumptions": [], "goal": "\u00ac((p :bool) \u21d2 (q :bool)) \u21d2 \u00acq"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_DEF, boolTheory.itself_Axiom, boolTheory.UNWIND_THM2, boolTheory.ONE_ONE_DEF, boolTheory.SWAP_FORALL_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (x :\u03b2). FOLDL f e [x] = f e x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ CONS Vx C$list$ NIL @ @ Vf Ve Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (x :\u03b2). FOLDL f e [x] = f e x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_APPEND, listTheory.LIST_REL_APPEND_IMP, listTheory.MAP_FRONT, listTheory.APPEND_EQ_APPEND_MID, listTheory.FOLDR]", "reward": 5}]], "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acq": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ \\/ Vp Vq @ C$bool$ ~ Vq"}, "plain": {"assumptions": [], "goal": "\u00ac((p :bool) \u2228 (q :bool)) \u21d2 \u00acq"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RES_EXISTS_DEF, boolTheory.F_DEF, boolTheory.ABS_REP_THM, boolTheory.EQ_EXPAND, boolTheory.LET_CONG]", "reward": 5}]], "(r1 :\u03b1) = (r2 :\u03b1) \u21d2 (Abbrev ((v :\u03b1) = r1) \u21d4 Abbrev (v = r2))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = Vr1 Vr2 @ @ C$min$ = @ C$marker$ Abbrev @ @ C$min$ = Vv Vr1 @ C$marker$ Abbrev @ @ C$min$ = Vv Vr2"}, "plain": {"assumptions": [], "goal": "(r1 :\u03b1) = (r2 :\u03b1) \u21d2 (Abbrev ((v :\u03b1) = r1) \u21d4 Abbrev (v = r2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[markerTheory.move_left_conj, markerTheory.Abbrev_def, markerTheory.move_left_conj, markerTheory.move_right_disj, markerTheory.Abbrev_def]", "reward": 5}]], "\u2200(ls :\u03b1 list). ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vls @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH Vls Vls @ C$list$ FRONT Vls"}, "plain": {"assumptions": [], "goal": "\u2200(ls :\u03b1 list). ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH C$list$ NIL C$list$ NIL @ C$list$ FRONT C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ([] :\u03b1 list))) ([] :\u03b1 list) = FRONT ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH Vls Vls @ C$list$ FRONT Vls"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ C$list$ FRONT @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls"], "goal": "\u2200(h :\u03b1). h::(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::ls))) (h::ls) = FRONT (h::ls)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH Vls Vls @ C$list$ FRONT Vls"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ C$list$ FRONT @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls"], "goal": "\u2200(h :\u03b1). h::(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::ls))) (h::ls) = FRONT (h::ls)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.HD, listTheory.TAKE_LENGTH_ID_rwt, listTheory.LIST_TO_SET_GENLIST, rich_listTheory.EVERY2_APPEND_suff, boolTheory.literal_case_DEF]", "reward": 0.2}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH C$list$ NIL C$list$ NIL @ C$list$ FRONT C$list$ NIL @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh C$list$ NIL @ @ C$list$ CONS Vh C$list$ NIL @ C$list$ FRONT @ @ C$list$ CONS Vh C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ([] :\u03b1 list))) ([] :\u03b1 list) = FRONT ([] :\u03b1 list)) \u21d2 [(h :\u03b1)] \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH [h])) [h] = FRONT [h]"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH Vls Vls @ C$list$ FRONT Vls @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ C$list$ FRONT @ @ C$list$ CONS Vh Vls"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh' Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vls @ @ C$list$ CONS Vh' Vls @ C$list$ FRONT @ @ C$list$ CONS Vh' Vls @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls @ C$list$ FRONT @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls"}, "plain": {"assumptions": ["((ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls) \u21d2 (h :\u03b1)::ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::ls))) (h::ls) = FRONT (h::ls)"], "goal": "\u2200(h' :\u03b1). (h'::(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h'::ls))) (h'::ls) = FRONT (h'::ls)) \u21d2 (h :\u03b1)::h'::ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::h'::ls))) (h::h'::ls) = FRONT (h::h'::ls)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH Vls Vls @ C$list$ FRONT Vls @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ C$list$ FRONT @ @ C$list$ CONS Vh Vls"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh' Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vls @ @ C$list$ CONS Vh' Vls @ C$list$ FRONT @ @ C$list$ CONS Vh' Vls @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls C$list$ NIL @ @ C$min$ = @ @ C$list$ TAKE @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls @ C$list$ FRONT @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vls"}, "plain": {"assumptions": ["((ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH ls)) ls = FRONT ls) \u21d2 (h :\u03b1)::ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::ls))) (h::ls) = FRONT (h::ls)"], "goal": "\u2200(h' :\u03b1). (h'::(ls :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h'::ls))) (h'::ls) = FRONT (h'::ls)) \u21d2 (h :\u03b1)::h'::ls \u2260 ([] :\u03b1 list) \u21d2 TAKE (PRE (LENGTH (h::h'::ls))) (h::h'::ls) = FRONT (h::h'::ls)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[boolTheory.MONO_IMP, listTheory.TAKE_def, listTheory.MAP_APPEND_MAP_EQ, listTheory.SHORTLEX_THM, listTheory.TAKE_def]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.EXISTS_LIST_EQ_MAP, listTheory.APPEND_EQ_APPEND_MID, listTheory.REVERSE_SNOC_DEF, listTheory.EVERYi_def, listTheory.FLAT]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1). {x} = {y} \u21d4 x = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$pred_set$ INSERT Vy C$pred_set$ EMPTY @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1). {x} = {y} \u21d4 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.DIFF_SAME_UNION, pred_setTheory.DELETE_DELETE, pred_setTheory.IN_SING, boolTheory.RIGHT_AND_OVER_OR, pred_setTheory.TC_PSUBSET]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1) (l :\u03b1 list). FOLDR f e (SNOC x l) = FOLDR f (f x e) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1) (l :\u03b1 list). FOLDR f e (SNOC x l) = FOLDR f (f x e) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx C$list$ NIL @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e (SNOC x ([] :\u03b1 list)) = FOLDR f (f x e) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e (SNOC x (l :\u03b1 list)) = FOLDR f (f x e) l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e (SNOC x (h::(l :\u03b1 list))) = FOLDR f (f x e) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR Vf @ @ Vf Vx Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e (SNOC x (l :\u03b1 list)) = FOLDR f (f x e) l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (x :\u03b1). FOLDR f e (SNOC x (h::(l :\u03b1 list))) = FOLDR f (f x e) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_APPEND_EQ, listTheory.FLAT_EQ_NIL, listTheory.LIST_REL_rules, listTheory.FILTER_APPEND_DISTRIB, listTheory.MAP2_MAP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_REVERSE, listTheory.GENLIST_APPEND, listTheory.LENGTH_NIL_SYM, listTheory.EL_SNOC, listTheory.MEM_SNOC]", "reward": 5}]], "\u2200(M :'a1 # 'a2) (N :'a1 -> 'a2 -> \u03b2 -> \u03b3) (b :\u03b2). (let ((x :'a1),(y :'a2)) = M in N x y) b = (let ((x :'a1),(y :'a2)) = M in N x y b)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VN @ C$bool$ ! | Vb @ @ C$min$ = @ @ @ C$bool$ LET @ C$pair$ UNCURRY | Vx | Vy @ @ VN Vx Vy VM Vb @ @ C$bool$ LET @ C$pair$ UNCURRY | Vx | Vy @ @ @ VN Vx Vy Vb VM"}, "plain": {"assumptions": [], "goal": "\u2200(M :'a1 # 'a2) (N :'a1 -> 'a2 -> \u03b2 -> \u03b3) (b :\u03b2). (let ((x :'a1),(y :'a2)) = M in N x y) b = (let ((x :'a1),(y :'a2)) = M in N x y b)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.IMP_DISJ_THM, boolTheory.SWAP_EXISTS_THM, pairTheory.ELIM_UNCURRY, boolTheory.COND_EXPAND_OR, pairTheory.UNCURRY_DEF]", "reward": 5}]], "(\u00ac(A :bool) \u21d2 F) \u21d2 (A \u21d2 F) \u21d2 F": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ~ VA C$bool$ F @ @ C$min$ ==> @ @ C$min$ ==> VA C$bool$ F C$bool$ F"}, "plain": {"assumptions": [], "goal": "(\u00ac(A :bool) \u21d2 F) \u21d2 (A \u21d2 F) \u21d2 F"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.CONJ_ASSOC, boolTheory.TRUTH, boolTheory.literal_case_id, boolTheory.BOTH_FORALL_OR_THM, boolTheory.LET_DEF]", "reward": 5}]], "\u2200(a1 :\u03b1 list) (a0 :\u03b1). ([] :\u03b1 list) \u2260 a0::a1": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va1 @ C$bool$ ! | Va0 @ C$bool$ ~ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Va0 Va1"}, "plain": {"assumptions": [], "goal": "\u2200(a1 :\u03b1 list) (a0 :\u03b1). ([] :\u03b1 list) \u2260 a0::a1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Va0 Va1 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(a0 :\u03b1)::(a1 :\u03b1 list) \u2260 ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_CONG, boolTheory.IMP_F_EQ_F, boolTheory.COND_RAND, boolTheory.ONE_ONE_THM, boolTheory.literal_case_RAND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.list_TY_DEF, listTheory.list_case_def, listTheory.list_size_def, boolTheory.itself_case_thm, boolTheory.LCOMM_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P l) = FILTER P (MAP f l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP Vl @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P l) = FILTER P (MAP f l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP C$list$ NIL @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P ([] :\u03b1 list)) = FILTER P (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP Vl @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P (l :\u03b1 list)) = FILTER P (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b1) (P :\u03b1 -> bool). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P (h::(l :\u03b1 list))) = FILTER P (MAP f (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP Vl @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ = @ VP @ Vf Vx @ VP Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER VP @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b1) (P :\u03b1 -> bool). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P (l :\u03b1 list)) = FILTER P (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b1) (P :\u03b1 -> bool). (\u2200(x :\u03b1). P (f x) \u21d4 P x) \u21d2 MAP f (FILTER P (h::(l :\u03b1 list))) = FILTER P (MAP f (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.COND_EXPAND, listTheory.LIST_APPLY_o, listTheory.REVERSE_DEF, boolTheory.RIGHT_AND_OVER_OR, listTheory.SINGL_LIST_APPLY_L]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.ITSELF_UNIQUE, listTheory.GENLIST_ID, listTheory.LIST_REL_EVERY_ZIP, listTheory.EL_ZIP, listTheory.FILTER_ALL_DISTINCT]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l1 :\u03b1 list) (l2 :\u03b1 list). FOLDR f e (l1 ++ l2) = FOLDR f (FOLDR f e l2) l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l2 :\u03b1 list). FOLDR f e (([] :\u03b1 list) \u29fa l2) = FOLDR f (FOLDR f e l2) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 Vl1"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 @ @ C$list$ CONS Vh Vl1"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l2 :\u03b1 list). FOLDR f e ((l1 :\u03b1 list) \u29fa l2) = FOLDR f (FOLDR f e l2) l1"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l2 :\u03b1 list). FOLDR f e (h::(l1 :\u03b1 list) \u29fa l2) = FOLDR f (FOLDR f e l2) (h::l1)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND Vl1 Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 Vl1"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ @ C$list$ FOLDR Vf @ @ @ C$list$ FOLDR Vf Ve Vl2 @ @ C$list$ CONS Vh Vl1"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l2 :\u03b1 list). FOLDR f e ((l1 :\u03b1 list) \u29fa l2) = FOLDR f (FOLDR f e l2) l1"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l2 :\u03b1 list). FOLDR f e (h::(l1 :\u03b1 list) \u29fa l2) = FOLDR f (FOLDR f e l2) (h::l1)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_f, boolTheory.DISJ_IMP_THM, listTheory.MAP_CONG, listTheory.EL_REVERSE, listTheory.FLAT_compute]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_LIFT2_def, listTheory.SHORTLEX_transitive, listTheory.OPT_MMAP_def, listTheory.datatype_list, listTheory.EL_MAP]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). SNOC x l = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ SNOC Vx C$list$ NIL @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). SNOC x ([] :\u03b1 list) = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). SNOC x (l :\u03b1 list) = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). SNOC x (h::(l :\u03b1 list)) = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ SNOC Vx Vl @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$list$ CONS @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). SNOC x (l :\u03b1 list) = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). SNOC x (h::(l :\u03b1 list)) = FOLDR (CONS :\u03b1 -> \u03b1 list -> \u03b1 list) [x] (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.SUM_SUM_ACC, listTheory.LIST_TO_SET_GENLIST, listTheory.MAP_MAP_o, listTheory.SHORTLEX_total, listTheory.ALL_DISTINCT_FILTER]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.COND_EXPAND_OR, listTheory.LIST_BIND_LIST_BIND, listTheory.EVERY2_REVERSE, listTheory.LIST_TO_SET_FLAT, listTheory.FOLDL_UNION_BIGUNION_paired]", "reward": 5}]], "\u2200(y :\u03b1) (l :\u03b1 list). MEM y l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b1) (l :\u03b1 list). MEM y l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b1). MEM y ([] :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(y :\u03b1). MEM y (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F l"], "goal": "\u2200(h :\u03b1) (y :\u03b1). MEM y (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx Vl' C$bool$ F @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(y :\u03b1). MEM y (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F l"], "goal": "\u2200(h :\u03b1) (y :\u03b1). MEM y (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). y = x \u2228 l') F (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDL_ZIP_SAME, listTheory.LAST_EL, listTheory.LAST_APPEND_CONS, boolTheory.UNWIND_THM1, listTheory.FILTER_EQ_ID]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EXISTS_LIST, listTheory.SNOC_APPEND, boolTheory.OR_INTRO_THM2, listTheory.LAST_REVERSE, listTheory.GENLIST_NUMERALS]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). FINITE s \u2227 BIJ f s t \u21d2 CARD s = CARD t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ C$min$ = @ C$pred_set$ CARD Vs @ C$pred_set$ CARD Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). FINITE s \u2227 BIJ f s t \u21d2 CARD s = CARD t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.PAIR_IN_GSPEC_IFF, pred_setTheory.PAIR_IN_GSPEC_IFF, pred_setTheory.IN_ABS, pred_setTheory.FINITE_BIJ]", "reward": 5}]], "INVOL $\u00ac": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ INVOL C$bool$ ~"}, "plain": {"assumptions": [], "goal": "INVOL $\u00ac"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, boolTheory.COND_RAND, boolTheory.RES_FORALL_CONG, relationTheory.INVOL, boolTheory.LET_CONG]", "reward": 5}]], "\u2200(s :\u03b1 + \u03b2) (s' :\u03b1 + \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). s = s' \u2227 (\u2200(a :\u03b1). s' = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). s' = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q s \u21d4 SUM_ALL P' Q' s')": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vs' @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vs Vs' @ @ C$bool$ /\\ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$min$ = Vs' @ C$sum$ INL Va @ @ C$min$ = @ VP Va @ VP' Va @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$min$ = Vs' @ C$sum$ INR Vb @ @ C$min$ = @ VQ Vb @ VQ' Vb @ @ C$min$ = @ @ @ C$sum$ SUM_ALL VP VQ Vs @ @ @ C$sum$ SUM_ALL VP' VQ' Vs'"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 + \u03b2) (s' :\u03b1 + \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). s = s' \u2227 (\u2200(a :\u03b1). s' = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). s' = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q s \u21d4 SUM_ALL P' Q' s')"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INL Vx' @ @ C$bool$ /\\ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx' @ C$sum$ INL Va @ @ C$min$ = @ VP Va @ VP' Va @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx' @ C$sum$ INR Vb @ @ C$min$ = @ VQ Vb @ VQ' Vb @ @ C$min$ = @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INL Vx' @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INL Vx' @ C$bool$ ! | Vy @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vy @ @ C$bool$ /\\ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Va @ @ C$min$ = @ VP Va @ VP' Va @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INR Vb @ @ C$min$ = @ VQ Vb @ VQ' Vb @ @ C$min$ = @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INR Vy @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INR Vy @ C$bool$ ! | Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Vx @ @ C$bool$ /\\ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INL Va @ @ C$min$ = @ VP Va @ VP' Va @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vb @ @ C$min$ = @ VQ Vb @ VQ' Vb @ @ C$min$ = @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INL Vx @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INL Vx @ C$bool$ ! | Vy' @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INR Vy' @ @ C$bool$ /\\ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy' @ C$sum$ INL Va @ @ C$min$ = @ VP Va @ VP' Va @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy' @ C$sum$ INR Vb @ @ C$min$ = @ VQ Vb @ VQ' Vb @ @ C$min$ = @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INR Vy' @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INR Vy'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (\u2200(x' :\u03b1) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). (INL x :\u03b1 + \u03b2) = (INL x' :\u03b1 + \u03b2) \u2227 (\u2200(a :\u03b1). (INL x' :\u03b1 + \u03b2) = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). (INL x' :\u03b1 + \u03b2) = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q (INL x' :\u03b1 + \u03b2) \u21d4 SUM_ALL P' Q' (INL x' :\u03b1 + \u03b2))) \u2227 \u2200(y :\u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). (INL x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u2227 (\u2200(a :\u03b1). (INR y :\u03b1 + \u03b2) = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). (INR y :\u03b1 + \u03b2) = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q (INR y :\u03b1 + \u03b2) \u21d4 SUM_ALL P' Q' (INR y :\u03b1 + \u03b2))) \u2227 \u2200(y :\u03b2). (\u2200(x :\u03b1) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). (INR y :\u03b1 + \u03b2) = (INL x :\u03b1 + \u03b2) \u2227 (\u2200(a :\u03b1). (INL x :\u03b1 + \u03b2) = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). (INL x :\u03b1 + \u03b2) = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q (INL x :\u03b1 + \u03b2) \u21d4 SUM_ALL P' Q' (INL x :\u03b1 + \u03b2))) \u2227 \u2200(y' :\u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). (INR y :\u03b1 + \u03b2) = (INR y' :\u03b1 + \u03b2) \u2227 (\u2200(a :\u03b1). (INR y' :\u03b1 + \u03b2) = (INL a :\u03b1 + \u03b2) \u21d2 (P a \u21d4 P' a)) \u2227 (\u2200(b :\u03b2). (INR y' :\u03b1 + \u03b2) = (INR b :\u03b1 + \u03b2) \u21d2 (Q b \u21d4 Q' b)) \u21d2 (SUM_ALL P Q (INR y' :\u03b1 + \u03b2) \u21d4 SUM_ALL P' Q' (INR y' :\u03b1 + \u03b2))"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.TYPE_DEFINITION_THM, sumTheory.FORALL_SUM, boolTheory.AND_CLAUSES, boolTheory.LET_CONG, boolTheory.BOTH_FORALL_OR_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[sumTheory.INR_INL_11, boolTheory.COND_RAND, sumTheory.SUM_ALL_def, sumTheory.SUM_ALL_def, sumTheory.SUM_ALL_def]", "reward": 5}]], "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d4 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ @ C$min$ = @ C$bool$ ? | Vn @ Vp Vn @ @ C$bool$ /\\ @ Vp @ C$while$ LEAST Vp @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$while$ LEAST Vp @ C$bool$ ~ @ Vp Vn"}, "plain": {"assumptions": [], "goal": "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d4 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ @ C$bool$ /\\ @ @ C$min$ ==> @ C$bool$ ? | Vn @ Vp Vn @ @ C$bool$ /\\ @ Vp @ C$while$ LEAST Vp @ C$bool$ ! | Vn @ @ C$min$ ==> @ C$bool$ ? | VP @ @ C$bool$ /\\ @ C$bool$ ! | Vn @ @ C$min$ ==> @ VP @ C$num$ SUC Vn @ VP Vn @ @ C$bool$ /\\ @ VP Vn @ C$bool$ ~ @ VP @ C$while$ LEAST Vp @ C$bool$ ~ @ Vp Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vp @ C$while$ LEAST Vp @ C$bool$ ! | Vn @ @ C$min$ ==> @ C$bool$ ? | VP @ @ C$bool$ /\\ @ C$bool$ ! | Vn @ @ C$min$ ==> @ VP @ C$num$ SUC Vn @ VP Vn @ @ C$bool$ /\\ @ VP Vn @ C$bool$ ~ @ VP @ C$while$ LEAST Vp @ C$bool$ ~ @ Vp Vn @ C$bool$ ? | Vn @ Vp Vn"}, "plain": {"assumptions": [], "goal": "\u2200(p :num -> bool). ((\u2203(n :num). p n) \u21d2 p ($LEAST p) \u2227 \u2200(n :num). (\u2203(P :num -> bool). (\u2200(n :num). P (SUC n) \u21d2 P n) \u2227 P n \u2227 \u00acP ($LEAST p)) \u21d2 \u00acp n) \u2227 (p ($LEAST p) \u2227 (\u2200(n :num). (\u2203(P :num -> bool). (\u2200(n :num). P (SUC n) \u21d2 P n) \u2227 P n \u2227 \u00acP ($LEAST p)) \u21d2 \u00acp n) \u21d2 \u2203(n :num). p n)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.MONO_IMP, prim_recTheory.LESS_DEF, boolTheory.literal_case_THM, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.EQ_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[prim_recTheory.LESS_DEF, prim_recTheory.LESS_DEF, prim_recTheory.LESS_DEF, arithmeticTheory.LESS_MONO_EQ, whileTheory.LEAST_ELIM]", "reward": 5}]], "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1) (l :\u03b2 list). FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 \u2218 f2) l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 Vl @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1) (l :\u03b2 list). FILTER f1 (MAP f2 l) = MAP f2 (FILTER (f1 \u2218 f2) l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 C$list$ NIL @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1). FILTER f1 (MAP f2 ([] :\u03b2 list)) = MAP f2 (FILTER (f1 \u2218 f2) ([] :\u03b2 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 Vl @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 @ @ C$list$ CONS Vh Vl @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1). FILTER f1 (MAP f2 (l :\u03b2 list)) = MAP f2 (FILTER (f1 \u2218 f2) l)"], "goal": "\u2200(h :\u03b2) (f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1). FILTER f1 (MAP f2 (h::(l :\u03b2 list))) = MAP f2 (FILTER (f1 \u2218 f2) (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 Vl @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ MAP Vf2 @ @ C$list$ CONS Vh Vl @ @ C$list$ MAP Vf2 @ @ C$list$ FILTER @ @ C$combin$ o Vf1 Vf2 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1). FILTER f1 (MAP f2 (l :\u03b2 list)) = MAP f2 (FILTER (f1 \u2218 f2) l)"], "goal": "\u2200(h :\u03b2) (f1 :\u03b1 -> bool) (f2 :\u03b2 -> \u03b1). FILTER f1 (MAP f2 (h::(l :\u03b2 list))) = MAP f2 (FILTER (f1 \u2218 f2) (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LLEX_total, listTheory.APPEND_SNOC, listTheory.MEM_FLAT, boolTheory.JRH_INDUCT_UTIL, boolTheory.BOTH_FORALL_OR_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EXISTS_LIST_EQ_MAP, listTheory.LIST_EQ, boolTheory.EQ_EXT, boolTheory.MONO_COND, listTheory.LENGTH_NIL_SYM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s = \ud835\udd4c(:\u03b1) \u21d2 \u2200(v :\u03b1). v \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$min$ = Vs C$pred_set$ UNIV @ C$bool$ ! | Vv @ @ C$bool$ IN Vv Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s = \ud835\udd4c(:\u03b1) \u21d2 \u2200(v :\u03b1). v \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM2, pred_setTheory.EQ_UNIV, boolTheory.LET_RATOR, boolTheory.RES_ABSTRACT_DEF, boolTheory.MONO_AND]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b2). (INR y :\u03b1 + \u03b2) \u2260 (INL x :\u03b1 + \u03b2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ~ @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b2). (INR y :\u03b1 + \u03b2) \u2260 (INL x :\u03b1 + \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LET_DEF, sumTheory.INR_neq_INL, boolTheory.RES_EXISTS_DEF, boolTheory.RIGHT_OR_OVER_AND, sumTheory.INR_neq_INL]", "reward": 5}]], "\u2200(n :num). DROP n ([] :\u03b1 list) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ DROP Vn C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). DROP n ([] :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.DROP_def, listTheory.MAP2_APPEND, listTheory.TAKE_def, listTheory.FILTER_NEQ_NIL, listTheory.APPEND_EQ_SING]", "reward": 5}]], "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EVERY P (l :\u03b1 list) \u21d2 EVERY Q l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VQ Vx @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VQ Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (Q :\u03b1 -> bool) x) \u21d2 EVERY P (l :\u03b1 list) \u21d2 EVERY Q l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_DEF, listTheory.EVERY_MEM, listTheory.list_case_compute, listTheory.LIST_TO_SET, boolTheory.LEFT_EXISTS_IMP_THM]", "reward": 5}]], "FILTER (P :\u03b1 -> bool) ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 (\u2200(h :\u03b1). P h \u21d2 FILTER P (h::(l :\u03b1 list)) = h::FILTER P l) \u2227 \u2200(h :\u03b1). \u00acP h \u21d2 FILTER P (h::l) = FILTER P l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ FILTER VP C$list$ NIL C$list$ NIL @ @ C$bool$ /\\ @ C$bool$ ! | Vh @ @ C$min$ ==> @ VP Vh @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh @ @ C$list$ FILTER VP Vl @ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ VP Vh @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER VP Vl"}, "plain": {"assumptions": [], "goal": "FILTER (P :\u03b1 -> bool) ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 (\u2200(h :\u03b1). P h \u21d2 FILTER P (h::(l :\u03b1 list)) = h::FILTER P l) \u2227 \u2200(h :\u03b1). \u00acP h \u21d2 FILTER P (h::l) = FILTER P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.NULL_DEF, boolTheory.OR_IMP_THM, boolTheory.LEFT_EXISTS_AND_THM, listTheory.FILTER, boolTheory.RIGHT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ NULL C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T C$list$ NIL"}, "plain": {"assumptions": [], "goal": "NULL ([] :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["NULL (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T l"], "goal": "\u2200(h :\u03b1). NULL (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["NULL (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T l"], "goal": "\u2200(h :\u03b1). NULL (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). F) T (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.MEM_LUPDATE, listTheory.LIST_TO_SET_MAP, listTheory.MEM_FILTER, listTheory.LIST_REL_EVERY_ZIP, listTheory.nub_append]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EL_SNOC, listTheory.MEM_FILTER, listTheory.EQ_LIST, listTheory.FILTER_EQ_ID, listTheory.EL_DROP]", "reward": 5}]], "\u2200(x :\u03b1). {x} \u2260 (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ~ @ @ C$min$ = @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). {x} \u2260 (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.itself_TY_DEF, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.NOT_INSERT_EMPTY, boolTheory.COND_RAND, boolTheory.AND1_THM]", "reward": 5}]], "\u2200(x :\u03b1 list). x \u227c x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$list$ isPREFIX Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list). x \u227c x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$list$ isPREFIX C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u227c ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$list$ isPREFIX Vx Vx"], "goal": "@ C$bool$ ! | Vh @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vh Vx"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c x"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c h::x"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ isPREFIX Vx Vx"], "goal": "@ C$bool$ ! | Vh @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vh Vx"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c x"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c h::x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.LET_DEF, boolTheory.SELECT_ELIM_THM, listTheory.EL_REVERSE, boolTheory.AND_INTRO_THM, listTheory.adjacent_cases]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.UNWIND_FORALL_THM2, listTheory.LIST_REL_EVERY_ZIP, listTheory.LIST_NOT_EQ, boolTheory.MONO_COND, listTheory.FLAT_APPEND]", "reward": 5}]], "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2227 p \u21d4 p \u2227 stmarker m) \u2227 (p \u2227 q \u2227 stmarker m \u21d4 (p \u2227 q) \u2227 stmarker m) \u2227 ((p \u2227 stmarker m) \u2227 q \u21d4 (p \u2227 q) \u2227 stmarker m)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ C$bool$ ! | Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ /\\ @ C$marker$ stmarker Vm Vp @ @ C$bool$ /\\ Vp @ C$marker$ stmarker Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ /\\ Vp @ @ C$bool$ /\\ Vq @ C$marker$ stmarker Vm @ @ C$bool$ /\\ @ @ C$bool$ /\\ Vp Vq @ C$marker$ stmarker Vm @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ Vp @ C$marker$ stmarker Vm Vq @ @ C$bool$ /\\ @ @ C$bool$ /\\ Vp Vq @ C$marker$ stmarker Vm"}, "plain": {"assumptions": [], "goal": "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2227 p \u21d4 p \u2227 stmarker m) \u2227 (p \u2227 q \u2227 stmarker m \u21d4 (p \u2227 q) \u2227 stmarker m) \u2227 ((p \u2227 stmarker m) \u2227 q \u21d4 (p \u2227 q) \u2227 stmarker m)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.LET_CONG, boolTheory.FORALL_BOOL, boolTheory.SKOLEM_THM, boolTheory.MONO_OR, boolTheory.FORALL_THM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P (REVERSE l) \u21d4 EVERY P l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP @ C$list$ REVERSE Vl @ @ C$list$ EVERY VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P (REVERSE l) \u21d4 EVERY P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.EVERY_MEM, listTheory.INJ_MAP_EQ, listTheory.EVERY_SIMP, listTheory.FRONT_SNOC, listTheory.FILTER_F]", "reward": 5}]], "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 EL (PRE (LENGTH l)) l = LAST l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ EL @ C$prim_rec$ PRE @ C$list$ LENGTH Vl Vl @ C$list$ LAST Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 EL (PRE (LENGTH l)) l = LAST l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.PAD_RIGHT, listTheory.LAST_EL, listTheory.MEM_DROP, listTheory.dropWhile_APPEND_EVERY, listTheory.CONS_ACYCLIC]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2203(y :\u03b1). y \u2208 IMAGE f s \u2227 P y) \u21d4 \u2203(x :\u03b2). x \u2208 s \u2227 P (f x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ VP Vy @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ VP @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2203(y :\u03b1). y \u2208 IMAGE f s \u2227 P y) \u21d4 \u2203(x :\u03b2). x \u2208 s \u2227 P (f x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SING_INSERT, pred_setTheory.IMAGE_COMPOSE, pred_setTheory.IN_IMAGE, boolTheory.RES_FORALL_CONG, pred_setTheory.SET_MINIMUM]", "reward": 5}]], "(\u2200(l :\u03b1 list). ([] :\u03b1 list) \u227c l \u21d4 T) \u2227 (\u2200(x :\u03b1) (l :\u03b1 list). x::l \u227c ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). x2::l2 \u227c x1::l1 \u21d4 x1 = x2 \u2227 l2 \u227c l1": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ isPREFIX C$list$ NIL Vl C$bool$ T @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vx Vl C$list$ NIL C$bool$ F @ C$bool$ ! | Vx1 @ C$bool$ ! | Vl1 @ C$bool$ ! | Vx2 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vx2 Vl2 @ @ C$list$ CONS Vx1 Vl1 @ @ C$bool$ /\\ @ @ C$min$ = Vx1 Vx2 @ @ C$list$ isPREFIX Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). ([] :\u03b1 list) \u227c l \u21d4 T) \u2227 (\u2200(x :\u03b1) (l :\u03b1 list). x::l \u227c ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b1) (l2 :\u03b1 list). x2::l2 \u227c x1::l1 \u21d4 x1 = x2 \u2227 l2 \u227c l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, boolTheory.CONJ_ASSOC, listTheory.NULL_GENLIST, listTheory.LIST_REL_MAP1, listTheory.DROP_GENLIST]", "reward": 5}]], "\u2200(f :\u03b1 -> bool) (l :\u03b1 list). FILTER f (FILTER f l) = FILTER f l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf Vl @ @ C$list$ FILTER Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> bool) (l :\u03b1 list). FILTER f (FILTER f l) = FILTER f l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf C$list$ NIL @ @ C$list$ FILTER Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> bool). FILTER f (FILTER f ([] :\u03b1 list)) = FILTER f ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf Vl @ @ C$list$ FILTER Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> bool). FILTER f (FILTER f (l :\u03b1 list)) = FILTER f l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> bool). FILTER f (FILTER f (h::(l :\u03b1 list))) = FILTER f (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf Vl @ @ C$list$ FILTER Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ FILTER Vf @ @ C$list$ FILTER Vf @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> bool). FILTER f (FILTER f (l :\u03b1 list)) = FILTER f l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> bool). FILTER f (FILTER f (h::(l :\u03b1 list))) = FILTER f (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDR_CONG, listTheory.MAP_ID, listTheory.INDEX_OF_def, listTheory.oEL_EQ_EL, listTheory.LIST_REL_LENGTH]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.splitAtPki_MAP, boolTheory.LEFT_AND_OVER_OR, listTheory.GENLIST_NUMERALS, listTheory.MAP_GENLIST, listTheory.FORALL_LIST]", "reward": 5}]], "((p :bool) \u21d4 (q :bool) \u21d2 (r :bool)) \u21d4 (p \u2228 q) \u2227 (p \u2228 \u00acr) \u2227 (\u00acq \u2228 r \u2228 \u00acp)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vp @ @ C$min$ ==> Vq Vr @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp Vq @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ C$bool$ ~ Vr @ @ C$bool$ \\/ @ C$bool$ ~ Vq @ @ C$bool$ \\/ Vr @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "((p :bool) \u21d4 (q :bool) \u21d2 (r :bool)) \u21d4 (p \u2228 q) \u2227 (p \u2228 \u00acr) \u2227 (\u00acq \u2228 r \u2228 \u00acp)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.SELECT_REFL_2, boolTheory.CONJ_COMM, boolTheory.EQ_SYM, boolTheory.EXISTS_itself, boolTheory.COND_EXPAND]", "reward": 5}]], "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d2 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ @ C$min$ ==> @ C$bool$ ? | Vn @ Vp Vn @ @ C$bool$ /\\ @ Vp @ C$while$ LEAST Vp @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$while$ LEAST Vp @ C$bool$ ~ @ Vp Vn"}, "plain": {"assumptions": [], "goal": "\u2200(p :num -> bool). (\u2203(n :num). p n) \u21d2 p ($LEAST p) \u2227 \u2200(n :num). n < $LEAST p \u21d2 \u00acp n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, whileTheory.LESS_LEAST, boolTheory.MONO_IMP, whileTheory.LEAST_ELIM, prim_recTheory.SIMP_REC_THM]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). TL (SNOC x l) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx Vl @ @ @ C$bool$ COND @ C$list$ NULL Vl C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). TL (SNOC x l) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx C$list$ NIL @ @ @ C$bool$ COND @ C$list$ NULL C$list$ NIL C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). TL (SNOC x ([] :\u03b1 list)) = if NULL ([] :\u03b1 list) then ([] :\u03b1 list) else SNOC x (TL ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx Vl @ @ @ C$bool$ COND @ C$list$ NULL Vl C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$bool$ COND @ C$list$ NULL @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). TL (SNOC x (l :\u03b1 list)) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)"], "goal": "\u2200(h :\u03b1) (x :\u03b1). TL (SNOC x (h::(l :\u03b1 list))) = if NULL (h::l) then ([] :\u03b1 list) else SNOC x (TL (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx Vl @ @ @ C$bool$ COND @ C$list$ NULL Vl C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ TL @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ @ C$bool$ COND @ C$list$ NULL @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ SNOC Vx @ C$list$ TL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). TL (SNOC x (l :\u03b1 list)) = if NULL l then ([] :\u03b1 list) else SNOC x (TL l)"], "goal": "\u2200(h :\u03b1) (x :\u03b1). TL (SNOC x (h::(l :\u03b1 list))) = if NULL (h::l) then ([] :\u03b1 list) else SNOC x (TL (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.all_distinct_nub, listTheory.LENGTH_TL, listTheory.SWAP_REVERSE_SYM, listTheory.list_to_set_diff, listTheory.GENLIST_AUX]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LUPDATE_SNOC, listTheory.EXISTS_SNOC, listTheory.MEM_SPLIT, listTheory.MEM_MAP, listTheory.LIST_IGNORE_BIND_def]", "reward": 5}]], "\u2200(P :\u03b1 list -> bool). (\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d2 P l) \u21d4 P ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Vl C$num$ 0 @ VP Vl @ VP C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 list -> bool). (\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d2 P l) \u21d4 P ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, listTheory.LENGTH_EQ_NUM, boolTheory.UNWIND_FORALL_THM1, listTheory.APPEND, numTheory.num_TY_DEF]", "reward": 5}]], "WF (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ WF C$relation$ EMPTY_REL"}, "plain": {"assumptions": [], "goal": "WF (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.irreflexive_def, relationTheory.EQC_IDEM, relationTheory.RTC_CASES_RTC_TWICE, relationTheory.EMPTY_REL_DEF, relationTheory.WF_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2228 countable t \u21d2 countable (s \u2229 t)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ \\/ @ C$pred_set$ countable Vs @ C$pred_set$ countable Vt @ C$pred_set$ countable @ @ C$pred_set$ INTER Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2228 countable t \u21d2 countable (s \u2229 t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ! | Vf @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vn @ C$bool$ ~ @ @ C$min$ = @ Vf Vn Vx @ C$bool$ ! | Vf @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vn @ C$bool$ ~ @ @ C$min$ = @ Vf Vn Vx @ C$bool$ ? | Vf @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vn @ @ C$min$ = @ Vf Vn Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(f :num -> \u03b1). \u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 \u2200(n :num). f n \u2260 x) \u2227 (\u2200(f :num -> \u03b1). \u2203(x :\u03b1). x \u2208 (t :\u03b1 -> bool) \u2227 \u2200(n :num). f n \u2260 x) \u2228 \u2203(f :num -> \u03b1). \u2200(x :\u03b1). (x \u2209 s \u2228 x \u2209 t) \u2228 \u2203(n :num). f n = x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.COUNTABLE_ALT, pred_setTheory.PSUBSET_DEF, pred_setTheory.DIFF_SUBSET, boolTheory.IMP_DISJ_THM, pred_setTheory.SUM_SET_IN_LE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_EXISTS_AND_THM, pred_setTheory.CARD_DIFF, pred_setTheory.FINITE_partition, pred_setTheory.INJ_DEF, pred_setTheory.FINITE_UNION]", "reward": 5}]], "CURRY (f :\u03b1 # \u03b2 -> \u03b3) = CURRY (g :\u03b1 # \u03b2 -> \u03b3) \u21d4 f = g": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$pair$ CURRY Vf @ C$pair$ CURRY Vg @ @ C$min$ = Vf Vg"}, "plain": {"assumptions": [], "goal": "CURRY (f :\u03b1 # \u03b2 -> \u03b3) = CURRY (g :\u03b1 # \u03b2 -> \u03b3) \u21d4 f = g"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pairTheory.UNCURRY_DEF, pairTheory.prod_TY_DEF, pairTheory.PAIR_EQ, pairTheory.UNCURRY_CURRY_THM, pairTheory.FST]", "reward": 5}]], "\u2200(c :\u03b1 list) (a :\u03b1 list). a \u227c a ++ c": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ C$bool$ ! | Va @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Va Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :\u03b1 list) (a :\u03b1 list). a \u227c a ++ c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ APPEND C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :\u03b1 list). ([] :\u03b1 list) \u227c ([] :\u03b1 list) \u29fa c"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vc @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Va Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vc"}, "plain": {"assumptions": ["\u2200(c :\u03b1 list). (a :\u03b1 list) \u227c a \u29fa c"], "goal": "\u2200(h :\u03b1) (c :\u03b1 list). h::(a :\u03b1 list) \u227c h::a \u29fa c"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vc @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Va Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vc"}, "plain": {"assumptions": ["\u2200(c :\u03b1 list). (a :\u03b1 list) \u227c a \u29fa c"], "goal": "\u2200(h :\u03b1) (c :\u03b1 list). h::(a :\u03b1 list) \u227c h::a \u29fa c"}}], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.literal_case_RATOR, listTheory.FILTER_T, listTheory.LIST_REL_def, listTheory.splitAtPki_APPEND, listTheory.PAD_LEFT]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EL_ALL_DISTINCT_EL_EQ, boolTheory.SWAP_FORALL_THM, listTheory.lupdate_append2, listTheory.FLAT_APPEND, boolTheory.OR_INTRO_THM2]", "reward": 5}]], "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2228 p \u21d4 p \u2228 stmarker m) \u2227 (p \u2228 q \u2228 stmarker m \u21d4 (p \u2228 q) \u2228 stmarker m) \u2227 ((p \u2228 stmarker m) \u2228 q \u21d4 (p \u2228 q) \u2228 stmarker m)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ C$bool$ ! | Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ \\/ @ C$marker$ stmarker Vm Vp @ @ C$bool$ \\/ Vp @ C$marker$ stmarker Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ Vq @ C$marker$ stmarker Vm @ @ C$bool$ \\/ @ @ C$bool$ \\/ Vp Vq @ C$marker$ stmarker Vm @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ \\/ Vp @ C$marker$ stmarker Vm Vq @ @ C$bool$ \\/ @ @ C$bool$ \\/ Vp Vq @ C$marker$ stmarker Vm"}, "plain": {"assumptions": [], "goal": "\u2200(p :bool) (q :bool) (m :bool). (stmarker m \u2228 p \u21d4 p \u2228 stmarker m) \u2227 (p \u2228 q \u2228 stmarker m \u21d4 (p \u2228 q) \u2228 stmarker m) \u2227 ((p \u2228 stmarker m) \u2228 q \u21d4 (p \u2228 q) \u2228 stmarker m)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOUNDED_DEF, boolTheory.MONO_OR, markerTheory.move_left_disj, boolTheory.SELECT_THM, boolTheory.IMP_F_EQ_F]", "reward": 5}]], "\u2200(x :\u03b1) (f :\u03b1 -> \u03b1) (g1 :num -> \u03b1) (g2 :num -> \u03b1) (m1 :num) (m2 :num). SIMP_REC_REL g1 x f m1 \u2227 SIMP_REC_REL g2 x f m2 \u21d2 \u2200(n :num). n < m1 \u2227 n < m2 \u21d2 g1 n = g2 n": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vf @ C$bool$ ! | Vg1 @ C$bool$ ! | Vg2 @ C$bool$ ! | Vm1 @ C$bool$ ! | Vm2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ @ C$prim_rec$ SIMP_REC_REL Vg1 Vx Vf Vm1 @ @ @ @ C$prim_rec$ SIMP_REC_REL Vg2 Vx Vf Vm2 @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn Vm1 @ @ C$prim_rec$ < Vn Vm2 @ @ C$min$ = @ Vg1 Vn @ Vg2 Vn"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (f :\u03b1 -> \u03b1) (g1 :num -> \u03b1) (g2 :num -> \u03b1) (m1 :num) (m2 :num). SIMP_REC_REL g1 x f m1 \u2227 SIMP_REC_REL g2 x f m2 \u21d2 \u2200(n :num). n < m1 \u2227 n < m2 \u21d2 g1 n = g2 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn Vm2", "@ @ C$prim_rec$ < Vn Vm1", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm2 @ @ C$min$ = @ Vg2 @ C$num$ SUC Vm @ Vf @ Vg2 Vm", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm1 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vm @ Vf @ Vg1 Vm", "@ @ C$min$ = @ Vg1 C$num$ 0 @ Vg2 C$num$ 0"], "goal": "@ @ C$min$ = @ Vg1 Vn @ Vg2 Vn"}, "plain": {"assumptions": ["(n :num) < (m2 :num)", "(n :num) < (m1 :num)", "\u2200(m :num). m < (m2 :num) \u21d2 (g2 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g2 m)", "\u2200(m :num). m < (m1 :num) \u21d2 (g1 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g1 m)", "(g1 :num -> \u03b1) (0 :num) = (g2 :num -> \u03b1) (0 :num)"], "goal": "(g1 :num -> \u03b1) (n :num) = (g2 :num -> \u03b1) n"}}], "parent": 0, "goal": 0, "by_tactic": "rw[prim_recTheory.SIMP_REC_REL, boolTheory.NOT_DEF, boolTheory.literal_case_THM, boolTheory.NOT_DEF, boolTheory.IMP_ANTISYM_AX]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm2 @ @ C$min$ = @ Vg2 @ C$num$ SUC Vm @ Vf @ Vg2 Vm", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm1 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vm @ Vf @ Vg1 Vm", "@ @ C$min$ = @ Vg1 C$num$ 0 @ Vg2 C$num$ 0"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vm1 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vm2 @ @ C$min$ = @ Vg1 C$num$ 0 @ Vg2 C$num$ 0"}, "plain": {"assumptions": ["\u2200(m :num). m < (m2 :num) \u21d2 (g2 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g2 m)", "\u2200(m :num). m < (m1 :num) \u21d2 (g1 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g1 m)", "(g1 :num -> \u03b1) (0 :num) = (g2 :num -> \u03b1) (0 :num)"], "goal": "(0 :num) < (m1 :num) \u21d2 (0 :num) < (m2 :num) \u21d2 (g1 :num -> \u03b1) (0 :num) = (g2 :num -> \u03b1) (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm1 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm2 @ @ C$min$ = @ Vg1 Vn @ Vg2 Vn", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm2 @ @ C$min$ = @ Vg2 @ C$num$ SUC Vm @ Vf @ Vg2 Vm", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm1 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vm @ Vf @ Vg1 Vm", "@ @ C$min$ = @ Vg1 C$num$ 0 @ Vg2 C$num$ 0"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn Vm1 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn Vm2 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vn @ Vg2 @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(n :num) < (m1 :num) \u21d2 n < (m2 :num) \u21d2 (g1 :num -> \u03b1) n = (g2 :num -> \u03b1) n", "\u2200(m :num). m < (m2 :num) \u21d2 (g2 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g2 m)", "\u2200(m :num). m < (m1 :num) \u21d2 (g1 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g1 m)", "(g1 :num -> \u03b1) (0 :num) = (g2 :num -> \u03b1) (0 :num)"], "goal": "SUC (n :num) < (m1 :num) \u21d2 SUC n < (m2 :num) \u21d2 (g1 :num -> \u03b1) (SUC n) = (g2 :num -> \u03b1) (SUC n)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm1 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm2 @ @ C$min$ = @ Vg1 Vn @ Vg2 Vn", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm2 @ @ C$min$ = @ Vg2 @ C$num$ SUC Vm @ Vf @ Vg2 Vm", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vm1 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vm @ Vf @ Vg1 Vm", "@ @ C$min$ = @ Vg1 C$num$ 0 @ Vg2 C$num$ 0"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn Vm1 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn Vm2 @ @ C$min$ = @ Vg1 @ C$num$ SUC Vn @ Vg2 @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(n :num) < (m1 :num) \u21d2 n < (m2 :num) \u21d2 (g1 :num -> \u03b1) n = (g2 :num -> \u03b1) n", "\u2200(m :num). m < (m2 :num) \u21d2 (g2 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g2 m)", "\u2200(m :num). m < (m1 :num) \u21d2 (g1 :num -> \u03b1) (SUC m) = (f :\u03b1 -> \u03b1) (g1 m)", "(g1 :num -> \u03b1) (0 :num) = (g2 :num -> \u03b1) (0 :num)"], "goal": "SUC (n :num) < (m1 :num) \u21d2 SUC n < (m2 :num) \u21d2 (g1 :num -> \u03b1) (SUC n) = (g2 :num -> \u03b1) (SUC n)"}}], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_IMP, prim_recTheory.LESS_DEF, boolTheory.JRH_INDUCT_UTIL, arithmeticTheory.LESS_MONO_REV, boolTheory.RIGHT_EXISTS_AND_THM]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[prim_recTheory.LESS_DEF, prim_recTheory.LESS_LEMMA2, boolTheory.OR_ELIM_THM, prim_recTheory.LESS_DEF, boolTheory.EQ_SYM]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (f :\u03b1 -> \u03b2) (f' :\u03b1 -> \u03b2). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 f x = f' x) \u21d2 MAP f l1 = MAP f' l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl1 Vl2 @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ MAP Vf Vl1 @ @ C$list$ MAP Vf' Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (f :\u03b1 -> \u03b2) (f' :\u03b1 -> \u03b2). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 f x = f' x) \u21d2 MAP f l1 = MAP f' l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_f, boolTheory.LEFT_AND_CONG, listTheory.list_distinct, boolTheory.BOUNDED_THM, boolTheory.MONO_EXISTS]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). INJ (\u03bb(x :\u03b1). x) s s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ @ C$pred_set$ INJ | Vx Vx Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). INJ (\u03bb(x :\u03b1). x) s s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_DEF, pred_setTheory.EXTENSION, pred_setTheory.IN_APP, pred_setTheory.EMPTY_UNION, boolTheory.OR_IMP_THM]", "reward": 5}]], "\u2200(p :bool) (q :bool) (m :bool). (p \u2228 stmarker m \u21d4 stmarker m \u2228 p) \u2227 ((stmarker m \u2228 p) \u2228 q \u21d4 stmarker m \u2228 p \u2228 q) \u2227 (p \u2228 stmarker m \u2228 q \u21d4 stmarker m \u2228 p \u2228 q)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ C$bool$ ! | Vm @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ \\/ Vp @ C$marker$ stmarker Vm @ @ C$bool$ \\/ @ C$marker$ stmarker Vm Vp @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$marker$ stmarker Vm Vp Vq @ @ C$bool$ \\/ @ C$marker$ stmarker Vm @ @ C$bool$ \\/ Vp Vq @ @ C$min$ = @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ @ C$marker$ stmarker Vm Vq @ @ C$bool$ \\/ @ C$marker$ stmarker Vm @ @ C$bool$ \\/ Vp Vq"}, "plain": {"assumptions": [], "goal": "\u2200(p :bool) (q :bool) (m :bool). (p \u2228 stmarker m \u21d4 stmarker m \u2228 p) \u2227 ((stmarker m \u2228 p) \u2228 q \u21d4 stmarker m \u2228 p \u2228 q) \u2227 (p \u2228 stmarker m \u2228 q \u21d4 stmarker m \u2228 p \u2228 q)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.IMP_ANTISYM_AX, boolTheory.LEFT_EXISTS_AND_THM, boolTheory.itself_TY_DEF, boolTheory.ITSELF_UNIQUE, boolTheory.RIGHT_AND_FORALL_THM]", "reward": 5}]], "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 (\u03bb(x :\u03b1). P x) \u21d4 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | VP @ @ C$min$ = @ @ C$bool$ IN Vx | Vx @ VP Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 (\u03bb(x :\u03b1). P x) \u21d4 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.SELECT_ELIM_THM, boolTheory.IN_DEF, boolTheory.TYPE_DEFINITION, boolTheory.SELECT_ELIM_THM, boolTheory.SELECT_REFL]", "reward": 5}]], "{(x,y) | (P :\u03b1 -> \u03b2 -> bool) x y} = UNCURRY P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC @ C$pair$ UNCURRY | Vx | Vy @ @ C$pair$ , @ @ C$pair$ , Vx Vy @ @ VP Vx Vy @ C$pair$ UNCURRY VP"}, "plain": {"assumptions": [], "goal": "{(x,y) | (P :\u03b1 -> \u03b2 -> bool) x y} = UNCURRY P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.RPROD_DEF, pairTheory.ELIM_UNCURRY, pairTheory.FST_PAIR_MAP, pred_setTheory.GSPEC_ETA, pairTheory.FORALL_PROD]", "reward": 5}]], "MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (x :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ MAP2 Vf Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (x :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ MAP2 Vf C$list$ NIL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) ([] :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ @ C$list$ MAP2 Vf Vx C$list$ NIL C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ @ C$list$ MAP2 Vf @ @ C$list$ CONS Vh Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": ["MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (x :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b2). MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (h::(x :\u03b2 list)) ([] :\u03b3 list) = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ @ C$list$ MAP2 Vf Vx C$list$ NIL C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ @ C$list$ MAP2 Vf @ @ C$list$ CONS Vh Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": ["MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (x :\u03b2 list) ([] :\u03b3 list) = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b2). MAP2 (f :\u03b2 -> \u03b3 -> \u03b1) (h::(x :\u03b2 list)) ([] :\u03b3 list) = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.datatype_list, listTheory.MAP, listTheory.EL, listTheory.MAP, listTheory.MAP2]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.list_size_def, listTheory.EL, listTheory.list_case_def, listTheory.MAP2_DEF, listTheory.list_distinct]", "reward": 5}]], "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). \u00acNULL l2 \u21d2 EL (LENGTH l1) (l1 ++ l2) = HD l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl1 @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 @ C$list$ HD Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). \u00acNULL l2 \u21d2 EL (LENGTH l1) (l1 ++ l2) = HD l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.TAKE_SUM, listTheory.MEM_ZIP, boolTheory.literal_case_RATOR, listTheory.LENGTH_dropWhile_LESS_EQ, listTheory.EL_APPEND_EQN]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). DFUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ @ C$pred_set$ DFUNSET VP VQ Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VP @ @ C$bool$ IN @ Vf Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). DFUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BETA_THM, pred_setTheory.SET_EQ_SUBSET, pred_setTheory.BIJ_SYM, pred_setTheory.DFUNSET, pred_setTheory.SUBSET_INTER1]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET C$pred_set$ EMPTY Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.SUBSET_applied, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.GSPEC_ETA, pred_setTheory.EMPTY_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2286 u \u21d4 s \u2286 u \u2227 t \u2286 u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ SUBSET @ @ C$pred_set$ UNION Vs Vt Vu @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vu @ @ C$pred_set$ SUBSET Vt Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2286 u \u21d4 s \u2286 u \u2227 t \u2286 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vu @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vu @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vu @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vu"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2228 x \u2208 (t :\u03b1 -> bool) \u21d2 x \u2208 (u :\u03b1 -> bool)) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 x \u2208 u) \u2227 (\u2200(x :\u03b1). x \u2208 t \u21d2 x \u2208 u) \u2228 (\u2203(x :\u03b1). (x \u2208 s \u2228 x \u2208 t) \u2227 x \u2209 u) \u2227 ((\u2203(x :\u03b1). x \u2208 s \u2227 x \u2209 u) \u2228 \u2203(x :\u03b1). x \u2208 t \u2227 x \u2209 u)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_THM, pred_setTheory.GSPECIFICATION, pred_setTheory.UNION_DEF, boolTheory.EQ_EXPAND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_REFL, boolTheory.CONJ_ASSOC, boolTheory.ONTO_THM, boolTheory.LEFT_FORALL_OR_THM, pred_setTheory.UNION_COMM]", "reward": 5}]], "\u2200(m :num) (n :num). SUC m = SUC n \u21d4 m = n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$num$ SUC Vm @ C$num$ SUC Vn @ @ C$min$ = Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). SUC m = SUC n \u21d4 m = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.IMP_CLAUSES, boolTheory.ABS_SIMP, boolTheory.LET_THM, boolTheory.JRH_INDUCT_UTIL, boolTheory.OR_CLAUSES]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). MEM x l \u21d4 FOLDR $\\/ F (MAP ($= x) l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). MEM x l \u21d4 FOLDR $\\/ F (MAP ($= x) l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP ($= x) ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (l :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP ($= x) l)"], "goal": "\u2200(h :\u03b1) (x :\u03b1). MEM x (h::(l :\u03b1 list)) \u21d4 FOLDR $\\/ F (MAP ($= x) (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F @ @ C$list$ MAP @ C$min$ = Vx @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (l :\u03b1 list) \u21d4 FOLDR $\\/ F (MAP ($= x) l)"], "goal": "\u2200(h :\u03b1) (x :\u03b1). MEM x (h::(l :\u03b1 list)) \u21d4 FOLDR $\\/ F (MAP ($= x) (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FLAT_APPEND, boolTheory.BETA_THM, listTheory.SHORTLEX_total, listTheory.EVERY2_MEM_MONO, listTheory.list_case_compute]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EVERY2_refl, listTheory.SUM_MAP_MEM_bound, listTheory.LUPDATE_SEM, boolTheory.LEFT_EXISTS_AND_THM, listTheory.FRONT_DEF]", "reward": 5}]], "\u2200(h :\u03b1) (t :\u03b1 list). TL (h::t) = t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vt @ @ C$min$ = @ C$list$ TL @ @ C$list$ CONS Vh Vt Vt"}, "plain": {"assumptions": [], "goal": "\u2200(h :\u03b1) (t :\u03b1 list). TL (h::t) = t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOTH_FORALL_IMP_THM, listTheory.TL_DEF, boolTheory.F_DEF, boolTheory.DATATYPE_TAG_DEF, boolTheory.CONJ_ASSOC]", "reward": 5}]], "((a :\u03b1),(b :\u03b1)) \u2208 {(x,x) | (P :\u03b1 -> bool) x} \u21d4 P a \u2227 a = b": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN @ @ C$pair$ , Va Vb @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ @ C$pair$ , Vx Vx @ VP Vx @ @ C$bool$ /\\ @ VP Va @ @ C$min$ = Va Vb"}, "plain": {"assumptions": [], "goal": "((a :\u03b1),(b :\u03b1)) \u2208 {(x,x) | (P :\u03b1 -> bool) x} \u21d4 P a \u2227 a = b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$min$ = Vb Va @ VP Va @ @ C$bool$ /\\ @ VP Va @ @ C$min$ = Va Vb"}, "plain": {"assumptions": [], "goal": "(b :\u03b1) = (a :\u03b1) \u2227 (P :\u03b1 -> bool) a \u21d4 P a \u2227 a = b"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_DEF, boolTheory.BOOL_FUN_CASES_THM, boolTheory.DISJ_ASSOC, pred_setTheory.GSPECIFICATION, pairTheory.FST_PAIR_MAP]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_GSPEC_IFF, pairTheory.pair_case_def, boolTheory.OR_CONG, pred_setTheory.EXTENSION, boolTheory.COND_EXPAND_IMP]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 IMAGE f (s DELETE x) = IMAGE f s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ DELETE Vs Vx @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 IMAGE f (s DELETE x) = IMAGE f s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.TC_PSUBSET, boolTheory.ONTO_THM, pred_setTheory.PSUBSET_INSERT_SUBSET, boolTheory.MONO_EXISTS, pred_setTheory.DELETE_NON_ELEMENT_RWT]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1 list). FRONT (x::y) \u227c x::y": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx Vy @ @ C$list$ CONS Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1 list). FRONT (x::y) \u227c x::y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). FRONT [x] \u227c [x]"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx Vy @ @ C$list$ CONS Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vy @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1). FRONT (x::(y :\u03b1 list)) \u227c x::y"], "goal": "\u2200(h :\u03b1) (x :\u03b1). FRONT (x::h::(y :\u03b1 list)) \u227c x::h::y"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `y`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx Vy @ @ C$list$ CONS Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$list$ isPREFIX @ C$list$ FRONT @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vy @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1). FRONT (x::(y :\u03b1 list)) \u227c x::y"], "goal": "\u2200(h :\u03b1) (x :\u03b1). FRONT (x::h::(y :\u03b1 list)) \u227c x::h::y"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_FORALL_OR_THM, listTheory.EVERY2_LUPDATE_same, listTheory.LIST_TO_SET_GENLIST, listTheory.LIST_IGNORE_BIND_def, boolTheory.NOT_IMP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "simp[boolTheory.literal_case_CONG, listTheory.list_case_compute, boolTheory.LET_CONG, listTheory.HD_DROP, listTheory.EVERY_FILTER_IMP]", "reward": 5}]], "(0 :num) < (n :num) \u21d2 TAKE n ((x :\u03b1)::(xs :\u03b1 list)) = x::TAKE (n \u2212 (1 :num)) xs": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vx Vxs @ @ C$list$ CONS Vx @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vxs"}, "plain": {"assumptions": [], "goal": "(0 :num) < (n :num) \u21d2 TAKE n ((x :\u03b1)::(xs :\u03b1 list)) = x::TAKE (n \u2212 (1 :num)) xs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[arithmeticTheory.MIN_COMM, listTheory.LIST_REL_EVERY_ZIP, arithmeticTheory.EXP2_LT, listTheory.TAKE_def, listTheory.DROP_def]", "reward": 5}]], "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool) (l :\u03b1 list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 Vl @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool) (l :\u03b1 list). FILTER f1 (FILTER f2 l) = FILTER f2 (FILTER f1 l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 C$list$ NIL @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool). FILTER f1 (FILTER f2 ([] :\u03b1 list)) = FILTER f2 (FILTER f1 ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 Vl @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool). FILTER f1 (FILTER f2 (l :\u03b1 list)) = FILTER f2 (FILTER f1 l)"], "goal": "\u2200(h :\u03b1) (f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool). FILTER f1 (FILTER f2 (h::(l :\u03b1 list))) = FILTER f2 (FILTER f1 (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 Vl @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf1 @ C$bool$ ! | Vf2 @ @ C$min$ = @ @ C$list$ FILTER Vf1 @ @ C$list$ FILTER Vf2 @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER Vf2 @ @ C$list$ FILTER Vf1 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool). FILTER f1 (FILTER f2 (l :\u03b1 list)) = FILTER f2 (FILTER f1 l)"], "goal": "\u2200(h :\u03b1) (f1 :\u03b1 -> bool) (f2 :\u03b1 -> bool). FILTER f1 (FILTER f2 (h::(l :\u03b1 list))) = FILTER f2 (FILTER f1 (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.TAKE_APPEND1, listTheory.oEL_THM, listTheory.LENGTH_EQ_NUM_compute, listTheory.LIST_GUARD_def, listTheory.LENGTH_GENLIST]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EVERY2_LUPDATE_same, listTheory.MAP_APPEND, listTheory.REV_DEF, boolTheory.COND_CLAUSES, listTheory.isPREFIX_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s DELETE x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$bool$ IN Vx @ @ C$pred_set$ DELETE Vs Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s DELETE x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, pred_setTheory.IN_DELETE, boolTheory.EXISTS_UNIQUE_REFL, boolTheory.AND_IMP_INTRO, boolTheory.FORALL_SIMP]", "reward": 5}]], "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 P \u21d4 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | VP @ @ C$min$ = @ @ C$bool$ IN Vx VP @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (P :\u03b1 -> bool). x \u2208 P \u21d4 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FORALL_BOOL, boolTheory.REFL_CLAUSE, boolTheory.IN_DEF, boolTheory.LEFT_EXISTS_AND_THM, boolTheory.literal_case_RATOR]", "reward": 5}]], "\u2200(f :\u03b1 -> num) (x :\u03b1) (y :\u03b1). measure f x y \u21d4 f x < f y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$prim_rec$ measure Vf Vx Vy @ @ C$prim_rec$ < @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> num) (x :\u03b1) (y :\u03b1). measure f x y \u21d4 f x < f y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_EXPAND, prim_recTheory.LESS_REFL, prim_recTheory.measure_def, boolTheory.IMP_CONJ_THM, boolTheory.ABS_SIMP]", "reward": 5}]], "IDEM (TC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ IDEM C$relation$ TC"}, "plain": {"assumptions": [], "goal": "IDEM (TC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.IDEM, relationTheory.RUNION_ASSOC, relationTheory.inv_TC, relationTheory.symmetric_TC, relationTheory.TC_IDEM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u2286 \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u2286 \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.EXTENSION, boolTheory.LEFT_EXISTS_AND_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 RC R x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ @ C$relation$ RC VR Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 RC R x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.RC_DEF, relationTheory.symmetric_RC, boolTheory.T_DEF, boolTheory.COND_EXPAND_OR, boolTheory.EQ_IMP_THM]", "reward": 5}]], "(\u2200(s :\u03b1 + \u03b2). (P :\u03b1 + \u03b2 -> bool) s) \u21d4 (\u2200(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2227 \u2200(y :\u03b2). P (INR y :\u03b1 + \u03b2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vs @ VP Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ VP @ C$sum$ INL Vx @ C$bool$ ! | Vy @ VP @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 + \u03b2). (P :\u03b1 + \u03b2 -> bool) s) \u21d4 (\u2200(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2227 \u2200(y :\u03b2). P (INR y :\u03b1 + \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_OR, boolTheory.TYPE_DEFINITION, sumTheory.sum_INDUCT, boolTheory.EXISTS_itself, boolTheory.LET_CONG]", "reward": 5}]], "\u2200(n :num). TAKE n ([] :\u03b1 list) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ TAKE Vn C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). TAKE n ([] :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FRONT_CONS, boolTheory.LCOMM_THM, listTheory.FILTER_NEQ_NIL, boolTheory.EXCLUDED_MIDDLE, listTheory.TAKE_def]", "reward": 5}]], "\u2200(x :\u03b1 # \u03b2) (l :(\u03b1 # \u03b2) list). UNZIP (SNOC x l) = (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ UNZIP @ @ C$list$ SNOC Vx Vl @ @ C$pair$ , @ @ C$list$ SNOC @ C$pair$ FST Vx @ C$pair$ FST @ C$list$ UNZIP Vl @ @ C$list$ SNOC @ C$pair$ SND Vx @ C$pair$ SND @ C$list$ UNZIP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 # \u03b2) (l :(\u03b1 # \u03b2) list). UNZIP (SNOC x l) = (SNOC (FST x) (FST (UNZIP l)),SNOC (SND x) (SND (UNZIP l)))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.COND_EXPAND, listTheory.LIST_REL_EL_EQN, boolTheory.OR_INTRO_THM2, listTheory.UNZIP_MAP, listTheory.EL_ALL_DISTINCT_EL_EQ]", "reward": 5}]], "\u2200(x :\u03b1). x \u2208 \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$bool$ IN Vx C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x \u2208 \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, boolTheory.NOT_CLAUSES, pred_setTheory.UNIV_DEF, pred_setTheory.GSPEC_ETA, boolTheory.LEFT_FORALL_OR_THM]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b2). (INL x :\u03b1 + \u03b2) \u2260 (INR y :\u03b1 + \u03b2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ~ @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b2). (INL x :\u03b1 + \u03b2) \u2260 (INR y :\u03b1 + \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[sumTheory.sum_ISO_DEF, boolTheory.EQ_TRANS, sumTheory.INR_neq_INL, boolTheory.REFL_CLAUSE, boolTheory.EXISTS_REFL]", "reward": 5}]], "nfst (0 :num) = (0 :num)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$numpair$ nfst C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "nfst (0 :num) = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$numpair$ invtri C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "tri\u207b\u00b9 (0 :num) = (0 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[numpairTheory.tri_le, numpairTheory.tri_eq_0, numpairTheory.nfst_def, numpairTheory.nfst_npair, numpairTheory.invtri_linverse]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[numpairTheory.nsnd_npair, numpairTheory.tri_formula, numpairTheory.tri_eq_0, numpairTheory.invtri_unique, numpairTheory.invtri_lower]", "reward": 5}]], "FINITE (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ FINITE C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "FINITE (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FUNSET_THM, pred_setTheory.FINITE_DEF, pred_setTheory.INTER_OVER_UNION, pred_setTheory.DISJOINT_DEF, pred_setTheory.LINV_OPT_def]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1) (l :\u03b3 list). FOLDR f e (MAP g l) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1) (l :\u03b3 list). FOLDR f e (MAP g l) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1). FOLDR f e (MAP g ([] :\u03b3 list)) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e ([] :\u03b3 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1). FOLDR f e (MAP g (l :\u03b3 list)) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e l"], "goal": "\u2200(h :\u03b3) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1). FOLDR f e (MAP g (h::(l :\u03b3 list))) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vy @ @ Vf @ Vg Vx Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1). FOLDR f e (MAP g (l :\u03b3 list)) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e l"], "goal": "\u2200(h :\u03b3) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (g :\u03b3 -> \u03b1). FOLDR f e (MAP g (h::(l :\u03b3 list))) = FOLDR (\u03bb(x :\u03b3) (y :\u03b2). f (g x) y) e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDL, boolTheory.EXISTS_SIMP, listTheory.LIST_BIND_MAP, listTheory.EXISTS_SNOC, listTheory.isPREFIX_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.splitAtPki_MAP, listTheory.LIST_TO_SET_APPEND, boolTheory.literal_case_CONG, boolTheory.RIGHT_AND_OVER_OR, listTheory.LIST_TO_SET_APPEND]", "reward": 5}]], "\u2200(x :\u03b1). FINITE {x}": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$pred_set$ FINITE @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). FINITE {x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.FINITE_DEF, pred_setTheory.EMPTY_SUBSET, pred_setTheory.INSERT_DELETE, boolTheory.LEFT_EXISTS_AND_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). INJ f s t \u2227 INJ g t u \u21d2 INJ (g \u2218 f) s u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$pred_set$ INJ Vf Vs Vt @ @ @ C$pred_set$ INJ Vg Vt Vu @ @ @ C$pred_set$ INJ @ @ C$combin$ o Vg Vf Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). INJ f s t \u2227 INJ g t u \u21d2 INJ (g \u2218 f) s u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.UEXISTS_SIMP, boolTheory.EQ_EXT, pred_setTheory.IMAGE_SING, pred_setTheory.NOT_EMPTY_SING, pred_setTheory.INJ_IFF]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 x INSERT s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$bool$ IN Vx @ @ C$pred_set$ INSERT Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 x INSERT s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_applied, pred_setTheory.DISJOINT_DIFF, boolTheory.LET_RATOR, pred_setTheory.IN_INSERT, pred_setTheory.INTER_EMPTY]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). FILTER P (SNOC x l) = if P x then SNOC x (FILTER P l) else FILTER P l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ SNOC Vx Vl @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ SNOC Vx @ @ C$list$ FILTER VP Vl @ @ C$list$ FILTER VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). FILTER P (SNOC x l) = if P x then SNOC x (FILTER P l) else FILTER P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_OR, listTheory.LENGTH_UNZIP, boolTheory.LET_RAND, listTheory.FILTER_APPEND_DISTRIB, boolTheory.LEFT_AND_FORALL_THM]", "reward": 5}]], "\u2200(p :\u03b1 -> bool). p (UNIV_POINT p) \u21d4 \u2200(x :\u03b1). p x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ @ C$min$ = @ Vp @ C$normalForms$ UNIV_POINT Vp @ C$bool$ ! | Vx @ Vp Vx"}, "plain": {"assumptions": [], "goal": "\u2200(p :\u03b1 -> bool). p (UNIV_POINT p) \u21d4 \u2200(x :\u03b1). p x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[normalFormsTheory.UNIV_POINT_DEF, boolTheory.COND_RAND, boolTheory.LEFT_OR_CONG, boolTheory.LEFT_FORALL_IMP_THM, boolTheory.IN_DEF]", "reward": 5}]], "BIGINTER (B :(\u03b1 -> bool) -> bool) (x :\u03b1) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ BIGINTER VB Vx @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ IN VP VB @ @ C$bool$ IN Vx VP"}, "plain": {"assumptions": [], "goal": "BIGINTER (B :(\u03b1 -> bool) -> bool) (x :\u03b1) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.REST_SING, pred_setTheory.IMAGE_SING, pred_setTheory.BIGINTER, pred_setTheory.INSERT_SUBSET, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d4 s HAS_SIZE CARD s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$pred_set$ FINITE Vs @ @ C$pred_set$ HAS_SIZE Vs @ C$pred_set$ CARD Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d4 s HAS_SIZE CARD s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.HAS_SIZE, pred_setTheory.IMAGE_11, pred_setTheory.FORALL_IN_INSERT, pred_setTheory.TC_SUBSET_THM]", "reward": 5}]], "\u2200(P :(\u03b1 -> bool) -> bool). P (\u2205 :\u03b1 -> bool) \u2227 (\u2200(s :\u03b1 -> bool). FINITE s \u2227 P s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)) \u21d2 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 P s": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP C$pred_set$ EMPTY @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ VP Vs @ C$bool$ ! | Ve @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Ve Vs @ VP @ @ C$pred_set$ INSERT Ve Vs @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ VP Vs"}, "plain": {"assumptions": [], "goal": "\u2200(P :(\u03b1 -> bool) -> bool). P (\u2205 :\u03b1 -> bool) \u2227 (\u2200(s :\u03b1 -> bool). FINITE s \u2227 P s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)) \u21d2 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 P s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$pred_set$ FINITE Vs", "@ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ VP Vs @ C$bool$ ! | Ve @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Ve Vs @ VP @ @ C$pred_set$ INSERT Ve Vs", "@ VP C$pred_set$ EMPTY"], "goal": "@ VP Vs"}, "plain": {"assumptions": ["FINITE (s :\u03b1 -> bool)", "\u2200(s :\u03b1 -> bool). FINITE s \u2227 (P :(\u03b1 -> bool) -> bool) s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)", "(P :(\u03b1 -> bool) -> bool) (\u2205 :\u03b1 -> bool)"], "goal": "(P :(\u03b1 -> bool) -> bool) (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_DEF, pred_setTheory.IN_UNION, boolTheory.EQ_EXPAND, pred_setTheory.IN_DELETE, pred_setTheory.SUBSET_INTER]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ VP Vs @ C$bool$ ! | Ve @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Ve Vs @ VP @ @ C$pred_set$ INSERT Ve Vs", "@ VP C$pred_set$ EMPTY"], "goal": "@ @ C$bool$ /\\ @ VP C$pred_set$ EMPTY @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ VP Vs @ C$bool$ ! | Ve @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Ve Vs @ VP @ @ C$pred_set$ INSERT Ve Vs"}, "plain": {"assumptions": ["\u2200(s :\u03b1 -> bool). FINITE s \u2227 (P :(\u03b1 -> bool) -> bool) s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)", "(P :(\u03b1 -> bool) -> bool) (\u2205 :\u03b1 -> bool)"], "goal": "(P :(\u03b1 -> bool) -> bool) (\u2205 :\u03b1 -> bool) \u2227 \u2200(s :\u03b1 -> bool). FINITE s \u2227 P s \u21d2 \u2200(e :\u03b1). e \u2209 s \u21d2 P (e INSERT s)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `s`", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "simp[pred_setTheory.PSUBSET_UNIV, pred_setTheory.LINV_LO, pred_setTheory.IMAGE_applied, boolTheory.AND_CLAUSES, pred_setTheory.SUBSET_applied]", "reward": 5}]], "$! (UNCURRY (\u03bb(x :\u03b1). (P :\u03b1 -> \u03b2 -> bool) x)) \u21d4 \u2200(x :\u03b1). $! (P x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! @ C$pair$ UNCURRY | Vx @ VP Vx @ C$bool$ ! | Vx @ C$bool$ ! @ VP Vx"}, "plain": {"assumptions": [], "goal": "$! (UNCURRY (\u03bb(x :\u03b1). (P :\u03b1 -> \u03b2 -> bool) x)) \u21d4 \u2200(x :\u03b1). $! (P x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.FORALL_THM, pairTheory.PAIR, pairTheory.UNCURRY_DEF, pairTheory.CURRY_UNCURRY_THM, pairTheory.CURRY_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2286 s \u21d4 s = \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ SUBSET C$pred_set$ UNIV Vs @ @ C$min$ = Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2286 s \u21d4 s = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_IN_EMPTY, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_ETA, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_EQ_UNIV_IMP]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2200(y :\u03b1). y \u2208 IMAGE f s \u21d2 P y) \u21d4 \u2200(x :\u03b2). x \u2208 s \u21d2 P (f x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ VP Vy @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ VP @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool). (\u2200(y :\u03b1). y \u2208 IMAGE f s \u21d2 P y) \u21d4 \u2200(x :\u03b2). x \u2208 s \u21d2 P (f x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.SELECT_UNIQUE, boolTheory.LET_RATOR, boolTheory.bool_case_thm, pred_setTheory.IN_IMAGE, boolTheory.SWAP_FORALL_THM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). EVERY P ([] :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EVERY P (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EVERY P (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ /\\ @ VP Vx Vl' C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EVERY P (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EVERY P (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2227 l') T (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.HD_DROP, listTheory.LIST_REL_NIL, listTheory.ALL_DISTINCT, boolTheory.LEFT_FORALL_IMP_THM, listTheory.TAKE_GENLIST]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.FILTER_COND_REWRITE, listTheory.LLEX_MONO, listTheory.DROP_cons, listTheory.MEM_LUPDATE_E, boolTheory.itself_case_thm]", "reward": 5}]], "nub ([] :\u03b1 list) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ nub C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "nub ([] :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EL_simp, listTheory.INDEX_FIND_def, listTheory.FOLDL, listTheory.nub_def, listTheory.DROP_GENLIST]", "reward": 5}]], "TAKE (0 :num) (l :\u03b1 list) = ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "TAKE (0 :num) (l :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "TAKE (0 :num) ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["TAKE (0 :num) (l :\u03b1 list) = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). TAKE (0 :num) (h::(l :\u03b1 list)) = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ TAKE C$num$ 0 @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["TAKE (0 :num) (l :\u03b1 list) = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). TAKE (0 :num) (h::(l :\u03b1 list)) = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.ZIP_UNZIP, listTheory.EXISTS_MEM, listTheory.DROP_nil, listTheory.TAKE_nil, listTheory.LENGTH_FRONT_CONS]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_ZIP_MIN, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.ZIP_def]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP C$list$ NIL @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). EXISTS P ([] :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EXISTS P (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EXISTS P (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR | Vx | Vl' @ @ C$bool$ \\/ @ VP Vx Vl' C$bool$ F @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). EXISTS P (l :\u03b1 list) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). EXISTS P (h::(l :\u03b1 list)) \u21d4 FOLDR (\u03bb(x :\u03b1) (l' :bool). P x \u2228 l') F (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.EVERY2_sym, listTheory.LIST_APPLY_o, listTheory.SUM, listTheory.TAKE_LENGTH_TOO_LONG, listTheory.GENLIST_FUN_EQ]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.TAKE_APPEND2, listTheory.LENGTH_MAP, listTheory.TAKE_LENGTH_ID_rwt, listTheory.LENGTH_EQ_SUM, listTheory.TAKE_APPEND2]", "reward": 5}]], "NULL ((l1 :\u03b1 list) ++ (l2 :\u03b1 list)) \u21d4 NULL l1 \u2227 NULL l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ NULL @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ /\\ @ C$list$ NULL Vl1 @ C$list$ NULL Vl2"}, "plain": {"assumptions": [], "goal": "NULL ((l1 :\u03b1 list) ++ (l2 :\u03b1 list)) \u21d4 NULL l1 \u2227 NULL l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.list_size_def, listTheory.APPEND_eq_NIL, listTheory.NULL_EQ, listTheory.LIST_TO_SET, listTheory.EL_MAP]", "reward": 5}]], "\u2200(m :\u03b1) (n :\u03b1). (\u03bb(x :\u03b1) (y :\u03b1). y = (f :\u03b1 -> \u03b1) x)\ua673 (f m) n \u21d4 (\u03bb(x :\u03b1) (y :\u03b1). y = f x)\u207a m n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ @ C$relation$ RTC | Vx | Vy @ @ C$min$ = Vy @ Vf Vx @ Vf Vm Vn @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ Vf Vx Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :\u03b1) (n :\u03b1). (\u03bb(x :\u03b1) (y :\u03b1). y = (f :\u03b1 -> \u03b1) x)\ua673 (f m) n \u21d4 (\u03bb(x :\u03b1) (y :\u03b1). y = f x)\u207a m n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.DISJ_COMM, relationTheory.NOT_INVOL, relationTheory.inv_inv, relationTheory.EXTEND_RTC_TC_EQN, boolTheory.EXISTS_REFL]", "reward": 5}]], "\u2200(ls :\u03b1 list) (n :num). n \u2264 LENGTH ls \u21d2 REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls \u2212 n) ls)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vls @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vls @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ DROP Vn Vls @ C$list$ REVERSE @ @ C$rich_list$ LASTN @ @ C$arithmetic$ - @ C$list$ LENGTH Vls Vn Vls"}, "plain": {"assumptions": [], "goal": "\u2200(ls :\u03b1 list) (n :num). n \u2264 LENGTH ls \u21d2 REVERSE (DROP n ls) = REVERSE (LASTN (LENGTH ls \u2212 n) ls)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.NORM_0, rich_listTheory.LASTN_DROP, listTheory.LIST_APPLY_o, arithmeticTheory.MOD_LESS, rich_listTheory.COMM_MONOID_FOLDL]", "reward": 5}]], "\u2200(p :\u03b1 # \u03b2) (f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4). SND ((f ## g) p) = g (SND p)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vf @ C$bool$ ! | Vg @ @ C$min$ = @ C$pair$ SND @ @ @ C$pair$ ## Vf Vg Vp @ Vg @ C$pair$ SND Vp"}, "plain": {"assumptions": [], "goal": "\u2200(p :\u03b1 # \u03b2) (f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4). SND ((f ## g) p) = g (SND p)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM1, pairTheory.SND, pairTheory.PAIR_MAP, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.BOTH_FORALL_OR_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\ua673": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$relation$ reflexive @ C$relation$ RTC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\ua673"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.RTC_REFL, boolTheory.bool_INDUCT, boolTheory.EQ_EXPAND, relationTheory.reflexive_def, boolTheory.LET_RAND]", "reward": 5}]], "\u2200(M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (f :\u03b1 -> \u03b2). f = WFREC R M \u21d2 WF R \u21d2 \u2200(x :\u03b1). f x = M (RESTRICT f R x) x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VR @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$min$ = Vf @ @ C$relation$ WFREC VR VM @ @ C$min$ ==> @ C$relation$ WF VR @ C$bool$ ! | Vx @ @ C$min$ = @ Vf Vx @ @ VM @ @ @ C$relation$ RESTRICT Vf VR Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (f :\u03b1 -> \u03b2). f = WFREC R M \u21d2 WF R \u21d2 \u2200(x :\u03b1). f x = M (RESTRICT f R x) x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.TC_lifts_transitive_relations, boolTheory.EQ_SYM_EQ, relationTheory.RC_SUBSET, boolTheory.UNWIND_THM2, relationTheory.WFREC_THM]", "reward": 5}]], "(y :\u03b1) \u2208 {x | (P :\u03b1 -> bool) x} \u21d4 P y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VP Vx @ VP Vy"}, "plain": {"assumptions": [], "goal": "(y :\u03b1) \u2208 {x | (P :\u03b1 -> bool) x} \u21d4 P y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.IMP_F, boolTheory.OR_CONG, pred_setTheory.GSPECIFICATION, boolTheory.EQ_CLAUSES, boolTheory.MONO_NOT]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u1d40 \u21d4 transitive R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ transitive @ C$relation$ inv VR @ C$relation$ transitive VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u1d40 \u21d4 transitive R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vy Vx @ @ VR Vz Vy @ @ VR Vz Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R y x \u2227 R z y \u21d2 R z x) \u21d4 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.LEFT_OR_EXISTS_THM, relationTheory.inv_DEF, relationTheory.transitive_def, relationTheory.WF_inv_image, boolTheory.BOUNDED_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.transitive_RC, boolTheory.EXCLUDED_MIDDLE, relationTheory.WFREC_DEF, relationTheory.symmetric_RC, boolTheory.FORALL_itself]", "reward": 5}]], "\u2200(L :num list). SUM L = SUM_ACC L (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VL @ @ C$min$ = @ C$list$ SUM VL @ @ C$list$ SUM_ACC VL C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(L :num list). SUM L = SUM_ACC L (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MONO_EVERY, listTheory.SUM_ACC_SUM_LEM, listTheory.FILTER, listTheory.FOLDL_UNION_BIGUNION, boolTheory.literal_case_CONG]", "reward": 5}]], "([] :\u03b1 list) \u2208 common_prefixes (s :\u03b1 list -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ IN C$list$ NIL @ C$rich_list$ common_prefixes Vs"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2208 common_prefixes (s :\u03b1 list -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.common_prefixes_def, listTheory.SUM_SNOC, rich_listTheory.ELL_LENGTH_APPEND, listTheory.EL_LENGTH_dropWhile_REVERSE, listTheory.list_distinct]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d2 t = IMAGE f s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ C$min$ = Vt @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d2 t = IMAGE f s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ONE_ONE_THM, pred_setTheory.BIJ_DEF, pred_setTheory.BIJ_DEF, pred_setTheory.IMAGE_SURJ, pred_setTheory.IMAGE_SING]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2209 s \u21d2 s DELETE x = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$pred_set$ DELETE Vs Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2209 s \u21d2 s DELETE x = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DIFF_SUBSET, pred_setTheory.DELETE_NON_ELEMENT, pred_setTheory.PAIR_IN_GSPEC_same, boolTheory.FUN_EQ_THM, boolTheory.EQ_EXPAND]", "reward": 5}]], "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(h1 :\u03b2) (h2 :\u03b2) (t :\u03b2 list). LAST (h1::h2::t) = LAST (h2::t)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LAST @ @ C$list$ CONS Vx C$list$ NIL Vx @ C$bool$ ! | Vh1 @ C$bool$ ! | Vh2 @ C$bool$ ! | Vt @ @ C$min$ = @ C$list$ LAST @ @ C$list$ CONS Vh1 @ @ C$list$ CONS Vh2 Vt @ C$list$ LAST @ @ C$list$ CONS Vh2 Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(h1 :\u03b2) (h2 :\u03b2) (t :\u03b2 list). LAST (h1::h2::t) = LAST (h2::t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.NOT_CONS_NIL, listTheory.EVERY_NOT_EXISTS, listTheory.LAST_DEF, listTheory.LENGTH_FRONT_CONS, listTheory.LENGTH_EQ_NIL]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ DIFF Vs Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DIFF, boolTheory.CONJ_ASSOC, boolTheory.LET_THM, pred_setTheory.SUBSET_DEF, pred_setTheory.DISJOINT_UNION]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT s \u2260 (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$min$ = @ @ C$pred_set$ INSERT Vx Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT s \u2260 (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ C$min$ = @ @ C$pred_set$ INSERT Vx Vs | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) INSERT (s :\u03b1 -> bool) \u2260 (\u03bb(x :\u03b1). F)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.T_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.DIFF_INTER2, pred_setTheory.DISJOINT_EMPTY]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.TC_SUBSET_THM, pred_setTheory.UNION_EMPTY, pred_setTheory.SET_CASES, pred_setTheory.INSERT_applied, pred_setTheory.UNION_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u2229 s = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ INTER Vs Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u2229 s = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.FUN_EQ_THM, pred_setTheory.INTER_applied, pred_setTheory.SPECIFICATION, boolTheory.CONJ_ASSOC, pred_setTheory.UNIV_SUBSET]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (x :\u03b1). x INSERT s = {x} \u222a s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ INSERT Vx Vs @ @ C$pred_set$ UNION @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (x :\u03b1). x INSERT s = {x} \u222a s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ INSERT Vx Vs @ C$pred_set$ GSPEC | Vx' @ @ C$pair$ , Vx' @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx | Vx C$bool$ F @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) INSERT (s :\u03b1 -> bool) = {x' | x' \u2208 x INSERT (\u03bb(x :\u03b1). F) \u2228 x' \u2208 s}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNION_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.INTER_applied, pred_setTheory.IN_INTER, boolTheory.AND_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_INSERT, pred_setTheory.INSERT_DEF, pred_setTheory.PSUBSET_IRREFL]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P (REVERSE l) \u21d4 EXISTS P l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EXISTS VP @ C$list$ REVERSE Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P (REVERSE l) \u21d4 EXISTS P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EXISTS_MEM, boolTheory.FUN_EQ_THM, listTheory.TAKE_LENGTH_ID_rwt, listTheory.LIST_TO_SET_MAP, listTheory.MEM_REVERSE]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u2203(x :\u03b1). x \u2208 s) \u21d4 s \u2260 (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ? | Vx @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2203(x :\u03b1). x \u2208 s) \u21d4 s \u2260 (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ETA_THM, pred_setTheory.EMPTY_DEF, pred_setTheory.IN_APP, boolTheory.SWAP_FORALL_THM, pred_setTheory.NOT_EQUAL_SETS]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). LENGTH l1 = LENGTH l2 \u2227 (\u2200(x :num). x < LENGTH l1 \u21d2 EL x l1 = EL x l2) \u21d2 l1 = l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl1 @ C$list$ LENGTH Vl2 @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH Vl1 @ @ C$min$ = @ @ C$list$ EL Vx Vl1 @ @ C$list$ EL Vx Vl2 @ @ C$min$ = Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). LENGTH l1 = LENGTH l2 \u2227 (\u2200(x :num). x < LENGTH l1 \u21d2 EL x l1 = EL x l2) \u21d2 l1 = l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FLAT_compute, listTheory.list_Axiom_old, prim_recTheory.LESS_NOT_EQ, boolTheory.IMP_CONJ_THM, listTheory.LIST_EQ_REWRITE]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b1) (s :\u03b3 -> bool). IMAGE f (IMAGE g s) = IMAGE (f \u2218 g) s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ IMAGE Vg Vs @ @ C$pred_set$ IMAGE @ @ C$combin$ o Vf Vg Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b1) (s :\u03b3 -> bool). IMAGE f (IMAGE g s) = IMAGE (f \u2218 g) s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.literal_case_RAND, pred_setTheory.PSUBSET_INSERT_SUBSET, pred_setTheory.DIFF_SUBSET, pred_setTheory.UNION_SUBSET, pred_setTheory.IMAGE_COMPOSE]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). FINITE s \u2227 t \u2286 s \u21d2 FINITE t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ @ C$pred_set$ SUBSET Vt Vs @ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). FINITE s \u2227 t \u2286 s \u21d2 FINITE t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$pred_set$ SUBSET Vt Vs", "@ C$pred_set$ FINITE Vs"], "goal": "@ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) \u2286 (s :\u03b1 -> bool)", "FINITE (s :\u03b1 -> bool)"], "goal": "FINITE (t :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_DEF, pred_setTheory.DELETE_applied, pred_setTheory.DFUNSET_applied, pred_setTheory.IN_DISJOINT, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_FINITE, boolTheory.MONO_ALL, pred_setTheory.UNIV_applied, pred_setTheory.IN_DISJOINT, boolTheory.DE_MORGAN_THM]", "reward": 5}]], "((p :bool) \u21d4 if (q :bool) then (r :bool) else (s :bool)) \u21d4 (p \u2228 q \u2228 \u00acs) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (p \u2228 \u00acr \u2228 \u00acs) \u2227 (\u00acq \u2228 r \u2228 \u00acp) \u2227 (q \u2228 s \u2228 \u00acp)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vp @ @ @ C$bool$ COND Vq Vr Vs @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ Vq @ C$bool$ ~ Vs @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ @ C$bool$ ~ Vr @ C$bool$ ~ Vq @ @ C$bool$ /\\ @ @ C$bool$ \\/ Vp @ @ C$bool$ \\/ @ C$bool$ ~ Vr @ C$bool$ ~ Vs @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ C$bool$ ~ Vq @ @ C$bool$ \\/ Vr @ C$bool$ ~ Vp @ @ C$bool$ \\/ Vq @ @ C$bool$ \\/ Vs @ C$bool$ ~ Vp"}, "plain": {"assumptions": [], "goal": "((p :bool) \u21d4 if (q :bool) then (r :bool) else (s :bool)) \u21d4 (p \u2228 q \u2228 \u00acs) \u2227 (p \u2228 \u00acr \u2228 \u00acq) \u2227 (p \u2228 \u00acr \u2228 \u00acs) \u2227 (\u00acq \u2228 r \u2228 \u00acp) \u2227 (q \u2228 s \u2228 \u00acp)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.EXISTS_THM, boolTheory.DISJ_COMM, boolTheory.NOT_IMP, boolTheory.SELECT_ELIM_THM, boolTheory.CONJ_COMM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEVERY P l \u21d4 EXISTS ($\u00ac \u2218 P) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ C$bool$ ~ @ @ C$list$ EVERY VP Vl @ @ C$list$ EXISTS @ @ C$combin$ o C$bool$ ~ VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEVERY P l \u21d4 EXISTS ($\u00ac \u2218 P) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ETA_THM, boolTheory.literal_case_CONG, boolTheory.BOTH_FORALL_OR_THM, boolTheory.ITSELF_UNIQUE, listTheory.EXISTS_NOT_EVERY]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). f \u2208 FUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET VP VQ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VP @ @ C$bool$ IN @ Vf Vx VQ"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). f \u2208 FUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, boolTheory.EQ_SYM_EQ, pred_setTheory.IN_DISJOINT, pred_setTheory.DFUNSET, pred_setTheory.FUNSET]", "reward": 5}]], "(\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x :\u03b1) (h :\u03b1) (t :\u03b1 list). MEM x (h::t) \u21d4 x = h \u2228 MEM x t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL C$bool$ F @ C$bool$ ! | Vx @ C$bool$ ! | Vh @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vt @ @ C$bool$ \\/ @ @ C$min$ = Vx Vh @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d4 F) \u2227 \u2200(x :\u03b1) (h :\u03b1) (t :\u03b1 list). MEM x (h::t) \u21d4 x = h \u2228 MEM x t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.MONO_NOT, boolTheory.RIGHT_AND_OVER_OR, listTheory.EXISTS_APPEND, listTheory.APPEND, listTheory.LIST_TO_SET]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 RC R (x :\u03b1) (y :\u03b1) \u21d2 RC Q x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VQ Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ RC VR Vx Vy @ @ @ C$relation$ RC VQ Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 RC R (x :\u03b1) (y :\u03b1) \u21d2 RC Q x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, boolTheory.RIGHT_EXISTS_AND_THM, relationTheory.reflexive_def, boolTheory.LET_THM, boolTheory.LEFT_OR_OVER_AND]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$min$ = Vs Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s = t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, boolTheory.EQ_CLAUSES, boolTheory.ABS_SIMP, boolTheory.RIGHT_AND_OVER_OR, boolTheory.IN_DEF]", "reward": 5}]], "reflexive (R :\u03b1 -> \u03b1 -> bool)^=": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ reflexive @ C$relation$ EQC VR"}, "plain": {"assumptions": [], "goal": "reflexive (R :\u03b1 -> \u03b1 -> bool)^="}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.EQC_DEF, relationTheory.TC_TRANSITIVE, relationTheory.RC_REFLEXIVE, relationTheory.RTC_INDUCT_RIGHT1, relationTheory.RTC_TRANSITIVE]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list) (a :\u03b1). MEM a l \u21d2 MEM (f a) (MAP f l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vl @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Va @ C$list$ LIST_TO_SET Vl @ @ C$bool$ IN @ Vf Va @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list) (a :\u03b1). MEM a l \u21d2 MEM (f a) (MAP f l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_SYM_EQ, boolTheory.JRH_INDUCT_UTIL, listTheory.MEM_MAP, boolTheory.F_DEF, listTheory.FLAT_APPEND]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). FILTER P (FILTER Q l) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). FILTER P (FILTER Q l) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ C$list$ NIL @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q ([] :\u03b1 list)) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q (l :\u03b1 list)) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q (h::(l :\u03b1 list))) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ @ @ C$list$ CONS Vh Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q (l :\u03b1 list)) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q (h::(l :\u03b1 list))) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_AND_FORALL_THM, listTheory.MAP_TAKE, boolTheory.EXCLUDED_MIDDLE, listTheory.LLEX_not_WF, listTheory.MAP_MAP_o]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$bool$ /\\ @ VP Vh C$bool$ T", "@ VQ Vh", "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$list$ FILTER VP @ @ C$list$ FILTER VQ Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl"], "goal": "@ @ C$min$ = @ @ @ C$bool$ COND @ VP Vh @ @ C$list$ CONS Vh @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl @ @ C$list$ FILTER | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl"}, "plain": {"assumptions": ["\u00ac((P :\u03b1 -> bool) (h :\u03b1) \u2227 T)", "(Q :\u03b1 -> bool) (h :\u03b1)", "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). FILTER P (FILTER Q (l :\u03b1 list)) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l"], "goal": "(if (P :\u03b1 -> bool) (h :\u03b1) then h::FILTER (\u03bb(x :\u03b1). P x \u2227 (Q :\u03b1 -> bool) x) (l :\u03b1 list) else FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l) = FILTER (\u03bb(x :\u03b1). P x \u2227 Q x) l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.MONO_OR, listTheory.EQ_LIST, listTheory.list_case_eq, listTheory.LIST_NOT_EQ, boolTheory.OR_DEF]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.APPEND_LENGTH_EQ, listTheory.LENGTH_DROP, listTheory.MEM_LUPDATE, listTheory.SNOC, listTheory.LEN_LENGTH_LEM]", "reward": 5}]], "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INR x :\u03b2 + \u03b1) \u2208 (t :\u03b2 + \u03b1 -> bool)) \u21d2 INJ (INR :\u03b1 -> \u03b2 + \u03b1) s t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ C$sum$ INR Vx Vt @ @ @ C$pred_set$ INJ C$sum$ INR Vs Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INR x :\u03b2 + \u03b1) \u2208 (t :\u03b2 + \u03b1 -> bool)) \u21d2 INJ (INR :\u03b1 -> \u03b2 + \u03b1) s t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.COUNT_applied, pred_setTheory.INSERT_SUBSET, pred_setTheory.IN_CROSS, boolTheory.LEFT_AND_FORALL_THM, pred_setTheory.INJ_DEF]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u2260 l2 \u21d2 \u2200(h1 :\u03b1) (h2 :\u03b1). h1::l1 \u2260 h2::l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl1 Vl2 @ C$bool$ ! | Vh1 @ C$bool$ ! | Vh2 @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh1 Vl1 @ @ C$list$ CONS Vh2 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u2260 l2 \u21d2 \u2200(h1 :\u03b1) (h2 :\u03b1). h1::l1 \u2260 h2::l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FILTER, boolTheory.EXISTS_SIMP, boolTheory.bool_INDUCT, listTheory.CONS_11, boolTheory.IMP_ANTISYM_AX]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (e :\u03b1) (s2 :\u03b1 -> bool). s DELETE e \u2286 s2 \u21d4 s \u2286 e INSERT s2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Ve @ C$bool$ ! | Vs2 @ @ C$min$ = @ @ C$pred_set$ SUBSET @ @ C$pred_set$ DELETE Vs Ve Vs2 @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ INSERT Ve Vs2"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (e :\u03b1) (s2 :\u03b1 -> bool). s DELETE e \u2286 s2 \u21d4 s \u2286 e INSERT s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ONE_ONE_THM, boolTheory.BOOL_FUN_CASES_THM, pred_setTheory.SUBSET_INSERT_DELETE, pred_setTheory.SUM_SET_IN_LE, pred_setTheory.DISJOINT_EMPTY_REFL_RWT]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). \u00acNULL (SNOC x l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ SNOC Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). \u00acNULL (SNOC x l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.NULL_EQ, listTheory.EL_LENGTH_SNOC, boolTheory.REFL_CLAUSE, listTheory.LIST_LIFT2_def, listTheory.LIST_BIND_def]", "reward": 5}]], "\u2200(P :\u03b1 -> \u03b2 -> bool). (\u2203(x :\u03b1) (y :\u03b2). P x y) \u21d4 \u2203((x :\u03b1),(y :\u03b2)). P x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ VP Vx Vy @ C$bool$ ? @ C$pair$ UNCURRY | Vx | Vy @ @ VP Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> \u03b2 -> bool). (\u2203(x :\u03b1) (y :\u03b2). P x y) \u21d4 \u2203((x :\u03b1),(y :\u03b2)). P x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.SND, pairTheory.ELIM_PEXISTS, boolTheory.EQ_IMP_THM, pairTheory.ELIM_UNCURRY, pairTheory.CLOSED_PAIR_EQ]", "reward": 5}]], "EVERY (P :\u03b1 -> bool) (FLAT (ls :\u03b1 list list)) \u21d4 EVERY (EVERY P) ls": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ EVERY VP @ C$list$ FLAT Vls @ @ C$list$ EVERY @ C$list$ EVERY VP Vls"}, "plain": {"assumptions": [], "goal": "EVERY (P :\u03b1 -> bool) (FLAT (ls :\u03b1 list list)) \u21d4 EVERY (EVERY P) ls"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FLAT Vls @ VP Ve @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vls @ C$bool$ ! | Ve' @ @ C$min$ ==> @ @ C$bool$ IN Ve' @ C$list$ LIST_TO_SET Ve @ VP Ve'"}, "plain": {"assumptions": [], "goal": "(\u2200(e :\u03b1). MEM e (FLAT (ls :\u03b1 list list)) \u21d2 (P :\u03b1 -> bool) e) \u21d4 \u2200(e :\u03b1 list). MEM e ls \u21d2 \u2200(e' :\u03b1). MEM e' e \u21d2 P e'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_DEF, listTheory.MAP2, listTheory.EVERY_MEM, listTheory.list_Axiom, listTheory.list_case_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.EXISTS_DEF, listTheory.TL_DEF, listTheory.MAP_APPEND, listTheory.MEM_FLAT, listTheory.EQ_LIST]", "reward": 5}]], "ZIP (([] :\u03b3 list),([] :\u03b4 list)) = ([] :(\u03b3 # \u03b4) list) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b2) (l2 :\u03b2 list). ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL C$list$ NIL C$list$ NIL @ C$bool$ ! | Vx1 @ C$bool$ ! | Vl1 @ C$bool$ ! | Vx2 @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vx1 Vl1 @ @ C$list$ CONS Vx2 Vl2 @ @ C$list$ CONS @ @ C$pair$ , Vx1 Vx2 @ C$list$ ZIP @ @ C$pair$ , Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "ZIP (([] :\u03b3 list),([] :\u03b4 list)) = ([] :(\u03b3 # \u03b4) list) \u2227 \u2200(x1 :\u03b1) (l1 :\u03b1 list) (x2 :\u03b2) (l2 :\u03b2 list). ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_FORALL_IMP_THM, boolTheory.bool_case_CONG, boolTheory.BETA_THM, listTheory.ZIP_def, pairTheory.LEX_DEF]", "reward": 5}]], "\u2200(m :num) (n :num). m < n \u21d2 EL m (COUNT_LIST n) = m": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ @ C$min$ = @ @ C$list$ EL Vm @ C$rich_list$ COUNT_LIST Vn Vm"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m < n \u21d2 EL m (COUNT_LIST n) = m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.LASTN_APPEND1, rich_listTheory.COUNT_LIST_GENLIST, rich_listTheory.DROP_LENGTH_APPEND, rich_listTheory.BUTLASTN_LENGTH_APPEND, rich_listTheory.EXISTS_SEG]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b3 -> bool). PREIMAGE f (PREIMAGE g s) = PREIMAGE (g \u2218 f) s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ PREIMAGE Vg Vs @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o Vg Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b3 -> bool). PREIMAGE f (PREIMAGE g s) = PREIMAGE (g \u2218 f) s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SURJ_DEF, pred_setTheory.BIJ_ALT, pred_setTheory.DELETE_applied, pred_setTheory.PREIMAGE_ALT, pred_setTheory.GSPEC_OR]", "reward": 5}]], "\u2200(a :\u03b1 -> bool) (b :\u03b1 -> bool) (c :\u03b2 -> bool) (d :\u03b2 -> bool). a \u2286 b \u2227 c \u2286 d \u21d2 a \u00d7 c \u2286 b \u00d7 d": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Va Vb @ @ C$pred_set$ SUBSET Vc Vd @ @ C$pred_set$ SUBSET @ @ C$pred_set$ CROSS Va Vc @ @ C$pred_set$ CROSS Vb Vd"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 -> bool) (b :\u03b1 -> bool) (c :\u03b2 -> bool) (d :\u03b2 -> bool). a \u2286 b \u2227 c \u2286 d \u21d2 a \u00d7 c \u2286 b \u00d7 d"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.IN_IMAGE, pred_setTheory.EXTENSION, pred_setTheory.CROSS_SUBSET, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). T) xs = xs": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ @ C$min$ = @ @ C$list$ FILTER | Vx C$bool$ T Vxs Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). T) xs = xs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EXISTS_DEF, listTheory.EVERY_EL, listTheory.FILTER_EQ_ID, boolTheory.EQ_REFL, listTheory.datatype_list]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 SC R (f x) (f y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR @ Vf Vx @ Vf Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ SC VR Vx Vy @ @ @ C$relation$ SC VR @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 SC R (f x) (f y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_MONOTONE, boolTheory.BOTH_FORALL_OR_THM, relationTheory.SC_DEF, boolTheory.OR_CONG, relationTheory.RTC_cases]", "reward": 5}]], "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c a ++ c \u21d4 b \u227c c": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ @ C$list$ APPEND Va Vc @ @ C$list$ isPREFIX Vb Vc"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c a ++ c \u21d4 b \u227c c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb @ @ C$list$ APPEND C$list$ NIL Vc @ @ C$list$ isPREFIX Vb Vc"}, "plain": {"assumptions": [], "goal": "\u2200(b :\u03b1 list) (c :\u03b1 list). ([] :\u03b1 list) \u29fa b \u227c ([] :\u03b1 list) \u29fa c \u21d4 b \u227c c"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ @ C$list$ APPEND Va Vc @ @ C$list$ isPREFIX Vb Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vc @ @ C$list$ isPREFIX Vb Vc"}, "plain": {"assumptions": ["\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c a \u29fa c \u21d4 b \u227c c"], "goal": "\u2200(h :\u03b1) (b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c h::a \u29fa c \u21d4 b \u227c c"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ @ C$list$ APPEND Va Vc @ @ C$list$ isPREFIX Vb Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vc @ @ C$list$ isPREFIX Vb Vc"}, "plain": {"assumptions": ["\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c a \u29fa c \u21d4 b \u227c c"], "goal": "\u2200(h :\u03b1) (b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c h::a \u29fa c \u21d4 b \u227c c"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_LIFT2_def, listTheory.WF_SHORTLEX_same_lengths, listTheory.ZIP_DROP, listTheory.LENGTH_TL, listTheory.MEM_FILTER]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.APPEND_EQ_SELF, listTheory.IMAGE_EL_count_LENGTH, listTheory.NULL_FILTER, listTheory.ZIP_DROP, listTheory.adjacent_EL]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DEF, boolTheory.itself_induction, boolTheory.EXISTS_SIMP, boolTheory.NOT_EXISTS_THM, pred_setTheory.SUBSET_applied]", "reward": 5}]], "LIST_REL (P :\u03b1 -> \u03b2 -> bool) (GENLIST (f :num -> \u03b1) (l :num)) (GENLIST (g :num -> \u03b2) l) \u21d4 \u2200(i :num). i < l \u21d2 P (f i) (g i)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ LIST_REL VP @ @ C$list$ GENLIST Vf Vl @ @ C$list$ GENLIST Vg Vl @ C$bool$ ! | Vi @ @ C$min$ ==> @ @ C$prim_rec$ < Vi Vl @ @ VP @ Vf Vi @ Vg Vi"}, "plain": {"assumptions": [], "goal": "LIST_REL (P :\u03b1 -> \u03b2 -> bool) (GENLIST (f :num -> \u03b1) (l :num)) (GENLIST (g :num -> \u03b2) l) \u21d4 \u2200(i :num). i < l \u21d2 P (f i) (g i)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_FORALL_OR_THM, listTheory.LIST_TO_SET_FILTER, listTheory.APPEND_11_LENGTH, listTheory.SNOC_11, listTheory.LIST_REL_EL_EQN]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 DROP n l = EL n l::DROP (SUC n) l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 DROP n l = EL n l::DROP (SUC n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ DROP Vn C$list$ NIL @ @ C$list$ CONS @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ DROP @ C$num$ SUC Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). n < LENGTH ([] :\u03b1 list) \u21d2 DROP n ([] :\u03b1 list) = EL n ([] :\u03b1 list)::DROP (SUC n) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 DROP n l = EL n l::DROP (SUC n) l"], "goal": "\u2200(h :\u03b1) (n :num). n < LENGTH (h::(l :\u03b1 list)) \u21d2 DROP n (h::l) = EL n (h::l)::DROP (SUC n) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 DROP n l = EL n l::DROP (SUC n) l"], "goal": "\u2200(h :\u03b1) (n :num). n < LENGTH (h::(l :\u03b1 list)) \u21d2 DROP n (h::l) = EL n (h::l)::DROP (SUC n) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDL, boolTheory.SELECT_REFL_2, listTheory.LENGTH, listTheory.LIST_GUARD_def, listTheory.oEL_DROP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC C$num$ 0 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 DROP n l = EL n l::DROP (SUC n) l"], "goal": "(0 :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 DROP (0 :num) (h::l) = EL (0 :num) (h::l)::DROP (SUC (0 :num)) (h::l)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 DROP n (h::l) = EL n (h::l)::DROP (SUC n) (h::l)", "\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 DROP n l = EL n l::DROP (SUC n) l"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 DROP (SUC n) (h::l) = EL (SUC n) (h::l)::DROP (SUC (SUC n)) (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl @ @ C$list$ DROP @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ C$num$ SUC @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 DROP n (h::l) = EL n (h::l)::DROP (SUC n) (h::l)", "\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 DROP n l = EL n l::DROP (SUC n) l"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 DROP (SUC n) (h::l) = EL (SUC n) (h::l)::DROP (SUC (SUC n)) (h::l)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LUPDATE_MAP, listTheory.FRONT_DEF, listTheory.MAP2_MAP, listTheory.LIST_BIND_MAP, listTheory.isPREFIX_NILR]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.LIST_EQ_REWRITE, listTheory.LENGTH_FRONT_CONS, listTheory.SWAP_REVERSE_SYM, listTheory.ALL_DISTINCT_ZIP, listTheory.all_distinct_nub]", "reward": 5}]], "\u2200(M :\u03b2 # \u03b3) (M' :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1). M = M' \u2227 (\u2200(x :\u03b2) (y :\u03b3). M' = (x,y) \u21d2 f x y = (f' :\u03b2 -> \u03b3 -> \u03b1) x y) \u21d2 (pair_CASE M f :\u03b1) = (pair_CASE M' f' :\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VM' @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$pair$ , Vx Vy @ @ C$min$ = @ @ Vf Vx Vy @ @ Vf' Vx Vy @ @ C$min$ = @ @ C$pair$ pair_CASE VM Vf @ @ C$pair$ pair_CASE VM' Vf'"}, "plain": {"assumptions": [], "goal": "\u2200(M :\u03b2 # \u03b3) (M' :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1). M = M' \u2227 (\u2200(x :\u03b2) (y :\u03b3). M' = (x,y) \u21d2 f x y = (f' :\u03b2 -> \u03b3 -> \u03b1) x y) \u21d2 (pair_CASE M f :\u03b1) = (pair_CASE M' f' :\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.UNCURRY_DEF, pairTheory.pair_CASE_def, pairTheory.PROD_ALL_THM, pairTheory.SWAP_def, pairTheory.PAIR]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 reflexive R\u207a": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ reflexive VR @ C$relation$ reflexive @ C$relation$ TC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 reflexive R\u207a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.transitive_def, boolTheory.FUN_EQ_THM, boolTheory.itself_case_thm, relationTheory.TC_SUBSET]", "reward": 5}]], "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF y DIFF z = x DIFF z DIFF y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$pred_set$ DIFF @ @ C$pred_set$ DIFF Vx Vy Vz @ @ C$pred_set$ DIFF @ @ C$pred_set$ DIFF Vx Vz Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF y DIFF z = x DIFF z DIFF y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vy @ C$bool$ ~ @ @ C$bool$ IN Vx' Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vz @ C$bool$ ~ @ @ C$bool$ IN Vx' Vy"}, "plain": {"assumptions": [], "goal": "((x' :\u03b1) \u2208 (x :\u03b1 -> bool) \u2227 x' \u2209 (y :\u03b1 -> bool)) \u2227 x' \u2209 (z :\u03b1 -> bool) \u21d4 (x' \u2208 x \u2227 x' \u2209 z) \u2227 x' \u2209 y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DIFF, pred_setTheory.INTER_applied, pred_setTheory.DIFF_applied, pred_setTheory.EXTENSION, boolTheory.EXISTS_OR_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EQ_UNIV, pred_setTheory.IN_INTER, pred_setTheory.UNION_OVER_INTER, boolTheory.COND_ABS, pred_setTheory.SET_EQ_SUBSET]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 SC R (x :\u03b1) (y :\u03b1) \u21d2 SC Q x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VQ Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ SC VR Vx Vy @ @ @ C$relation$ SC VQ Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 SC R (x :\u03b1) (y :\u03b1) \u21d2 SC Q x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.SC_DEF, boolTheory.literal_case_CONG, boolTheory.AND2_THM, boolTheory.OR_INTRO_THM2, boolTheory.IMP_F_EQ_F]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (LASTN n l) = n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ LASTN Vn Vl Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (LASTN n l) = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.LASTN_def, arithmeticTheory.MIN_MAX_EQ, arithmeticTheory.MOD_P, boolTheory.FORALL_DEF, listTheory.LIST_IGNORE_BIND_def]", "reward": 5}]], "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 ELL (0 :num) l = LAST l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$rich_list$ ELL C$num$ 0 Vl @ C$list$ LAST Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 ELL (0 :num) l = LAST l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.APPEND_FRONT_LAST, rich_listTheory.IS_SUBLIST_REVERSE, rich_listTheory.ELL_compute, boolTheory.LEFT_OR_OVER_AND, boolTheory.literal_case_id]", "reward": 5}]], "(pair_CASE ((x :\u03b2),(y :\u03b3)) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = f x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pair$ pair_CASE @ @ C$pair$ , Vx Vy Vf @ @ Vf Vx Vy"}, "plain": {"assumptions": [], "goal": "(pair_CASE ((x :\u03b2),(y :\u03b3)) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = f x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pairTheory.pair_CASE_def, pairTheory.PAIR, pairTheory.PFORALL_THM, pairTheory.CLOSED_PAIR_EQ, pairTheory.PAIR_FST_SND_EQ]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2286 u \u21d2 s \u2286 u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ SUBSET Vt Vu @ @ C$pred_set$ SUBSET Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2286 u \u21d2 s \u2286 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_OR, pred_setTheory.SUBSET_applied, boolTheory.COND_RAND, boolTheory.RIGHT_OR_OVER_AND, boolTheory.TYPE_DEFINITION]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 \u2200(f :\u03b1 -> \u03b2). f x \u2208 IMAGE f s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vf @ @ C$bool$ IN @ Vf Vx @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 \u2200(f :\u03b1 -> \u03b2). f x \u2208 IMAGE f s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ Vs Vx"], "goal": "@ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx @ Vf Vx' @ Vs Vx'"}, "plain": {"assumptions": ["(s :\u03b1 -> bool) (x :\u03b1)"], "goal": "\u2203(x' :\u03b1). (f :\u03b1 -> \u03b2) (x :\u03b1) = f x' \u2227 (s :\u03b1 -> bool) x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.INTER_applied, pred_setTheory.IN_APP, boolTheory.OR_CONG, pred_setTheory.IMAGE_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.DIFF_EMPTY, pred_setTheory.DECOMPOSITION, pred_setTheory.DIFF_INTER2, boolTheory.literal_case_id, boolTheory.DATATYPE_TAG_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). s \u2286 x INSERT s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ INSERT Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). s \u2286 x INSERT s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_EXISTS_IMP_THM, pred_setTheory.DISJOINT_DEF, pred_setTheory.IN_INSERT, pred_setTheory.SUBSET_DEF, pred_setTheory.UNION_applied]", "reward": 5}]], "\u2200(l :\u03b1 list) (e :\u03b1) (y :\u03b1). MEM y (FRONT (e::l)) \u21d2 MEM y (e::l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve Vl @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (e :\u03b1) (y :\u03b1). MEM y (FRONT (e::l)) \u21d2 MEM y (e::l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (y :\u03b1). MEM y (FRONT [e]) \u21d2 MEM y [e]"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve Vl @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (y :\u03b1). MEM y (FRONT (e::(l :\u03b1 list))) \u21d2 MEM y (e::l)"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (y :\u03b1). MEM y (FRONT (e::h::(l :\u03b1 list))) \u21d2 MEM y (e::h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve Vl @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Ve @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (y :\u03b1). MEM y (FRONT (e::(l :\u03b1 list))) \u21d2 MEM y (e::l)"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (y :\u03b1). MEM y (FRONT (e::h::(l :\u03b1 list))) \u21d2 MEM y (e::h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SUM_ACC_SUM_LEM, listTheory.NULL_EQ, listTheory.LENGTH_EQ_SUM, boolTheory.literal_case_CONG, boolTheory.OR_IMP_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.SUM_IMAGE_LIST_TO_SET_upper_bound, listTheory.LIST_EQ_REWRITE, listTheory.EL, listTheory.SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST, listTheory.TAKE_0]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). (\u2200(n :num). n < LENGTH l1 \u2227 (R :\u03b1 -> \u03b1 -> bool) (EL n l1) (EL n l2) \u2227 R (EL n l2) (EL n l3) \u21d2 R (EL n l1) (EL n l3)) \u2227 LIST_REL R l1 l2 \u2227 LIST_REL R l2 l3 \u21d2 LIST_REL R l1 l3": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$bool$ /\\ @ @ VR @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2 @ @ VR @ @ C$list$ EL Vn Vl2 @ @ C$list$ EL Vn Vl3 @ @ VR @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl3 @ @ C$bool$ /\\ @ @ @ C$list$ LIST_REL VR Vl1 Vl2 @ @ @ C$list$ LIST_REL VR Vl2 Vl3 @ @ @ C$list$ LIST_REL VR Vl1 Vl3"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). (\u2200(n :num). n < LENGTH l1 \u2227 (R :\u03b1 -> \u03b1 -> bool) (EL n l1) (EL n l2) \u2227 R (EL n l2) (EL n l3) \u21d2 R (EL n l1) (EL n l3)) \u2227 LIST_REL R l1 l2 \u2227 LIST_REL R l2 l3 \u21d2 LIST_REL R l1 l3"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.APPEND_LENGTH_EQ, listTheory.LAST_APPEND_CONS, listTheory.EXISTS_NOT_EVERY, listTheory.LIST_REL_EL_EQN, listTheory.all_distinct_nub]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 \u00acEVERY (\u03bb(x :\u03b1). \u00acP x) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EXISTS VP Vl @ C$bool$ ~ @ @ C$list$ EVERY | Vx @ C$bool$ ~ @ VP Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EXISTS P l \u21d4 \u00acEVERY (\u03bb(x :\u03b1). \u00acP x) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_MAP2, listTheory.MAP_APPEND, listTheory.EVERY_MEM, listTheory.EXISTS_MEM, boolTheory.ABS_SIMP]", "reward": 5}]], "NULL ([] :\u03b1 list) \u2227 \u2200(h :\u03b1) (t :\u03b1 list). \u00acNULL (h::t)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$list$ NULL C$list$ NIL @ C$bool$ ! | Vh @ C$bool$ ! | Vt @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vt"}, "plain": {"assumptions": [], "goal": "NULL ([] :\u03b1 list) \u2227 \u2200(h :\u03b1) (t :\u03b1 list). \u00acNULL (h::t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.AND_CONG, listTheory.NULL_DEF, boolTheory.EXISTS_REFL, listTheory.list_size_def, boolTheory.LET_CONG]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). f \u2208 DFUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ C$bool$ IN Vf @ @ C$pred_set$ DFUNSET VP VQ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VP @ @ C$bool$ IN @ Vf Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b1 -> \u03b2 -> bool). f \u2208 DFUNSET P Q \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_ABS, pred_setTheory.FUNSET_applied, pred_setTheory.DFUNSET, pred_setTheory.IMAGE_INTER, pred_setTheory.NOT_EMPTY_SING]", "reward": 5}]], "\u2200(n1 :num) (n2 :num) (x :\u03b1). n1 < n2 \u21d2 EL n1 (REPLICATE n2 x) = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn1 @ C$bool$ ! | Vn2 @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vn1 Vn2 @ @ C$min$ = @ @ C$list$ EL Vn1 @ @ C$rich_list$ REPLICATE Vn2 Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(n1 :num) (n2 :num) (x :\u03b1). n1 < n2 \u21d2 EL n1 (REPLICATE n2 x) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_DEF, listTheory.LENGTH_DROP, listTheory.HD_GENLIST_COR, rich_listTheory.REPLICATE_GENLIST, listTheory.REV_REVERSE_LEM]", "reward": 5}]], "SET_TO_LIST {(x :\u03b1)} = [x]": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ SET_TO_LIST @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SET_TO_LIST {(x :\u03b1)} = [x]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FRONT_CONS, listTheory.SET_TO_LIST_THM, pred_setTheory.SUM_SET_UNION, pred_setTheory.INSERT_INTER, pred_setTheory.POW_DEF]", "reward": 5}]], "\u2200(n :num) (f :num -> \u03b1). (0 :num) < n \u21d2 HD (GENLIST f n) = f (0 :num)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf Vn @ Vf C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (f :num -> \u03b1). (0 :num) < n \u21d2 HD (GENLIST f n) = f (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 C$num$ 0 @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf C$num$ 0 @ Vf C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(f :num -> \u03b1). (0 :num) < (0 :num) \u21d2 HD (GENLIST f (0 :num)) = f (0 :num)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf Vn @ Vf C$num$ 0"], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn @ Vf C$num$ 0"}, "plain": {"assumptions": ["\u2200(f :num -> \u03b1). (0 :num) < (n :num) \u21d2 HD (GENLIST f n) = f (0 :num)"], "goal": "\u2200(f :num -> \u03b1). (0 :num) < SUC (n :num) \u21d2 HD (GENLIST f (SUC n)) = f (0 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 Vn @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf Vn @ Vf C$num$ 0"], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn @ @ C$min$ = @ C$list$ HD @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn @ Vf C$num$ 0"}, "plain": {"assumptions": ["\u2200(f :num -> \u03b1). (0 :num) < (n :num) \u21d2 HD (GENLIST f n) = f (0 :num)"], "goal": "\u2200(f :num -> \u03b1). (0 :num) < SUC (n :num) \u21d2 HD (GENLIST f (SUC n)) = f (0 :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, listTheory.SUM_IMAGE_LIST_TO_SET_upper_bound, boolTheory.LEFT_OR_EXISTS_THM, prim_recTheory.LESS_LEMMA1, numTheory.ZERO_REP_DEF]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_SPLIT1, boolTheory.NOT_FORALL_THM, listTheory.LENGTH_TL, listTheory.HD_GENLIST, listTheory.FLAT]", "reward": 5}]], "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = [(x :\u03b2)] \u21d4 \u2203(x0 :\u03b1). l = [x0] \u2227 x = f x0": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl @ @ C$list$ CONS Vx C$list$ NIL @ C$bool$ ? | Vx0 @ @ C$bool$ /\\ @ @ C$min$ = Vl @ @ C$list$ CONS Vx0 C$list$ NIL @ @ C$min$ = Vx @ Vf Vx0"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = [(x :\u03b2)] \u21d4 \u2203(x0 :\u03b1). l = [x0] \u2227 x = f x0"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_CONS, listTheory.MAP_EQ_NIL, listTheory.list_size_def, listTheory.list_size_def, listTheory.LIST_TO_SET_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive (RC R)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$relation$ reflexive @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive (RC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.trichotomous, relationTheory.RC_DEF, relationTheory.RC_DEF, relationTheory.reflexive_def]", "reward": 5}]], "\u2200(xs :\u03b1 list) (n :num) (y :\u03b1). oEL n xs = SOME y \u21d4 n < LENGTH xs \u2227 y = EL n xs": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ @ C$list$ oEL Vn Vxs @ C$option$ SOME Vy @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vxs @ @ C$min$ = Vy @ @ C$list$ EL Vn Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list) (n :num) (y :\u03b1). oEL n xs = SOME y \u21d4 n < LENGTH xs \u2227 y = EL n xs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SNOC_APPEND, listTheory.EVERY2_LUPDATE_same, boolTheory.EQ_IMP_THM, listTheory.oEL_THM, boolTheory.MONO_AND]", "reward": 5}]], "\u2200(f' :\u03b1 -> \u03b2 -> \u03b3) (f :\u03b1 -> \u03b2 -> \u03b3) (M' :\u03b1 # \u03b2) (M :\u03b1 # \u03b2). M = M' \u2227 (\u2200(x :\u03b1) (y :\u03b2). M' = (x,y) \u21d2 f x y = f' x y) \u21d2 UNCURRY f M = UNCURRY f' M'": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf' @ C$bool$ ! | Vf @ C$bool$ ! | VM' @ C$bool$ ! | VM @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$pair$ , Vx Vy @ @ C$min$ = @ @ Vf Vx Vy @ @ Vf' Vx Vy @ @ C$min$ = @ @ C$pair$ UNCURRY Vf VM @ @ C$pair$ UNCURRY Vf' VM'"}, "plain": {"assumptions": [], "goal": "\u2200(f' :\u03b1 -> \u03b2 -> \u03b3) (f :\u03b1 -> \u03b2 -> \u03b3) (M' :\u03b1 # \u03b2) (M :\u03b1 # \u03b2). M = M' \u2227 (\u2200(x :\u03b1) (y :\u03b2). M' = (x,y) \u21d2 f x y = f' x y) \u21d2 UNCURRY f M = UNCURRY f' M'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, pairTheory.UNCURRY_VAR, boolTheory.SELECT_REFL, pairTheory.PAIR, boolTheory.SELECT_REFL]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). MEM x (SET_TO_LIST s) \u21d4 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ SET_TO_LIST Vs @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). MEM x (SET_TO_LIST s) \u21d4 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.list_case_cong, listTheory.SET_TO_LIST_IN_MEM, pred_setTheory.BIGINTER_EMPTY, pred_setTheory.SING_DELETE]", "reward": 5}]], "{x | F} = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx C$bool$ F C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "{x | F} = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_IN_EMPTY, pred_setTheory.HAS_SIZE_0, pred_setTheory.GSPEC_ETA, pred_setTheory.SUM_SET_DEF, pred_setTheory.EMPTY_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list) (x :\u03b1). ELL (0 :num) (SNOC x l) = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$rich_list$ ELL C$num$ 0 @ @ C$list$ SNOC Vx Vl Vx"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (x :\u03b1). ELL (0 :num) (SNOC x l) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.ELL, listTheory.ITSET_eq_FOLDL_SET_TO_LIST, listTheory.FOLDL, listTheory.LUPDATE_NIL, listTheory.ALL_DISTINCT_ZIP_SWAP]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2) (l :\u03b3 list). FOLDL f e (MAP g l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2) (l :\u03b3 list). FOLDL f e (MAP g l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2). FOLDL f e (MAP g ([] :\u03b3 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e ([] :\u03b3 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2). FOLDL f e (MAP g (l :\u03b3 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e l"], "goal": "\u2200(h :\u03b3) (f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2). FOLDL f e (MAP g (h::(l :\u03b3 list))) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vg @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vx @ Vg Vy Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2). FOLDL f e (MAP g (l :\u03b3 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e l"], "goal": "\u2200(h :\u03b3) (f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (g :\u03b3 -> \u03b2). FOLDL f e (MAP g (h::(l :\u03b3 list))) = FOLDL (\u03bb(x :\u03b1) (y :\u03b3). f x (g y)) e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.COND_RATOR, listTheory.LENGTH_MAP2, boolTheory.literal_case_id, listTheory.LIST_REL_EVERY_ZIP, listTheory.last_drop]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.el_append3, listTheory.SINGL_SINGL_APPLY, boolTheory.CONJ_ASSOC, listTheory.UNIQUE_FILTER, listTheory.EXISTS_APPEND]", "reward": 5}]], "\u2200(P :\u03b1 # \u03b2 -> \u03b3). (\u03bb(p :\u03b1 # \u03b2). P p) = (\u03bb((p1 :\u03b1),(p2 :\u03b2)). P (p1,p2))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = | Vp @ VP Vp @ C$pair$ UNCURRY | Vp1 | Vp2 @ VP @ @ C$pair$ , Vp1 Vp2"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 # \u03b2 -> \u03b3). (\u03bb(p :\u03b1 # \u03b2). P p) = (\u03bb((p1 :\u03b1),(p2 :\u03b2)). P (p1,p2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.ELIM_UNCURRY, pairTheory.PAIR, boolTheory.EQ_TRANS, boolTheory.JRH_INDUCT_UTIL, pairTheory.CLOSED_PAIR_EQ]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (a :\u03b1). IS_SUFFIX l1 l2 \u21d2 IS_SUFFIX (a::l1) l2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl1 Vl2 @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ CONS Va Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (a :\u03b1). IS_SUFFIX l1 l2 \u21d2 IS_SUFFIX (a::l1) l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vl' @ @ C$min$ = @ @ C$list$ CONS Va @ @ C$list$ APPEND Vl Vl2 @ @ C$list$ APPEND Vl' Vl2"}, "plain": {"assumptions": [], "goal": "\u2203(l' :\u03b1 list). (a :\u03b1)::((l :\u03b1 list) \u29fa (l2 :\u03b1 list)) = l' \u29fa l2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_TAKE_EQ, rich_listTheory.IS_SUFFIX_APPEND, boolTheory.FUN_EQ_THM, listTheory.HD_DROP, rich_listTheory.OR_EL_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SET_TO_LIST_EMPTY, boolTheory.BOTH_EXISTS_AND_THM, listTheory.oEL_DROP, rich_listTheory.BUTLASTN_def, listTheory.DROP_cons]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2209 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vs Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, pred_setTheory.PAIR_IN_GSPEC_1, boolTheory.IMP_DISJ_THM, pred_setTheory.IN_DISJOINT, boolTheory.NOT_IMP]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). reflexive R \u21d2 reflexive (inv_image R f)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vf @ @ C$min$ ==> @ C$relation$ reflexive VR @ C$relation$ reflexive @ @ C$relation$ inv_image VR Vf"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). reflexive R \u21d2 reflexive (inv_image R f)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_CLAUSES, relationTheory.reflexive_def, relationTheory.reflexive_RC_identity, boolTheory.RIGHT_AND_OVER_OR, relationTheory.inv_image_def]", "reward": 5}]], "\u2200(s :\u03b1 list) (h :\u03b1) (t :\u03b1 list). IS_SUFFIX s (h::t) \u21d2 IS_SUFFIX s t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vh @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vs @ @ C$list$ CONS Vh Vt @ @ C$rich_list$ IS_SUFFIX Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 list) (h :\u03b1) (t :\u03b1 list). IS_SUFFIX s (h::t) \u21d2 IS_SUFFIX s t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.SPLITP_NIL_SND_EVERY, rich_listTheory.IS_SUFFIX_APPEND, listTheory.LAST_APPEND_CONS, boolTheory.PULL_EXISTS, boolTheory.RIGHT_AND_FORALL_THM]", "reward": 5}]], "\u00acNULL (l2 :\u03b1 list) \u2227 (n :num) = LENGTH (l1 :\u03b1 list) \u21d2 EL n (l1 ++ l2) = HD l2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ~ @ C$list$ NULL Vl2 @ @ C$min$ = Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ APPEND Vl1 Vl2 @ C$list$ HD Vl2"}, "plain": {"assumptions": [], "goal": "\u00acNULL (l2 :\u03b1 list) \u2227 (n :num) = LENGTH (l1 :\u03b1 list) \u21d2 EL n (l1 ++ l2) = HD l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL @ C$list$ LENGTH Vl1 @ @ C$list$ APPEND Vl1 Vl2 @ C$list$ HD Vl2"}, "plain": {"assumptions": ["\u00acNULL (l2 :\u03b1 list)"], "goal": "EL (LENGTH (l1 :\u03b1 list)) (l1 \u29fa (l2 :\u03b1 list)) = HD l2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FILTER_COND_REWRITE, listTheory.MAP2_MAP, boolTheory.SELECT_UNIQUE, listTheory.LIST_REL_SPLIT1, listTheory.list_case_compute]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.F_IMP, listTheory.EL_DROP, listTheory.splitAtPki_change_predicate, boolTheory.AND2_THM, listTheory.EL_APPEND_EQN]", "reward": 5}]], "\u2200(y :\u03b1) (x :\u03b1) (l :\u03b1 list). MEM y (SNOC x l) \u21d4 y = x \u2228 MEM y l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ SNOC Vx Vl @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b1) (x :\u03b1) (l :\u03b1 list). MEM y (SNOC x l) \u21d4 y = x \u2228 MEM y l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.RIGHT_OR_EXISTS_THM, listTheory.ALL_DISTINCT_REVERSE, listTheory.LIST_TO_SET_SNOC, listTheory.FILTER_EQ_NIL, listTheory.INDEX_OF_def]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (n :num) (x :\u03b1). n < LENGTH l1 \u21d2 LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vn @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ @ @ C$list$ LUPDATE Vx Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ @ C$list$ LUPDATE Vx Vn Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (n :num) (x :\u03b1). n < LENGTH l1 \u21d2 LUPDATE x n (l1 ++ l2) = LUPDATE x n l1 ++ l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FILTER_APPEND_DISTRIB, listTheory.GENLIST, listTheory.DISJOINT_GENLIST_PLUS, listTheory.MEM_MAP, listTheory.lupdate_append]", "reward": 5}]], "nsnd (n :num) \u2264 n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$arithmetic$ <= @ C$numpair$ nsnd Vn Vn"}, "plain": {"assumptions": [], "goal": "nsnd (n :num) \u2264 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.INV_PRE_EQ, arithmeticTheory.FUNPOW_1, arithmeticTheory.DIVMOD_ID, numpairTheory.nsnd_def, arithmeticTheory.SUB_EQUAL_0]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R\u1d40 \u21d4 symmetric R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ symmetric @ C$relation$ inv VR @ C$relation$ symmetric VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric R\u1d40 \u21d4 symmetric R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_EXISTS_THM, boolTheory.NOT_IMP, relationTheory.symmetric_def, relationTheory.inv_DEF, relationTheory.RC_REFLEXIVE]", "reward": 5}]], "\u2200(l :\u03b1 list). NULL l \u21d4 LENGTH l = (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ NULL Vl @ @ C$min$ = @ C$list$ LENGTH Vl C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). NULL l \u21d4 LENGTH l = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM, listTheory.list_Axiom_old, listTheory.NULL_EQ, boolTheory.SELECT_REFL, listTheory.LENGTH_NIL]", "reward": 5}]], "(\u2200(P :\u03b1 -> bool). PREFIX P ([] :\u03b1 list) = ([] :\u03b1 list)) \u2227 \u2200(P :\u03b2 -> bool) (x :\u03b2) (l :\u03b2 list). PREFIX P (x::l) = if P x then x::PREFIX P l else ([] :\u03b2 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | VP @ @ C$min$ = @ @ C$rich_list$ PREFIX VP C$list$ NIL C$list$ NIL @ C$bool$ ! | VP @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$rich_list$ PREFIX VP @ @ C$list$ CONS Vx Vl @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx @ @ C$rich_list$ PREFIX VP Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(\u2200(P :\u03b1 -> bool). PREFIX P ([] :\u03b1 list) = ([] :\u03b1 list)) \u2227 \u2200(P :\u03b2 -> bool) (x :\u03b2) (l :\u03b2 list). PREFIX P (x::l) = if P x then x::PREFIX P l else ([] :\u03b2 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.REVERSE_FOLDL, rich_listTheory.PREFIX_FOLDR, listTheory.LIST_NOT_EQ, rich_listTheory.BUTLASTN_def, rich_listTheory.TAKE]", "reward": 5}]], "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INL x :\u03b1 + \u03b2) \u2208 (t :\u03b1 + \u03b2 -> bool)) \u21d2 INJ (INL :\u03b1 -> \u03b1 + \u03b2) s t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ C$sum$ INL Vx Vt @ @ @ C$pred_set$ INJ C$sum$ INL Vs Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (INL x :\u03b1 + \u03b2) \u2208 (t :\u03b1 + \u03b2 -> bool)) \u21d2 INJ (INL :\u03b1 -> \u03b1 + \u03b2) s t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_IFF, pred_setTheory.COMPONENT, pred_setTheory.BIGUNION_SING, boolTheory.UNWIND_FORALL_THM1, pred_setTheory.BIGINTER_SING]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 INJ f s (IMAGE f s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ @ @ C$pred_set$ INJ Vf Vs @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 INJ f s (IMAGE f s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.DIFF_DEF, pred_setTheory.IMAGE_IN, boolTheory.literal_case_CONG, pred_setTheory.INJ_IFF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). INFINITE s \u21d4 \u2200(t :\u03b1 -> bool). FINITE t \u21d2 t \u2286 s \u21d2 t \u2282 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ~ @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ C$pred_set$ FINITE Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vt Vs @ @ C$pred_set$ PSUBSET Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). INFINITE s \u21d4 \u2200(t :\u03b1 -> bool). FINITE t \u21d2 t \u2286 s \u21d2 t \u2282 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.PSUBSET_DEF, pred_setTheory.INJ_IMAGE, pred_setTheory.EQ_SUBSET_SUBSET, boolTheory.EQ_SYM_EQ, boolTheory.RES_FORALL_CONG]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool) (l :\u03b2 list). FOLDL f e (FILTER P l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool) (l :\u03b2 list). FOLDL f e (FILTER P l) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool). FOLDL f e (FILTER P ([] :\u03b2 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e ([] :\u03b2 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool). FOLDL f e (FILTER P (l :\u03b2 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e l"], "goal": "\u2200(h :\u03b2) (f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool). FOLDL f e (FILTER P (h::(l :\u03b2 list))) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | VP @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Ve @ @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ @ C$bool$ COND @ VP Vy @ @ Vf Vx Vy Vx Ve @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool). FOLDL f e (FILTER P (l :\u03b2 list)) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e l"], "goal": "\u2200(h :\u03b2) (f :\u03b1 -> \u03b2 -> \u03b1) (e :\u03b1) (P :\u03b2 -> bool). FOLDL f e (FILTER P (h::(l :\u03b2 list))) = FOLDL (\u03bb(x :\u03b1) (y :\u03b2). if P y then f x y else x) e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LLEX_total, listTheory.EXISTS_APPEND, listTheory.NOT_EXISTS, boolTheory.RIGHT_AND_FORALL_THM, listTheory.SHORTLEX_total]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.splitAtPki_EQN, listTheory.FOLDR_CONS, listTheory.LLEX_MONO, boolTheory.PEIRCE, listTheory.ALL_DISTINCT_REVERSE]", "reward": 5}]], "((a :\u03b1),(b :\u03b2)) \u2208 {((x :\u03b1),y) | (P :\u03b2 -> bool) y} \u21d4 P b \u2227 a = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN @ @ C$pair$ , Va Vb @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , @ @ C$pair$ , Vx Vy @ VP Vy @ @ C$bool$ /\\ @ VP Vb @ @ C$min$ = Va Vx"}, "plain": {"assumptions": [], "goal": "((a :\u03b1),(b :\u03b2)) \u2208 {((x :\u03b1),y) | (P :\u03b2 -> bool) y} \u21d4 P b \u2227 a = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.ELIM_UNCURRY, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.IN_APP, pairTheory.FST, boolTheory.EQ_IMP_THM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). (\u2200(x :\u03b1). P x \u21d2 Q x) \u21d2 \u2200(l :\u03b1 list). EVERY P l \u21d2 EVERY Q l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VQ Vx @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VQ Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). (\u2200(x :\u03b1). P x \u21d2 Q x) \u21d2 \u2200(l :\u03b1 list). EVERY P l \u21d2 EVERY Q l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_SIMP, listTheory.LIST_REL_ind, boolTheory.SELECT_UNIQUE, listTheory.EVERY_MEM, listTheory.MAP2]", "reward": 5}]], "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = b \u21d4 a = f b": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ C$relation$ INVOL Vf @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ @ C$min$ = @ Vf Va Vb @ @ C$min$ = Va @ Vf Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = b \u21d4 a = f b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_IMP_THM, relationTheory.INVOL, boolTheory.CONJ_COMM, relationTheory.WF_inv_image, boolTheory.IMP_CONG]", "reward": 5}]], "BIGUNION (IMAGE (f :\u03b2 -> \u03b1 -> bool) (set (ls :\u03b2 list))) \u2286 (s :\u03b1 -> bool) \u21d4 \u2200(x :\u03b2). MEM x ls \u21d2 f x \u2286 s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ SUBSET @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE Vf @ C$list$ LIST_TO_SET Vls Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ @ C$pred_set$ SUBSET @ Vf Vx Vs"}, "plain": {"assumptions": [], "goal": "BIGUNION (IMAGE (f :\u03b2 -> \u03b1 -> bool) (set (ls :\u03b2 list))) \u2286 (s :\u03b1 -> bool) \u21d4 \u2200(x :\u03b2). MEM x ls \u21d2 f x \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vs @ Vf Vx @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' @ Vf Vx @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (\u2203(s :\u03b1 -> bool). x \u2208 s \u2227 \u2203(x :\u03b2). s = (f :\u03b2 -> \u03b1 -> bool) x \u2227 MEM x (ls :\u03b2 list)) \u21d2 x \u2208 (s :\u03b1 -> bool)) \u21d4 \u2200(x :\u03b2). MEM x ls \u21d2 \u2200(x' :\u03b1). x' \u2208 f x \u21d2 x' \u2208 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.BIJ_support, pred_setTheory.FINITE_BIGUNION, pred_setTheory.FINITE_PSUBSET_UNIV, pred_setTheory.SUBSET_DEF, pred_setTheory.is_measure_maximal_SING]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_FORALL_THM, pred_setTheory.ITSET_EMPTY, listTheory.EXISTS_MEM, boolTheory.RIGHT_AND_OVER_OR, listTheory.GENLIST_GENLIST_AUX]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2) (x :\u03b1). f \u2208 FUNSET s t \u2227 x \u2208 s \u21d2 f x \u2208 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET Vs Vt @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2) (x :\u03b1). f \u2208 FUNSET s t \u2227 x \u2208 s \u21d2 f x \u2208 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.BOTH_FORALL_OR_THM, pred_setTheory.MEMBER_NOT_EMPTY, pred_setTheory.NOT_SING_EMPTY, pred_setTheory.IN_FUNSET, pred_setTheory.INJ_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). \u2203(fn :\u03b1 # \u03b2 -> \u03b3). \u2200(x :\u03b1) (y :\u03b2). fn (x,y) = f x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ? | Vfn @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ Vfn @ @ C$pair$ , Vx Vy @ @ Vf Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). \u2203(fn :\u03b1 # \u03b2 -> \u03b3). \u2200(x :\u03b1) (y :\u03b2). fn (x,y) = f x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pairTheory.UNCURRY_DEF, boolTheory.FORALL_SIMP, pairTheory.PAIR_EQ, boolTheory.NOT_IMP, boolTheory.IMP_F]", "reward": 5}]], "\u2200(l :num list). SUM (REVERSE l) = SUM l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE Vl @ C$list$ SUM Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :num list). SUM (REVERSE l) = SUM l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE C$list$ NIL @ C$list$ SUM C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUM (REVERSE ([] :num list)) = SUM ([] :num list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE Vl @ C$list$ SUM Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ C$list$ SUM @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (REVERSE (l :num list)) = SUM l"], "goal": "\u2200(h :num). SUM (REVERSE (h::(l :num list))) = SUM (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE Vl @ C$list$ SUM Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl @ C$list$ SUM @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (REVERSE (l :num list)) = SUM l"], "goal": "\u2200(h :num). SUM (REVERSE (h::(l :num list))) = SUM (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SUM_ACC_SUM_LEM, listTheory.EL_LENGTH_dropWhile_REVERSE, listTheory.LIST_IGNORE_BIND_def, listTheory.MAP_TAKE, listTheory.GENLIST_CONG]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.SUM_APPEND, listTheory.FRONT_DEF, listTheory.MAP_APPEND, listTheory.MAP_DROP, listTheory.FRONT_DEF]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEXISTS P l \u21d4 EVERY ($\u00ac \u2218 P) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ C$bool$ ~ @ @ C$list$ EXISTS VP Vl @ @ C$list$ EVERY @ @ C$combin$ o C$bool$ ~ VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). \u00acEXISTS P l \u21d4 EVERY ($\u00ac \u2218 P) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_NOT_EXISTS, listTheory.MAP_APPEND, listTheory.EVERY_MEM, listTheory.EXISTS_MEM, boolTheory.literal_case_RATOR]", "reward": 5}]], "\u2200(xs :\u03b1 option list) (n :num) (f :\u03b1 -> \u03b2) (h :\u03b1). LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) = MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ C$bool$ ! | Vf @ C$bool$ ! | Vh @ @ C$min$ = @ @ @ C$list$ LUPDATE @ C$option$ SOME @ Vf Vh Vn @ @ C$list$ MAP @ C$option$ OPTION_MAP Vf Vxs @ @ C$list$ MAP @ C$option$ OPTION_MAP Vf @ @ @ C$list$ LUPDATE @ C$option$ SOME Vh Vn Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 option list) (n :num) (f :\u03b1 -> \u03b2) (h :\u03b1). LUPDATE (SOME (f h)) n (MAP (OPTION_MAP f) xs) = MAP (OPTION_MAP f) (LUPDATE (SOME h) n xs)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_FILTER_LEQ_MONO, listTheory.LUPDATE_MAP, listTheory.GENLIST_APPEND, listTheory.LIST_BIND_MAP, boolTheory.COND_CLAUSES]", "reward": 5}]], "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vp @ VP Vp @ C$bool$ ! | Vp_1 @ C$bool$ ! | Vp_2 @ VP @ @ C$pair$ , Vp_1 Vp_2"}, "plain": {"assumptions": [], "goal": "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2200(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.BOTH_FORALL_OR_THM, boolTheory.FORALL_DEF, pairTheory.PAIR, boolTheory.MONO_NOT, boolTheory.SELECT_REFL_2]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). P \u2286 Q \u21d2 \u2200(x :\u03b1). x \u2208 P \u21d2 x \u2208 Q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ ==> @ @ C$pred_set$ SUBSET VP VQ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VP @ @ C$bool$ IN Vx VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). P \u2286 Q \u21d2 \u2200(x :\u03b1). x \u2208 P \u21d2 x \u2208 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FORALL_AND_THM, boolTheory.itself_Axiom, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_APP, boolTheory.IMP_F]", "reward": 5}]], "\u2200(p :\u03b1 # \u03b2) (q :\u03b1 # \u03b2). p = q \u21d4 FST p = FST q \u2227 SND p = SND q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ @ C$min$ = @ @ C$min$ = Vp Vq @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vp @ C$pair$ FST Vq @ @ C$min$ = @ C$pair$ SND Vp @ C$pair$ SND Vq"}, "plain": {"assumptions": [], "goal": "\u2200(p :\u03b1 # \u03b2) (q :\u03b1 # \u03b2). p = q \u21d4 FST p = FST q \u2227 SND p = SND q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_FORALL_THM, pairTheory.PAIR, boolTheory.OR_INTRO_THM2, boolTheory.DISJ_COMM, boolTheory.IMP_CONJ_THM]", "reward": 5}]], "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). SEG n m (SNOC x l) = SEG n m l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vn Vm @ C$list$ LENGTH Vl @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$rich_list$ SEG Vn Vm @ @ C$list$ SNOC Vx Vl @ @ @ C$rich_list$ SEG Vn Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 \u2200(x :\u03b1). SEG n m (SNOC x l) = SEG n m l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN, listTheory.splitAtPki_EQN, rich_listTheory.SEG_APPEND1, listTheory.INDEX_OF_def, rich_listTheory.MAP_FOLDL]", "reward": 5}]], "(x :\u03b1) \u2208 RDOM (R :\u03b1 -> \u03b2 -> bool) \u21d4 \u2203(y :\u03b2). R x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$relation$ RDOM VR @ C$bool$ ? | Vy @ @ VR Vx Vy"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 RDOM (R :\u03b1 -> \u03b2 -> bool) \u21d4 \u2203(y :\u03b2). R x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.SWAP_FORALL_THM, boolTheory.IN_DEF, relationTheory.O_DEF, relationTheory.RDOM_DEF, relationTheory.TC_CASES2_E]", "reward": 5}]], "IDEM (SC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ IDEM C$relation$ SC"}, "plain": {"assumptions": [], "goal": "IDEM (SC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.IDEM, relationTheory.irreflexive_inv, relationTheory.reflexive_def, relationTheory.SC_IDEM, relationTheory.reflexive_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). RC (RC R) = RC R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ RC @ C$relation$ RC VR @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). RC (RC R) = RC R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.SC_SYMMETRIC, relationTheory.reflexive_RC_identity, boolTheory.EQ_REFL, relationTheory.RTC_REFL, relationTheory.RC_REFLEXIVE]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). RC R x y \u21d2 f x = f y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$min$ = @ Vf Vx @ Vf Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RC VR Vx Vy @ @ C$min$ = @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). RC R x y \u21d2 f x = f y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_id, relationTheory.RC_DEF, boolTheory.FUN_EQ_THM, relationTheory.reflexive_RTC, relationTheory.RTC_INDUCT]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list) (f :\u03b1 -> \u03b2 -> bool). LIST_REL f l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 EVERY (UNCURRY f) (ZIP (l1,l2))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vf @ @ C$min$ = @ @ @ C$list$ LIST_REL Vf Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl1 @ C$list$ LENGTH Vl2 @ @ C$list$ EVERY @ C$pair$ UNCURRY Vf @ C$list$ ZIP @ @ C$pair$ , Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b2 list) (f :\u03b1 -> \u03b2 -> bool). LIST_REL f l1 l2 \u21d4 LENGTH l1 = LENGTH l2 \u2227 EVERY (UNCURRY f) (ZIP (l1,l2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LET_RATOR, listTheory.list_case_cong, listTheory.LIST_REL_EVERY_ZIP, boolTheory.BOTH_EXISTS_AND_THM, boolTheory.itself_TY_DEF]", "reward": 5}]], "\u2200(L :\u03b1 list). LENGTH L = LEN L (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VL @ @ C$min$ = @ C$list$ LENGTH VL @ @ C$list$ LEN VL C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(L :\u03b1 list). LENGTH L = LEN L (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.list_INDUCT0, listTheory.LEN_LENGTH_LEM, listTheory.MEM_MAP, boolTheory.EXISTS_REFL, listTheory.REVERSE_SNOC]", "reward": 5}]], "(([] :\u03b1 list) \u227c (l :\u03b1 list) \u21d4 T) \u2227 ((h :\u03b1)::(t :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 F) \u2227 ((h1 :\u03b1)::(t1 :\u03b1 list) \u227c (h2 :\u03b1)::(t2 :\u03b1 list) \u21d4 h1 = h2 \u2227 t1 \u227c t2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ isPREFIX C$list$ NIL Vl C$bool$ T @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vt C$list$ NIL C$bool$ F @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh1 Vt1 @ @ C$list$ CONS Vh2 Vt2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ C$list$ isPREFIX Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "(([] :\u03b1 list) \u227c (l :\u03b1 list) \u21d4 T) \u2227 ((h :\u03b1)::(t :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 F) \u2227 ((h1 :\u03b1)::(t1 :\u03b1 list) \u227c (h2 :\u03b1)::(t2 :\u03b1 list) \u21d4 h1 = h2 \u2227 t1 \u227c t2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.isPREFIX, listTheory.INJ_MAP_EQ_IFF, listTheory.FRONT_DEF, listTheory.EXISTS_MEM, listTheory.list_case_def]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 (\u2205 :\u03b1 -> bool))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$pred_set$ PSUBSET Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). \u00ac(s \u2282 (\u2205 :\u03b1 -> bool))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, pred_setTheory.PSUBSET_DEF, pred_setTheory.EMPTY_SUBSET, boolTheory.ABS_SIMP, pred_setTheory.SET_EQ_SUBSET]", "reward": 5}]], "\u2200(p :\u03b1 # \u03b2) (p' :\u03b1 # \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). p = p' \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (P x \u21d4 P' x)) \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (Q y \u21d4 Q' y)) \u21d2 (PROD_ALL P Q p \u21d4 PROD_ALL P' Q' p')": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vp' @ C$bool$ ! | VP @ C$bool$ ! | VP' @ C$bool$ ! | VQ @ C$bool$ ! | VQ' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vp Vp' @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = Vp' @ @ C$pair$ , Vx Vy @ @ C$min$ = @ VP Vx @ VP' Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = Vp' @ @ C$pair$ , Vx Vy @ @ C$min$ = @ VQ Vy @ VQ' Vy @ @ C$min$ = @ @ @ C$pair$ PROD_ALL VP VQ Vp @ @ @ C$pair$ PROD_ALL VP' VQ' Vp'"}, "plain": {"assumptions": [], "goal": "\u2200(p :\u03b1 # \u03b2) (p' :\u03b1 # \u03b2) (P :\u03b1 -> bool) (P' :\u03b1 -> bool) (Q :\u03b2 -> bool) (Q' :\u03b2 -> bool). p = p' \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (P x \u21d4 P' x)) \u2227 (\u2200(x :\u03b1) (y :\u03b2). p' = (x,y) \u21d2 (Q y \u21d4 Q' y)) \u21d2 (PROD_ALL P Q p \u21d4 PROD_ALL P' Q' p')"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vp' @ C$pair$ FST @ @ C$pair$ , Vx Vy @ @ C$min$ = @ C$pair$ SND Vp' @ C$pair$ SND @ @ C$pair$ , Vx Vy @ @ C$min$ = @ VQ Vy @ VQ' Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vp' @ C$pair$ FST @ @ C$pair$ , Vx Vy @ @ C$min$ = @ C$pair$ SND Vp' @ C$pair$ SND @ @ C$pair$ , Vx Vy @ @ C$min$ = @ VP Vx @ VP' Vx", "@ @ C$min$ = @ C$pair$ SND Vp @ C$pair$ SND Vp'", "@ @ C$min$ = @ C$pair$ FST Vp @ C$pair$ FST Vp'"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ VP @ C$pair$ FST Vp' @ VQ @ C$pair$ SND Vp' @ @ C$bool$ /\\ @ VP' @ C$pair$ FST Vp' @ VQ' @ C$pair$ SND Vp'"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b2). FST (p' :\u03b1 # \u03b2) = FST (x,y) \u2227 SND p' = SND (x,y) \u21d2 ((Q :\u03b2 -> bool) y \u21d4 (Q' :\u03b2 -> bool) y)", "\u2200(x :\u03b1) (y :\u03b2). FST (p' :\u03b1 # \u03b2) = FST (x,y) \u2227 SND p' = SND (x,y) \u21d2 ((P :\u03b1 -> bool) x \u21d4 (P' :\u03b1 -> bool) x)", "SND (p :\u03b1 # \u03b2) = SND (p' :\u03b1 # \u03b2)", "FST (p :\u03b1 # \u03b2) = FST (p' :\u03b1 # \u03b2)"], "goal": "(P :\u03b1 -> bool) (FST (p' :\u03b1 # \u03b2)) \u2227 (Q :\u03b2 -> bool) (SND p') \u21d4 (P' :\u03b1 -> bool) (FST p') \u2227 (Q' :\u03b2 -> bool) (SND p')"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.NOT_DEF, boolTheory.ONE_ONE_DEF, pairTheory.PROD_ALL_def, pairTheory.PROD_ALL_THM, pairTheory.PAIR_FST_SND_EQ]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pairTheory.LAMBDA_PROD, boolTheory.IMP_F, boolTheory.LEFT_FORALL_OR_THM, pairTheory.PAIR, pairTheory.PAIR_FST_SND_EQ]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). SURJ f s t \u2227 SURJ g t u \u21d2 SURJ (g \u2218 f) s u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$pred_set$ SURJ Vf Vs Vt @ @ @ C$pred_set$ SURJ Vg Vt Vu @ @ @ C$pred_set$ SURJ @ @ C$combin$ o Vg Vf Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). SURJ f s t \u2227 SURJ g t u \u21d2 SURJ (g \u2218 f) s u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN @ Vg Vx Vu @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vu @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vt @ @ C$min$ = @ Vg Vy Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vu @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vg @ Vf Vy Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). ((\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2200(x :\u03b2). x \u2208 t \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 f y = x) \u2227 (\u2200(x :\u03b2). x \u2208 t \u21d2 g x \u2208 u) \u2227 (\u2200(x :\u03b3). x \u2208 u \u21d2 \u2203(y :\u03b2). y \u2208 t \u2227 g y = x) \u21d2 \u2200(x :\u03b3). x \u2208 u \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 g (f y) = x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.itself_Axiom, pred_setTheory.IMAGE_SING, pred_setTheory.INSERT_DIFF, pred_setTheory.SURJ_DEF, boolTheory.ITSELF_UNIQUE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EMPTY_SING, pred_setTheory.INSERT_SING_UNION, boolTheory.FUN_EQ_THM, pred_setTheory.INJ_EXTEND, pred_setTheory.SING]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n l = TAKE (LENGTH l \u2212 n) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN Vn Vl @ @ C$list$ TAKE @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n l = TAKE (LENGTH l \u2212 n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.TAKE_BUTLASTN, rich_listTheory.DROP_APPEND1, listTheory.IMP_EVERY_LUPDATE, listTheory.TAKE_0, arithmeticTheory.FUNPOW_ADD]", "reward": 5}]], "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_SND l) = LENGTH l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ LENGTH @ C$rich_list$ UNZIP_SND Vl @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_SND l) = LENGTH l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_ZIP_MIN, listTheory.ALL_DISTINCT_SING, listTheory.REV_DEF, listTheory.FIND_def, rich_listTheory.UNZIP_SND_DEF]", "reward": 5}]], "{x | (P :\u03b1 -> bool) x} = P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VP Vx VP"}, "plain": {"assumptions": [], "goal": "{x | (P :\u03b1 -> bool) x} = P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.EXTENSION, pairTheory.COMMA_DEF, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u2203(f :num -> \u03b1). BIJ f \ud835\udd4c(:num) s) \u21d2 countable s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$bool$ ? | Vf @ @ @ C$pred_set$ BIJ Vf C$pred_set$ UNIV Vs @ C$pred_set$ countable Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2203(f :num -> \u03b1). BIJ f \ud835\udd4c(:num) s) \u21d2 countable s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vs @ C$bool$ ?! | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx C$pred_set$ UNIV @ @ C$min$ = Vy @ Vf Vx", "@ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET C$pred_set$ UNIV Vs"], "goal": "@ C$bool$ ? | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vn @ @ C$min$ = @ Vf Vn Vx"}, "plain": {"assumptions": ["\u2200(y :\u03b1). y \u2208 (s :\u03b1 -> bool) \u21d2 \u2203!(x :num). x \u2208 \ud835\udd4c(:num) \u2227 y = (f :num -> \u03b1) x", "(f :num -> \u03b1) \u2208 ((\ud835\udd4c(:num) \u2192 (s :\u03b1 -> bool)) :(num -> \u03b1) -> bool)"], "goal": "\u2203(f :num -> \u03b1). \u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 \u2203(n :num). f n = x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_DIFF, pred_setTheory.COUNTABLE_ALT, pred_setTheory.BIJ_ALT, pred_setTheory.BIJ_ALT, pred_setTheory.DISJOINT_IMAGE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_EXISTS_IMP_THM, pred_setTheory.PHP, boolTheory.IMP_CONG, pred_setTheory.BIJ_EMPTY, pred_setTheory.SCHROEDER_CLOSED]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT x INSERT s = x INSERT s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ INSERT Vx Vs @ @ C$pred_set$ INSERT Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x INSERT x INSERT s = x INSERT s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(x' :\u03b1) = (x :\u03b1) \u2228 x' = x \u2228 x' \u2208 (s :\u03b1 -> bool) \u21d4 x' = x \u2228 x' \u2208 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, boolTheory.TYPE_DEFINITION_THM, boolTheory.itself_case_thm, pred_setTheory.SET_EQ_SUBSET, pred_setTheory.IN_INSERT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.SELECT_REFL, pred_setTheory.DIFF_applied, pred_setTheory.IN_DISJOINT, pred_setTheory.SPECIFICATION, pred_setTheory.EMPTY_NOT_UNIV]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (REST s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$bool$ ~ @ C$pred_set$ FINITE Vs @ C$bool$ ~ @ C$pred_set$ FINITE @ C$pred_set$ REST Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (REST s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.FINITE_COUNT, pred_setTheory.DIFF_UNION, pred_setTheory.BIJ_EMPTY, pred_setTheory.FINITE_REST_EQ]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set l1 \u222a set l2 = set (l1 ++ l2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$pred_set$ UNION @ C$list$ LIST_TO_SET Vl1 @ C$list$ LIST_TO_SET Vl2 @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set l1 \u222a set l2 = set (l1 ++ l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_APPEND, boolTheory.EXISTS_OR_THM, boolTheory.RES_EXISTS_FALSE, boolTheory.OR_CONG, listTheory.LENGTH_UNZIP]", "reward": 5}]], "WF (R :\u03b1 -> \u03b1 -> bool)\u207a \u21d4 WF R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ WF @ C$relation$ TC VR @ C$relation$ WF VR"}, "plain": {"assumptions": [], "goal": "WF (R :\u03b1 -> \u03b1 -> bool)\u207a \u21d4 WF R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | VB @ @ C$min$ ==> @ C$bool$ ? | Vw @ VB Vw @ C$bool$ ? | Vmin @ @ C$bool$ /\\ @ VB Vmin @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ @ C$relation$ TC VR Vb Vmin @ C$bool$ ~ @ VB Vb @ C$bool$ ! | VB @ @ C$min$ ==> @ C$bool$ ? | Vw @ VB Vw @ C$bool$ ? | Vmin @ @ C$bool$ /\\ @ VB Vmin @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ VR Vb Vmin @ C$bool$ ~ @ VB Vb"}, "plain": {"assumptions": [], "goal": "(\u2200(B :\u03b1 -> bool). (\u2203(w :\u03b1). B w) \u21d2 \u2203(min :\u03b1). B min \u2227 \u2200(b :\u03b1). (R :\u03b1 -> \u03b1 -> bool)\u207a b min \u21d2 \u00acB b) \u21d4 \u2200(B :\u03b1 -> bool). (\u2203(w :\u03b1). B w) \u21d2 \u2203(min :\u03b1). B min \u2227 \u2200(b :\u03b1). R b min \u21d2 \u00acB b"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.WF_DEF, relationTheory.WF_NOT_REFL, relationTheory.EMPTY_REL_DEF, relationTheory.symmetric_def, relationTheory.WF_SUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.WF_DEF, relationTheory.RTC_ALT_DEF, relationTheory.EXTEND_RTC_TC_EQN, relationTheory.symmetric_TC, relationTheory.WF_TC]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d4 s DELETE x = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$pred_set$ DELETE Vs Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d4 s DELETE x = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM1, pred_setTheory.IN_DELETE, boolTheory.EQ_IMP_THM, pred_setTheory.EXTENSION, boolTheory.AND_INTRO_THM]", "reward": 5}]], "(x :\u03b1) \u2208 BIGINTER (B :(\u03b1 -> bool) -> bool) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ BIGINTER VB @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ IN VP VB @ @ C$bool$ IN Vx VP"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 BIGINTER (B :(\u03b1 -> bool) -> bool) \u21d4 \u2200(P :\u03b1 -> bool). P \u2208 B \u21d2 x \u2208 P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.FINITE_BIJ_COUNT, pred_setTheory.IN_FUNSET, pred_setTheory.BIGINTER, boolTheory.SELECT_THM, pred_setTheory.GSPECIFICATION]", "reward": 5}]], "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). F) xs = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ @ C$min$ = @ @ C$list$ FILTER | Vx C$bool$ F Vxs C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list). FILTER (\u03bb(x :\u03b1). F) xs = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.DATATYPE_TAG_THM, listTheory.EVERY_EL, listTheory.FILTER_EQ_NIL, boolTheory.REFL_CLAUSE, listTheory.MONO_EVERY]", "reward": 5}]], "numeral$texp_help (n :num) (0 :num) = (2 :num) ** (n + (1 :num))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$numeral$ texp_help Vn C$num$ 0 @ @ C$arithmetic$ EXP @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "numeral$texp_help (n :num) (0 :num) = (2 :num) ** (n + (1 :num))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.MULT_MONO_EQ, numeralTheory.texp_help_thm, arithmeticTheory.ADD_SUC, arithmeticTheory.ODD_MULT, arithmeticTheory.NORM_0]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u2286 (\u2205 :\u03b1 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u2286 (\u2205 :\u03b1 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.NOT_IN_EMPTY, boolTheory.LET_CONG, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION]", "reward": 5}]], "(\u2200(y :\u03b1) (x :\u03b1). (INL x :\u03b1 + \u03b2) = (INL y :\u03b1 + \u03b2) \u21d4 x = y) \u2227 \u2200(y :\u03b2) (x :\u03b2). (INR x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u21d4 x = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vy @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INL Vy @ @ C$min$ = Vx Vy @ C$bool$ ! | Vy @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$min$ = @ C$sum$ INR Vx @ C$sum$ INR Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(y :\u03b1) (x :\u03b1). (INL x :\u03b1 + \u03b2) = (INL y :\u03b1 + \u03b2) \u21d4 x = y) \u2227 \u2200(y :\u03b2) (x :\u03b2). (INR x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u21d4 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[sumTheory.INL_11, boolTheory.RIGHT_EXISTS_IMP_THM, sumTheory.INR_11, boolTheory.COND_ABS, boolTheory.AND_CONG]", "reward": 5}]], "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). n < LENGTH l1 \u21d2 EL n (l1 ++ l2) = EL n l1": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ EL Vn Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). n < LENGTH l1 \u21d2 EL n (l1 ++ l2) = EL n l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.nub_def, boolTheory.PEIRCE, listTheory.NRC_LRC, listTheory.SHORTLEX_NIL2, listTheory.EL_APPEND_EQN]", "reward": 5}]], "(n :num) \u2264 tri n": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$arithmetic$ <= Vn @ C$numpair$ tri Vn"}, "plain": {"assumptions": [], "goal": "(n :num) \u2264 tri n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$arithmetic$ <= C$num$ 0 @ C$numpair$ tri C$num$ 0"}, "plain": {"assumptions": [], "goal": "(0 :num) \u2264 tri (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$arithmetic$ <= Vn @ C$numpair$ tri Vn"], "goal": "@ @ C$arithmetic$ <= @ C$num$ SUC Vn @ C$numpair$ tri @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(n :num) \u2264 tri n"], "goal": "SUC (n :num) \u2264 tri (SUC n)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= Vn @ C$numpair$ tri Vn"], "goal": "@ @ C$arithmetic$ <= @ C$num$ SUC Vn @ C$numpair$ tri @ C$num$ SUC Vn"}, "plain": {"assumptions": ["(n :num) \u2264 tri n"], "goal": "SUC (n :num) \u2264 tri (SUC n)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[arithmeticTheory.MODEQ_REFL, arithmeticTheory.num_CASES, arithmeticTheory.SUB_MOD, arithmeticTheory.DIV_MULT, arithmeticTheory.X_LT_EXP_X]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[arithmeticTheory.MULT_DIV, arithmeticTheory.EXP_1, arithmeticTheory.DIV_LE_MONOTONE, numpairTheory.tri_LE, numpairTheory.tri_def]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 TAKE n (REVERSE l) = REVERSE (LASTN n l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ TAKE Vn @ C$list$ REVERSE Vl @ C$list$ REVERSE @ @ C$rich_list$ LASTN Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 TAKE n (REVERSE l) = REVERSE (LASTN n l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[rich_listTheory.LASTN_def, boolTheory.COND_RAND, listTheory.SWAP_REVERSE_SYM, rich_listTheory.LASTN_def, arithmeticTheory.LESS_EQ_TRANS]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 RC R x y \u21d2 P y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vx @ @ VR Vx Vy @ VP Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vx @ @ @ C$relation$ RC VR Vx Vy @ VP Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 RC R x y \u21d2 P y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.ONTO_DEF, boolTheory.LEFT_EXISTS_AND_THM, boolTheory.AND2_THM, boolTheory.AND_CONG, relationTheory.RC_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). IMAGE (\u03bb(x :\u03b1). x) s = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ IMAGE | Vx Vx Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). IMAGE (\u03bb(x :\u03b1). x) s = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DELETE, pred_setTheory.IN_IMAGE, boolTheory.ONE_ONE_THM, boolTheory.EQ_TRANS, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). SURJ (\u03bb(x :\u03b1). x) s s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ @ C$pred_set$ SURJ | Vx Vx Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). SURJ (\u03bb(x :\u03b1). x) s s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IMAGE_CONG, pred_setTheory.IN_DELETE_EQ, boolTheory.LEFT_OR_CONG, pred_setTheory.SURJ_DEF, boolTheory.EQ_IMP_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (a :\u03b1). Q a \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R y z \u21d2 Q z) \u21d2 \u2200(z :\u03b1). R\ua673 a z \u21d2 Q z": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VQ @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Va @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vy @ @ VR Vy Vz @ VQ Vz @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Va Vz @ VQ Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (a :\u03b1). Q a \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R y z \u21d2 Q z) \u21d2 \u2200(z :\u03b1). R\ua673 a z \u21d2 Q z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.ETA_THM, boolTheory.RES_SELECT_DEF, boolTheory.DISJ_EQ_IMP, relationTheory.RTC_ALT_RIGHT_DEF, boolTheory.IMP_CONJ_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1). IMAGE f {x} = {f x}": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$pred_set$ INSERT @ Vf Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1). IMAGE f {x} = {f x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = Vx' @ Vf Vx'' @ @ C$bool$ IN Vx'' @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT @ Vf Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "(\u2203(x'' :\u03b1). (x' :\u03b2) = (f :\u03b1 -> \u03b2) x'' \u2227 x'' \u2208 {(x :\u03b1)}) \u21d4 x' \u2208 {f x}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, pred_setTheory.EXTENSION, boolTheory.ABS_SIMP, boolTheory.EQ_REFL, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.COMPONENT, pred_setTheory.GSPEC_ETA, pred_setTheory.SING_applied, pred_setTheory.SUBSET_THM, pred_setTheory.SPECIFICATION]", "reward": 5}]], "MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz Vls @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND Vls"}, "plain": {"assumptions": [], "goal": "MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz C$list$ NIL @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) ([] :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ([] :(\u03b2 # \u03b1) list))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz Vls @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND Vls"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz @ @ C$list$ CONS Vh Vls @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)"], "goal": "\u2200(h :\u03b2 # \u03b1). MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (h::(ls :(\u03b2 # \u03b1) list))) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) (h::ls))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz Vls @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND Vls"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP C$pair$ SND @ @ C$list$ FILTER @ C$pair$ UNCURRY | Vx | Vy @ C$bool$ ~ @ @ C$min$ = Vy Vz @ @ C$list$ CONS Vh Vls @ @ C$list$ FILTER | Vy @ C$bool$ ~ @ @ C$min$ = Vz Vy @ @ C$list$ MAP C$pair$ SND @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (ls :(\u03b2 # \u03b1) list)) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) ls)"], "goal": "\u2200(h :\u03b2 # \u03b1). MAP (SND :\u03b2 # \u03b1 -> \u03b1) (FILTER (\u03bb((x :\u03b2),(y :\u03b1)). y \u2260 (z :\u03b1)) (h::(ls :(\u03b2 # \u03b1) list))) = FILTER (\u03bb(y :\u03b1). z \u2260 y) (MAP (SND :\u03b2 # \u03b1 -> \u03b1) (h::ls))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pairTheory.PAIR, listTheory.oEL_DROP, listTheory.MAP_APPEND, listTheory.EL_ZIP, listTheory.ZIP_EQ_NIL]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_IGNORE_BIND_def, boolTheory.RIGHT_OR_EXISTS_THM, pairTheory.UNCURRY_VAR, listTheory.MAP_APPEND, listTheory.SHORTLEX_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). \u00ac(\ud835\udd4c(:\u03b1) \u2282 s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ~ @ @ C$pred_set$ PSUBSET C$pred_set$ UNIV Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). \u00ac(\ud835\udd4c(:\u03b1) \u2282 s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPEC_ETA, pred_setTheory.PSUBSET_DEF, pred_setTheory.GSPEC_ETA, boolTheory.EQ_EXT, pred_setTheory.UNIV_SUBSET]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (b :\u03b2). ITSET f (\u2205 :\u03b1 -> bool) b = b": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vb @ @ C$min$ = @ @ @ C$pred_set$ ITSET Vf C$pred_set$ EMPTY Vb Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (b :\u03b2). ITSET f (\u2205 :\u03b1 -> bool) b = b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_INSERT, pred_setTheory.ITSET_THM, pred_setTheory.FINITE_DEF, pred_setTheory.IN_BIGUNION_IMAGE, pred_setTheory.SUBSET_transitive]", "reward": 5}]], "\ud835\udd4c(:bool) = {T; F}": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = C$pred_set$ UNIV @ @ C$pred_set$ INSERT C$bool$ T @ @ C$pred_set$ INSERT C$bool$ F C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:bool) = {T; F}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ETA_THM, pred_setTheory.UNION_DEF, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.IN_INSERT, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 MEM (EL n l) l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$bool$ IN @ @ C$list$ EL Vn Vl @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 MEM (EL n l) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ? | Vn' @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn' @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ EL Vn Vl @ @ C$list$ EL Vn' Vl"}, "plain": {"assumptions": ["(n :num) < LENGTH (l :\u03b1 list)"], "goal": "\u2203(n' :num). n' < LENGTH (l :\u03b1 list) \u2227 EL (n :num) l = EL n' l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MEM_EL, listTheory.ALL_DISTINCT_FILTER_EL_IMP, listTheory.ALL_DISTINCT_EL_IMP, listTheory.LIST_REL_O, listTheory.LENGTH_DROP]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.SNOC_APPEND, listTheory.MAP2_DEF, listTheory.LENGTH, listTheory.FLAT_compute, listTheory.SET_TO_LIST_INV]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b2 -> bool). R\u1d40 \u1d40 = R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ inv @ C$relation$ inv VR VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b2 -> bool). R\u1d40 \u1d40 = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, boolTheory.DISJ_EQ_IMP, boolTheory.ETA_THM, relationTheory.inv_DEF, boolTheory.FORALL_SIMP]", "reward": 5}]], "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = f b \u21d4 a = b": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ C$relation$ INVOL Vf @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ @ C$min$ = @ Vf Va @ Vf Vb @ @ C$min$ = Va Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :'z -> 'z). INVOL f \u21d2 \u2200(a :'z) (b :'z). f a = f b \u21d4 a = b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.FUN_EQ_THM, boolTheory.UEXISTS_OR_THM, relationTheory.transitive_EQC, boolTheory.literal_case_THM, relationTheory.INVOL]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (y :\u03b1) (z :\u03b1). R y z \u21d2 RESTRICT f R z y = f y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VR @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ VR Vy Vz @ @ C$min$ = @ @ @ @ C$relation$ RESTRICT Vf VR Vz Vy @ Vf Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (y :\u03b1) (z :\u03b1). R y z \u21d2 RESTRICT f R z y = f y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.SC_lifts_monotonicities, boolTheory.literal_case_DEF, relationTheory.EQC_EQUIVALENCE, boolTheory.MONO_AND, relationTheory.RESTRICT_DEF]", "reward": 5}]], "SET_TO_LIST (\u2205 :\u03b1 -> bool) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ SET_TO_LIST C$pred_set$ EMPTY C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SET_TO_LIST (\u2205 :\u03b1 -> bool) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.TAKE_EQ_NIL, pred_setTheory.CHOICE_SING, pred_setTheory.pairwise_SUBSET, listTheory.SET_TO_LIST_THM, listTheory.LENGTH_DROP]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (P :\u03b1 -> bool) (P' :\u03b1 -> bool). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EVERY P l1 \u21d4 EVERY P' l2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | VP @ C$bool$ ! | VP' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl1 Vl2 @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ VP Vx @ VP' Vx @ @ C$min$ = @ @ C$list$ EVERY VP Vl1 @ @ C$list$ EVERY VP' Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (P :\u03b1 -> bool) (P' :\u03b1 -> bool). l1 = l2 \u2227 (\u2200(x :\u03b1). MEM x l2 \u21d2 (P x \u21d4 P' x)) \u21d2 (EVERY P l1 \u21d4 EVERY P' l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.list_size_def, listTheory.list_case_compute, listTheory.EVERY_MEM, listTheory.FILTER_EQ_NIL, listTheory.FILTER_APPEND_DISTRIB]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). MEM x l \u2227 P x \u21d2 Q x) \u2227 EVERY P l \u21d2 EVERY Q l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ VP Vx @ VQ Vx @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VQ Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). (\u2200(x :\u03b1). MEM x l \u2227 P x \u21d2 Q x) \u2227 EVERY P l \u21d2 EVERY Q l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LUPDATE_MAP, boolTheory.DISJ_IMP_THM, listTheory.EVERY_MEM, listTheory.LAST_MAP, listTheory.MEM_LUPDATE_E]", "reward": 5}]], "REVERSE ([] :\u03b2 list) = ([] :\u03b2 list) \u2227 \u2200(x :\u03b1) (l :\u03b1 list). REVERSE (x::l) = SNOC x (REVERSE l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ REVERSE C$list$ NIL C$list$ NIL @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vx Vl @ @ C$list$ SNOC Vx @ C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "REVERSE ([] :\u03b2 list) = ([] :\u03b2 list) \u2227 \u2200(x :\u03b1) (l :\u03b1 list). REVERSE (x::l) = SNOC x (REVERSE l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.UNION_APPEND, listTheory.LIST_EQ_REWRITE, listTheory.EVERY_MEM, listTheory.SNOC_APPEND]", "reward": 5}]], "\u2200(xs :\u03b1 list) (k :num) (n :num). TAKE k (DROP n xs) = DROP n (TAKE (k + n) xs)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ C$bool$ ! | Vk @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ TAKE Vk @ @ C$list$ DROP Vn Vxs @ @ C$list$ DROP Vn @ @ C$list$ TAKE @ @ C$arithmetic$ + Vk Vn Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list) (k :num) (n :num). TAKE k (DROP n xs) = DROP n (TAKE (k + n) xs)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EL_compute, listTheory.LENGTH_MAP2, arithmeticTheory.ADD_SUB, listTheory.EL_MAP2, listTheory.DROP_TAKE]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z) \u21d2 \u2200(x :\u03b1 list) (y :\u03b1 list) (z :\u03b1 list). LIST_REL R x y \u2227 LIST_REL R y z \u21d2 LIST_REL R x z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$list$ LIST_REL VR Vx Vy @ @ @ C$list$ LIST_REL VR Vy Vz @ @ @ C$list$ LIST_REL VR Vx Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z) \u21d2 \u2200(x :\u03b1 list) (y :\u03b1 list) (z :\u03b1 list). LIST_REL R x y \u2227 LIST_REL R y z \u21d2 LIST_REL R x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vz", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vy @ @ VR @ @ C$list$ EL Vn Vy @ @ C$list$ EL Vn Vz", "@ @ C$min$ = @ C$list$ LENGTH Vy @ C$list$ LENGTH Vz", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vx @ @ VR @ @ C$list$ EL Vn Vx @ @ C$list$ EL Vn Vy", "@ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"], "goal": "@ @ VR @ @ C$list$ EL Vn Vx @ @ C$list$ EL Vn Vz"}, "plain": {"assumptions": ["(n :num) < LENGTH (z :\u03b1 list)", "\u2200(n :num). n < LENGTH (y :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) (EL n y) (EL n (z :\u03b1 list))", "LENGTH (y :\u03b1 list) = LENGTH (z :\u03b1 list)", "\u2200(n :num). n < LENGTH (x :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) (EL n x) (EL n (y :\u03b1 list))", "LENGTH (x :\u03b1 list) = LENGTH (y :\u03b1 list)", "\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z"], "goal": "(R :\u03b1 -> \u03b1 -> bool) (EL (n :num) (x :\u03b1 list)) (EL n (z :\u03b1 list))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_EL_EQN, boolTheory.EXISTS_UNIQUE_REFL, boolTheory.literal_case_THM, boolTheory.ITSELF_UNIQUE, listTheory.REVERSE_EQ_NIL]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.FILTER_APPEND_DISTRIB, listTheory.LENGTH_FRONT_CONS, listTheory.FOLDL_UNION_BIGUNION_paired, listTheory.LAST_APPEND_CONS, listTheory.SUM_MAP_PLUS_ZIP]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (a :\u03b1) (s :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 a INSERT s \u21d2 P x) \u21d4 P a \u2227 \u2200(x :\u03b1). x \u2208 s \u21d2 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Va @ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ @ C$pred_set$ INSERT Va Vs @ VP Vx @ @ C$bool$ /\\ @ VP Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (a :\u03b1) (s :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 a INSERT s \u21d2 P x) \u21d4 P a \u2227 \u2200(x :\u03b1). x \u2208 s \u21d2 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.INSERT_applied, pred_setTheory.IN_APP, boolTheory.OR_INTRO_THM1, pred_setTheory.DIFF_DIFF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u222a t = t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs Vt @ @ C$min$ = @ @ C$pred_set$ UNION Vs Vt Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u222a t = t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ UNION Vs Vt @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b1 -> bool)) \u21d4 \u2200(x :\u03b1). x \u2208 s \u222a t \u21d4 x \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.PSUBSET_DEF, boolTheory.OR_ELIM_THM, pred_setTheory.SUBSET_DEF, pred_setTheory.MEMBER_NOT_EMPTY]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_K, pred_setTheory.UNION_applied, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION, pred_setTheory.IN_UNION]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). P x \u2227 Q x) l \u21d4 EVERY P l \u2227 EVERY Q l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx Vl @ @ C$bool$ /\\ @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VQ Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). P x \u2227 Q x) l \u21d4 EVERY P l \u2227 EVERY Q l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.T_DEF, listTheory.EVERY_EL, listTheory.CONS_11, boolTheory.EQ_IMP_THM, boolTheory.FORALL_BOOL]", "reward": 5}]], "FINITE (s :\u03b1 -> bool) \u2227 FINITE (t :\u03b1 -> bool) \u21d2 CARD (s \u222a t) \u2264 CARD s + CARD t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ C$pred_set$ FINITE Vt @ @ C$arithmetic$ <= @ C$pred_set$ CARD @ @ C$pred_set$ UNION Vs Vt @ @ C$arithmetic$ + @ C$pred_set$ CARD Vs @ C$pred_set$ CARD Vt"}, "plain": {"assumptions": [], "goal": "FINITE (s :\u03b1 -> bool) \u2227 FINITE (t :\u03b1 -> bool) \u21d2 CARD (s \u222a t) \u2264 CARD s + CARD t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.INTER_UNION_COMPL, pred_setTheory.CARD_UNION_EQN, pred_setTheory.FUNSET_DFUNSET, pred_setTheory.IMAGE_DEF, pred_setTheory.INSERT_INSERT]", "reward": 5}]], "FST (p :\u03b1 # \u03b2) = (x :\u03b1) \u21d4 \u2203(y :\u03b2). p = (x,y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$pair$ FST Vp Vx @ C$bool$ ? | Vy @ @ C$min$ = Vp @ @ C$pair$ , Vx Vy"}, "plain": {"assumptions": [], "goal": "FST (p :\u03b1 # \u03b2) = (x :\u03b1) \u21d4 \u2203(y :\u03b2). p = (x,y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pairTheory.ELIM_UNCURRY, pairTheory.PAIR, pairTheory.pair_case_def, boolTheory.EQ_TRANS, pairTheory.CLOSED_PAIR_EQ]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2). (\u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d2 x = y) \u21d2 \u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (IMAGE f s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$bool$ ~ @ C$pred_set$ FINITE Vs @ C$bool$ ~ @ C$pred_set$ FINITE @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d2 x = y) \u21d2 \u2200(s :\u03b1 -> bool). INFINITE s \u21d2 INFINITE (IMAGE f s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_EMPTY, pred_setTheory.BIGINTER_UNION, boolTheory.LEFT_EXISTS_AND_THM, boolTheory.IMP_ANTISYM_AX, pred_setTheory.SCHROEDER_CLOSED]", "reward": 5}]], "(\u2200(a :\u03b1 list) (c :\u03b1 list). (d :\u03b1 list) \u2260 a ++ [(b :\u03b1)] ++ c) \u21d4 \u00acMEM b d": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ~ @ @ C$min$ = Vd @ @ C$list$ APPEND @ @ C$list$ APPEND Va @ @ C$list$ CONS Vb C$list$ NIL Vc @ C$bool$ ~ @ @ C$bool$ IN Vb @ C$list$ LIST_TO_SET Vd"}, "plain": {"assumptions": [], "goal": "(\u2200(a :\u03b1 list) (c :\u03b1 list). (d :\u03b1 list) \u2260 a ++ [(b :\u03b1)] ++ c) \u21d4 \u00acMEM b d"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SUM_SNOC, boolTheory.COND_DEF, listTheory.MEM_SPLIT, listTheory.REVERSE_11, boolTheory.UNWIND_THM1]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool) (y :\u03b2). y \u2208 BIGUNION (IMAGE f s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 y \u2208 f x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE Vf Vs @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool) (y :\u03b2). y \u2208 BIGUNION (IMAGE f s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 y \u2208 f x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs' @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vs' @ Vf Vx @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy @ Vf Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(s' :\u03b2 -> bool). (y :\u03b2) \u2208 s' \u2227 \u2203(x :\u03b1). s' = (f :\u03b1 -> \u03b2 -> bool) x \u2227 x \u2208 (s :\u03b1 -> bool)) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 y \u2208 f x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_BIGUNION, pred_setTheory.IN_IMAGE, pred_setTheory.INTER_DEF, pred_setTheory.IN_IMAGE, pred_setTheory.FINITE_WEAK_ENUMERATE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.SING_DELETE, pred_setTheory.IN_IMAGE, pred_setTheory.INSERT_applied, pred_setTheory.INSERT_INSERT]", "reward": 5}]], "{x | x \u2208 (y :\u03b1 -> bool)} = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN Vx Vy Vy"}, "plain": {"assumptions": [], "goal": "{x | x \u2208 (y :\u03b1 -> bool)} = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DEF, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.CROSS_INSERT_RIGHT, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_CROSS]", "reward": 5}]], "\u2200(m :num) (n :num). m \u2264 n \u2297 m": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$arithmetic$ <= Vm @ @ C$numpair$ npair Vn Vm"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m \u2264 n \u2297 m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.CONJ_COMM, arithmeticTheory.EXP_EXP_LE_MONO, arithmeticTheory.EXP_EXP_INJECTIVE, numpairTheory.npair_def, boolTheory.DE_MORGAN_THM]", "reward": 5}]], "\u2200(n :num) (f :num -> \u03b1) (m :num). n < m \u21d2 EL n (MAP f (COUNT_LIST m)) = f n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vf @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST Vm @ Vf Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (f :num -> \u03b1) (m :num). n < m \u21d2 EL n (MAP f (COUNT_LIST m)) = f n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.MAP_COUNT_LIST, listTheory.TAKE_LENGTH_TOO_LONG, rich_listTheory.SPLITP_NIL_FST_IMP, rich_listTheory.LENGTH_SEG, rich_listTheory.MAP_COUNT_LIST]", "reward": 5}]], "transitive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ transitive C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "transitive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_applied, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, relationTheory.INVOL_ONE_ONE, relationTheory.transitive_def, relationTheory.STRORD]", "reward": 5}]], "antisymmetric ($RSUBSET :(\u03b1 -> \u03b2 -> bool) -> (\u03b1 -> \u03b2 -> bool) -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ antisymmetric C$relation$ RSUBSET"}, "plain": {"assumptions": [], "goal": "antisymmetric ($RSUBSET :(\u03b1 -> \u03b2 -> bool) -> (\u03b1 -> \u03b2 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.RSUBSET_ANTISYM, relationTheory.INVOL, relationTheory.antisymmetric_def, relationTheory.antisymmetric_def, relationTheory.trichotomous]", "reward": 5}]], "\u2200(x :\u03b1) (n :num) (ys :\u03b1 list). LENGTH (LUPDATE x n ys) = LENGTH ys": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vn @ C$bool$ ! | Vys @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ LUPDATE Vx Vn Vys @ C$list$ LENGTH Vys"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (n :num) (ys :\u03b1 list). LENGTH (LUPDATE x n ys) = LENGTH ys"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LUPDATE_SEM, boolTheory.RES_EXISTS_UNIQUE_DEF, listTheory.SUM_MAP_FOLDL, listTheory.LENGTH_ZIP_MIN, listTheory.EL_MAP]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). BIJ f s t) \u21d4 \u2203(g :\u03b2 -> \u03b1). BIJ g t s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ C$bool$ ? | Vf @ @ @ C$pred_set$ BIJ Vf Vs Vt @ C$bool$ ? | Vg @ @ @ C$pred_set$ BIJ Vg Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). BIJ f s t) \u21d4 \u2203(g :\u03b2 -> \u03b1). BIJ g t s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INSERT_DIFF, pred_setTheory.SUBSET_K, pred_setTheory.RTC_PSUBSET, pred_setTheory.BIJ_SYM_IMP, pred_setTheory.INSERT_UNION]", "reward": 5}]], "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). LAST (x::y::z) = LAST (y::z)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LAST @ @ C$list$ CONS Vx C$list$ NIL Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ C$list$ LAST @ @ C$list$ CONS Vx @ @ C$list$ CONS Vy Vz @ C$list$ LAST @ @ C$list$ CONS Vy Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). LAST [x] = x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). LAST (x::y::z) = LAST (y::z)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.NOT_CONS_NIL, listTheory.MEM_MAP_f, listTheory.LAST_DEF, listTheory.CONS_11, boolTheory.OR_IMP_THM]", "reward": 5}]], "FUNSET \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) = \ud835\udd4c(:\u03b1 -> \u03b2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ FUNSET C$pred_set$ UNIV C$pred_set$ UNIV C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "FUNSET \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) = \ud835\udd4c(:\u03b1 -> \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.UNIV_DEF, pred_setTheory.INSERT_applied, pred_setTheory.DIFF_DEF, pred_setTheory.SPECIFICATION, pred_setTheory.FUNSET]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool) (v :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 s \u2227 v \u2286 t \u21d2 DISJOINT u v": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ C$bool$ ! | Vv @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vu Vs @ @ C$pred_set$ SUBSET Vv Vt @ @ C$pred_set$ DISJOINT Vu Vv"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool) (v :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 s \u2227 v \u2286 t \u21d2 DISJOINT u v"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.CONJ_ASSOC, boolTheory.MONO_NOT_EQ, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_DISJOINT, pred_setTheory.UNION_applied]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t DIFF t = s DIFF t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DIFF @ @ C$pred_set$ DIFF Vs Vt Vt @ @ C$pred_set$ DIFF Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t DIFF t = s DIFF t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "((x :\u03b1) \u2208 (s :\u03b1 -> bool) \u2227 x \u2209 (t :\u03b1 -> bool)) \u2227 x \u2209 t \u21d4 x \u2208 s \u2227 x \u2209 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM, pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, boolTheory.RIGHT_AND_OVER_OR, pred_setTheory.IN_DIFF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_SYM, boolTheory.bool_INDUCT, pred_setTheory.DIFF_DEF, boolTheory.OR_IMP_THM, pred_setTheory.SET_EQ_SUBSET]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = t \u2229 s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ INTER Vs Vt @ @ C$pred_set$ INTER Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = t \u2229 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ INTER Vs Vt @ @ C$pred_set$ INTER Vt Vs"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2229 (t :\u03b1 -> bool) = t \u2229 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.PAIR_IN_GSPEC_same, boolTheory.IMP_ANTISYM_AX, boolTheory.NOT_F, pred_setTheory.PSUBSET_UNIV]", "reward": 0.1}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.CONJ_COMM, pred_setTheory.NOT_IN_EMPTY, boolTheory.DATATYPE_TAG_DEF, pred_setTheory.INTER_DEF, pred_setTheory.SUBSET_TRANS]", "reward": 5}]], "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). NULL l \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ NULL C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T C$list$ NIL"}, "plain": {"assumptions": [], "goal": "NULL ([] :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["NULL (l :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l"], "goal": "\u2200(h :\u03b1). NULL (h::(l :\u03b1 list)) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["NULL (l :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l"], "goal": "\u2200(h :\u03b1). NULL (h::(l :\u03b1 list)) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.ALL_DISTINCT_SET_TO_LIST, listTheory.LIST_REL_SPLIT2, listTheory.LENGTH_TAKE_EQ, listTheory.REVERSE_REV, boolTheory.BOTH_FORALL_OR_THM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = @ C$list$ NULL C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T C$list$ NIL @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(NULL ([] :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T ([] :\u03b1 list)) \u21d2 (NULL [(h :\u03b1)] \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T [h])"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T Vl @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh' Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh' Vl @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl"}, "plain": {"assumptions": ["(NULL (l :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l) \u21d2 (NULL ((h :\u03b1)::l) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::l))"], "goal": "\u2200(h' :\u03b1). (NULL (h'::(l :\u03b1 list)) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h'::l)) \u21d2 (NULL ((h :\u03b1)::h'::l) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::h'::l))"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = @ C$list$ NULL Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T Vl @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh Vl"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh' Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh' Vl @ @ C$min$ = @ C$list$ NULL @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl @ @ @ C$list$ FOLDL | Vx | Vl' C$bool$ F C$bool$ T @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl"}, "plain": {"assumptions": ["(NULL (l :\u03b1 list) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T l) \u21d2 (NULL ((h :\u03b1)::l) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::l))"], "goal": "\u2200(h' :\u03b1). (NULL (h'::(l :\u03b1 list)) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h'::l)) \u21d2 (NULL ((h :\u03b1)::h'::l) \u21d4 FOLDL (\u03bb(x :bool) (l' :\u03b1). F) T (h::h'::l))"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.EVERY2_THM, listTheory.FLAT_EQ_NIL, listTheory.LIST_REL_EL_EQN, listTheory.LIST_REL_cases, listTheory.EL_REVERSE]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.UNIQUE_DEF, listTheory.DROP_TAKE, listTheory.LAST_compute, listTheory.EL_MAP, listTheory.FILTER]", "reward": 5}]], "IDEM (RTC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ IDEM C$relation$ RTC"}, "plain": {"assumptions": [], "goal": "IDEM (RTC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.IDEM, relationTheory.RTC_IDEM, relationTheory.inv_RC, relationTheory.inv_SC, relationTheory.RC_OR_Id]", "reward": 5}]], "(([(f :\u03b2 -> \u03b1)] <*> [(x :\u03b2)]) :\u03b1 list) = [f x]": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_APPLY @ @ C$list$ CONS Vf C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS @ Vf Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(([(f :\u03b2 -> \u03b1)] <*> [(x :\u03b2)]) :\u03b1 list) = [f x]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP, listTheory.LIST_APPLY_def, listTheory.isPREFIX_NILR, listTheory.SINGL_APPLY_MAP, listTheory.ALL_DISTINCT_ZIP]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1). x \u2208 {y} \u21d4 x = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ INSERT Vy C$pred_set$ EMPTY @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1). x \u2208 {y} \u21d4 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_REST, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.SUBSET_DEF, pred_setTheory.DISJOINT_EMPTY_REFL, pred_setTheory.IN_INSERT]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t DELETE x \u21d4 x \u2209 s \u2227 s \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ DELETE Vt Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$pred_set$ SUBSET Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t DELETE x \u21d4 x \u2209 s \u2227 s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vt @ C$bool$ ~ @ @ C$min$ = Vx' Vx"], "goal": "@ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). x' \u2208 (s :\u03b1 -> bool) \u21d2 x' \u2208 (t :\u03b1 -> bool) \u2227 x' \u2260 (x :\u03b1)"], "goal": "(x :\u03b1) \u2209 (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DELETE, boolTheory.REFL_CLAUSE, boolTheory.EQ_IMP_THM, pred_setTheory.SUBSET_DEF, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_SYM_EQ, pred_setTheory.IN_DISJOINT, pred_setTheory.DIFF_DEF, pred_setTheory.PSUBSET_DEF, boolTheory.EXISTS_REFL]", "reward": 5}]], "LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). (P :\u03b1 -> \u03b2 -> bool) a b \u2227 (Q :\u03b1 -> \u03b2 -> bool) a b) (l1 :\u03b1 list) (l2 :\u03b2 list) \u21d4 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). P a b) l1 l2 \u2227 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). Q a b) l1 l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ LIST_REL | Va | Vb @ @ C$bool$ /\\ @ @ VP Va Vb @ @ VQ Va Vb Vl1 Vl2 @ @ C$bool$ /\\ @ @ @ C$list$ LIST_REL | Va | Vb @ @ VP Va Vb Vl1 Vl2 @ @ @ C$list$ LIST_REL | Va | Vb @ @ VQ Va Vb Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). (P :\u03b1 -> \u03b2 -> bool) a b \u2227 (Q :\u03b1 -> \u03b2 -> bool) a b) (l1 :\u03b1 list) (l2 :\u03b2 list) \u21d4 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). P a b) l1 l2 \u2227 LIST_REL (\u03bb(a :\u03b1) (b :\u03b2). Q a b) l1 l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.LIST_REL_EL_EQN, listTheory.NULL_APPEND, boolTheory.EQ_IMP_THM, listTheory.EVERY_NOT_EXISTS, boolTheory.FUN_EQ_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). REST s x \u21d4 x \u2208 s \u2227 x \u2260 CHOICE s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ REST Vs Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$min$ = Vx @ C$pred_set$ CHOICE Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). REST s x \u21d4 x \u2208 s \u2227 x \u2260 CHOICE s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.DELETE_applied, boolTheory.COND_RATOR, boolTheory.UNWIND_THM2, pred_setTheory.REST_DEF]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x \u2286 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET @ @ C$pred_set$ DELETE Vs Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF, pred_setTheory.DELETE_applied, boolTheory.COND_EXPAND]", "reward": 5}]], "((a :\u03b1),(b :\u03b2)) \u2208 {(y,(x :\u03b2)) | (P :\u03b1 -> bool) y} \u21d4 P a \u2227 b = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN @ @ C$pair$ , Va Vb @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , @ @ C$pair$ , Vy Vx @ VP Vy @ @ C$bool$ /\\ @ VP Va @ @ C$min$ = Vb Vx"}, "plain": {"assumptions": [], "goal": "((a :\u03b1),(b :\u03b2)) \u2208 {(y,(x :\u03b2)) | (P :\u03b1 -> bool) y} \u21d4 P a \u2227 b = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPECIFICATION, boolTheory.IMP_ANTISYM_AX, pairTheory.COMMA_DEF, boolTheory.bool_INDUCT, pairTheory.PROD_ALL_def]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u2229 t \u21d4 x \u2208 s \u2227 x \u2208 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ INTER Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u2229 t \u21d4 x \u2208 s \u2227 x \u2208 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_DEF, pred_setTheory.INTER_DEF, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.SET_EQ_SUBSET, boolTheory.IMP_CLAUSES]", "reward": 5}]], "reflexive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ reflexive C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "reflexive ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.IN_GSPEC, relationTheory.inv_RC, relationTheory.reflexive_def, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2229 u \u21d4 s \u2286 t \u2227 s \u2286 u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ INTER Vt Vu @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ SUBSET Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2229 u \u21d4 s \u2286 t \u2227 s \u2286 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, boolTheory.DISJ_COMM, pred_setTheory.IN_INTER, boolTheory.IMP_ANTISYM_AX, pred_setTheory.SET_EQ_SUBSET]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s DIFF s = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s DIFF s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.T_DEF, pred_setTheory.EMPTY_SUBSET, pred_setTheory.GSPEC_ETA, pred_setTheory.DIFF_DEF, pred_setTheory.EMPTY_DEF]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). IS_SUFFIX l1 l2 \u21d4 REVERSE l2 \u227c REVERSE l1": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$rich_list$ IS_SUFFIX Vl1 Vl2 @ @ C$list$ isPREFIX @ C$list$ REVERSE Vl2 @ C$list$ REVERSE Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). IS_SUFFIX l1 l2 \u21d4 REVERSE l2 \u227c REVERSE l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.BOOL_EQ_DISTINCT, rich_listTheory.IS_PREFIX_REVERSE, boolTheory.EXISTS_itself, listTheory.MEM_SNOC, rich_listTheory.BUTLASTN_CONS]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (REVERSE l) = REVERSE (DROP n l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN Vn @ C$list$ REVERSE Vl @ C$list$ REVERSE @ @ C$list$ DROP Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (REVERSE l) = REVERSE (DROP n l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.IMP_EVERY_LUPDATE, rich_listTheory.BUTLASTN_def, boolTheory.EXISTS_DEF, listTheory.FLAT_compute, listTheory.LIST_TO_SET_APPEND]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). x \u2208 s \u21d4 MEM x (SET_TO_LIST s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ SET_TO_LIST Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(x :\u03b1). x \u2208 s \u21d4 MEM x (SET_TO_LIST s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SET_TO_LIST_INV, listTheory.NULL_EQ, listTheory.LENGTH_DROP, listTheory.UNZIP_ZIP, pred_setTheory.HAS_SIZE]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u222a s = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ UNION Vs Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u222a s = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, boolTheory.COND_EXPAND, boolTheory.COND_EXPAND_IMP, boolTheory.EXISTS_REFL, pred_setTheory.IN_UNION]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x \u2208 y INSERT s \u21d4 x = y \u2228 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ INSERT Vy Vs @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x \u2208 y INSERT s \u21d4 x = y \u2228 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.INSERT_DEF, pred_setTheory.IN_EQ_UNIV_IMP]", "reward": 5}]], "COMPL ((s :\u03b1 -> bool) \u222a (t :\u03b1 -> bool)) = COMPL s \u2229 COMPL t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ COMPL @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vs @ C$pred_set$ COMPL Vt"}, "plain": {"assumptions": [], "goal": "COMPL ((s :\u03b1 -> bool) \u222a (t :\u03b1 -> bool)) = COMPL s \u2229 COMPL t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ COMPL @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$pred_set$ COMPL @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx @ C$pred_set$ COMPL @ C$pred_set$ COMPL Vs @ @ C$bool$ IN Vx @ C$pred_set$ COMPL @ C$pred_set$ COMPL Vt"}, "plain": {"assumptions": [], "goal": "COMPL {x | x \u2208 (s :\u03b1 -> bool) \u2228 x \u2208 (t :\u03b1 -> bool)} = COMPL {x | x \u2208 COMPL (COMPL s) \u2228 x \u2208 COMPL (COMPL t)}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_UNION_COMPL, pred_setTheory.INSERT_DEF, pred_setTheory.UNION_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.DELETE_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.BIGINTER_UNION, pred_setTheory.IN_COMPL, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_COMPL, pred_setTheory.UNIV_applied]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1) (P :\u03b1 -> bool). x \u2208 y INSERT P \u21d4 x = y \u2228 x \u2260 y \u2227 x \u2208 P": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | VP @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ INSERT Vy VP @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vx Vy @ @ C$bool$ IN Vx VP"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1) (P :\u03b1 -> bool). x \u2208 y INSERT P \u21d4 x = y \u2228 x \u2260 y \u2227 x \u2208 P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.GSPEC_ID, pred_setTheory.IN_INSERT, boolTheory.LEFT_AND_FORALL_THM, pred_setTheory.POW_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 \u2203(u :\u03b1). R\ua673 x u \u2227 R\ua673 u y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$relation$ RTC VR Vx Vy @ C$bool$ ? | Vu @ @ C$bool$ /\\ @ @ @ C$relation$ RTC VR Vx Vu @ @ @ C$relation$ RTC VR Vu Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 \u2203(u :\u03b1). R\ua673 x u \u2227 R\ua673 u y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.TC_lifts_equalities, relationTheory.TC_DEF, relationTheory.RTC_cases, boolTheory.ETA_THM, relationTheory.RTC_RTC]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2260 t \u21d4 \u2203(x :\u03b1). x \u2208 t \u21d4 x \u2209 s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vs Vt @ C$bool$ ? | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2260 t \u21d4 \u2203(x :\u03b1). x \u2208 t \u21d4 x \u2209 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vs Vt @ C$bool$ ? | Vx @ @ C$min$ = @ Vt Vx @ C$bool$ ~ @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2260 (t :\u03b1 -> bool) \u21d4 \u2203(x :\u03b1). t x \u21d4 \u00acs x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_OR_OVER_AND, boolTheory.BOOL_FUN_INDUCT, boolTheory.IN_DEF, boolTheory.AND_IMP_INTRO, boolTheory.LEFT_OR_OVER_AND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_AND, boolTheory.BOTH_FORALL_IMP_THM, boolTheory.CONJ_COMM, boolTheory.COND_RAND, boolTheory.IMP_F_EQ_F]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE x = s DELETE x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DELETE @ @ C$pred_set$ DELETE Vs Vx Vx @ @ C$pred_set$ DELETE Vs Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE x = s DELETE x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.DELETE_DEF, pred_setTheory.GSPEC_ETA, boolTheory.RIGHT_FORALL_OR_THM, pred_setTheory.DIFF_DIFF]", "reward": 5}]], "(x :\u03b1) \u2208 RDOM (RRESTRICT (R :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool)) \u21d4 x \u2208 RDOM R \u2227 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$relation$ RDOM @ @ C$relation$ RRESTRICT VR Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$relation$ RDOM VR @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 RDOM (RRESTRICT (R :\u03b1 -> \u03b2 -> bool) (s :\u03b1 -> bool)) \u21d4 x \u2208 RDOM R \u2227 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.IN_RDOM, relationTheory.RRESTRICT_DEF, relationTheory.O_DEF, relationTheory.RINTER, relationTheory.RSUBSET]", "reward": 5}]], "\u2200(B :\u03b1 -> bool) (C :\u03b1 -> \u03b1) (R :\u03b1 -> \u03b1 -> bool). WF R \u2227 (\u2200(s :\u03b1). B s \u21d2 R (C s) s) \u21d2 \u2200(P :\u03b1 -> bool). (\u2200(s :\u03b1). (B s \u21d2 P (C s)) \u21d2 P s) \u21d2 \u2200(v :\u03b1). P v": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VB @ C$bool$ ! | VC @ C$bool$ ! | VR @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$relation$ WF VR @ C$bool$ ! | Vs @ @ C$min$ ==> @ VB Vs @ @ VR @ VC Vs Vs @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$min$ ==> @ VB Vs @ VP @ VC Vs @ VP Vs @ C$bool$ ! | Vv @ VP Vv"}, "plain": {"assumptions": [], "goal": "\u2200(B :\u03b1 -> bool) (C :\u03b1 -> \u03b1) (R :\u03b1 -> \u03b1 -> bool). WF R \u2227 (\u2200(s :\u03b1). B s \u21d2 R (C s) s) \u21d2 \u2200(P :\u03b1 -> bool). (\u2200(s :\u03b1). (B s \u21d2 P (C s)) \u21d2 P s) \u21d2 \u2200(v :\u03b1). P v"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.WeakOrder, relationTheory.WF_EQ_INDUCTION_THM, relationTheory.trichotomous_STRORD, relationTheory.transitive_TC_identity, relationTheory.transitive_EQC]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 s \u2286 t \u2227 \u2203(y :\u03b1). y \u2208 t \u2227 y \u2209 s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ PSUBSET Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vt @ C$bool$ ~ @ @ C$bool$ IN Vy Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 s \u2286 t \u2227 \u2203(y :\u03b1). y \u2208 t \u2227 y \u2209 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vt @ C$bool$ ~ @ @ C$bool$ IN Vy Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b1 -> bool)) \u2227 (\u2203(x :\u03b1). x \u2208 t \u21d4 x \u2209 s) \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 x \u2208 t) \u2227 \u2203(y :\u03b1). y \u2208 t \u2227 y \u2209 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.COMPONENT, boolTheory.RIGHT_OR_OVER_AND, pred_setTheory.PSUBSET_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.NOT_EQUAL_SETS]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_DELETE, pred_setTheory.INSERT_INSERT, pred_setTheory.IN_INTER, pred_setTheory.SPECIFICATION, pred_setTheory.INSERT_UNION_EQ]", "reward": 5}]], "{x | x = (y :\u03b1)} = {y}": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$min$ = Vx Vy @ @ C$pred_set$ INSERT Vy C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "{x | x = (y :\u03b1)} = {y}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$min$ = Vx Vy @ C$pred_set$ GSPEC | Vy' @ @ C$pair$ , Vy' @ @ C$bool$ \\/ @ @ C$min$ = Vy' Vy @ @ C$bool$ IN Vy' C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "{x | x = (y :\u03b1)} = {y' | y' = y \u2228 y' \u2208 (\u2205 :\u03b1 -> bool)}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_DEF, pred_setTheory.BIGUNION_IMAGE_UNIV, pred_setTheory.INSERT_DEF, pairTheory.UNCURRY_CURRY_THM, pred_setTheory.SUBSET_ADD]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DEF, pred_setTheory.REST_applied, pred_setTheory.IN_DISJOINT, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.PSUBSET_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). (s DELETE y) x \u21d4 x \u2208 s \u2227 x \u2260 y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$pred_set$ DELETE Vs Vy Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (x :\u03b1) (y :\u03b1). (s DELETE y) x \u21d4 x \u2208 s \u2227 x \u2260 y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_DELETE, pred_setTheory.GSPECIFICATION, pred_setTheory.IN_APP, boolTheory.LCOMM_THM, pred_setTheory.DISJOINT_SYM]", "reward": 5}]], "IDEM (RC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ IDEM C$relation$ RC"}, "plain": {"assumptions": [], "goal": "IDEM (RC :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.IDEM, relationTheory.inv_O, relationTheory.RC_IDEM, relationTheory.inv_RC, relationTheory.IDEM_DEF]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EXISTS P (l1 ++ l2) \u21d4 EXISTS P l1 \u2228 EXISTS P l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ EXISTS VP @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$list$ EXISTS VP Vl1 @ @ C$list$ EXISTS VP Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EXISTS P (l1 ++ l2) \u21d4 EXISTS P l1 \u2228 EXISTS P l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_MEM, listTheory.EVERY_APPEND, boolTheory.PULL_EXISTS, listTheory.MAP, listTheory.EXISTS_NOT_EVERY]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (s :(\u03b1 -> bool) -> bool). (\u2200(x :\u03b1). x \u2208 BIGUNION s \u21d2 P x) \u21d4 \u2200(t :\u03b1 -> bool) (x :\u03b1). t \u2208 s \u2227 x \u2208 t \u21d2 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION Vs @ VP Vx @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vt Vs @ @ C$bool$ IN Vx Vt @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (s :(\u03b1 -> bool) -> bool). (\u2200(x :\u03b1). x \u2208 BIGUNION s \u21d2 P x) \u21d4 \u2200(t :\u03b1 -> bool) (x :\u03b1). t \u2208 s \u2227 x \u2208 t \u21d2 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_FORALL_OR_THM, pred_setTheory.FINITE_REST_EQ, pred_setTheory.IN_BIGUNION, pred_setTheory.REL_RESTRICT_DEF, boolTheory.FUN_EQ_THM]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 R\ua673 x y \u21d2 P y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vx @ @ VR Vx Vy @ VP Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vx @ @ @ C$relation$ RTC VR Vx Vy @ VP Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (P :\u03b1 -> bool) x \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). P x \u2227 R\ua673 x y \u21d2 P y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_CLAUSES, boolTheory.itself_induction, relationTheory.RC_DEF, relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.RTC_IDEM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u2229 u) = s \u2229 t \u2229 u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ INTER Vs @ @ C$pred_set$ INTER Vt Vu @ @ C$pred_set$ INTER @ @ C$pred_set$ INTER Vs Vt Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u2229 u) = s \u2229 t \u2229 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.SUBSET_DEF, boolTheory.CONJ_ASSOC, pred_setTheory.EXTENSION, boolTheory.AND_IMP_INTRO]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s DIFF t) x \u21d4 x \u2208 s \u2227 x \u2209 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ DIFF Vs Vt Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (s DIFF t) x \u21d4 x \u2208 s \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPEC_ETA, pred_setTheory.SET_EQ_SUBSET, pred_setTheory.DIFF_DEF, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_applied]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l \u2260 l \u21d4 \u2203(x :\u03b1). MEM x l \u2227 \u00acP x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ FILTER VP Vl Vl @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). FILTER P l \u2260 l \u21d4 \u2203(x :\u03b1). MEM x l \u2227 \u00acP x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FILTER_EQ_ID, listTheory.EVERY_MEM, listTheory.MEM_SPLIT, boolTheory.FORALL_SIMP, boolTheory.OR_CLAUSES]", "reward": 5}]], "WF (\u03bb(x :num) (y :num). y = SUC x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ WF | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx"}, "plain": {"assumptions": [], "goal": "WF (\u03bb(x :num) (y :num). y = SUC x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.EQC_REFL, relationTheory.WF_EQ_INDUCTION_THM, relationTheory.reflexive_def, numTheory.INDUCTION, relationTheory.inv_O]", "reward": 5}]], "\u2200(x :num) (y :num). x \u2297 y = (0 :num) \u21d4 x = (0 :num) \u2227 y = (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ @ C$numpair$ npair Vx Vy C$num$ 0 @ @ C$bool$ /\\ @ @ C$min$ = Vx C$num$ 0 @ @ C$min$ = Vy C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(x :num) (y :num). x \u2297 y = (0 :num) \u21d4 x = (0 :num) \u2227 y = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.MONO_AND, boolTheory.ABS_SIMP, numpairTheory.tri_eq_0, numpairTheory.npair_def, numTheory.ZERO_REP_DEF]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2227 Q x} = {x | P x} \u2229 {x | Q x}": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx @ @ C$pred_set$ INTER @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VP Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2227 Q x} = {x | P x} \u2229 {x | Q x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_EXPAND, pred_setTheory.DFUNSET_applied, pred_setTheory.INTER_DEF, pairTheory.UNCURRY_DEF, pred_setTheory.IN_GSPEC_IFF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(f :num -> \u03b1) (b :num). BIJ f (count b) s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ? | Vf @ C$bool$ ? | Vb @ @ @ C$pred_set$ BIJ Vf @ C$pred_set$ count Vb Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(f :num -> \u03b1) (b :num). BIJ f (count b) s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_BIJ_COUNT_EQ, pred_setTheory.INSERT_applied, pred_setTheory.NOT_INSERT_EMPTY, pred_setTheory.DFUNSET_applied, pred_setTheory.DISJOINT_EMPTY_REFL_RWT]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (TAKE m l)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (TAKE m l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP C$list$ NIL @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (m :num). EVERY P ([] :\u03b1 list) \u21d2 EVERY P (TAKE m ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (TAKE m l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (m :num). EVERY P (h::(l :\u03b1 list)) \u21d2 EVERY P (TAKE m (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (TAKE m l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (m :num). EVERY P (h::(l :\u03b1 list)) \u21d2 EVERY P (TAKE m (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, listTheory.list_to_set_diff, listTheory.TAKE_APPEND2, listTheory.EXISTS_APPEND, listTheory.NULL_EQ]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ EVERY VP Vl", "@ VP Vh", "@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ TAKE Vm Vl"], "goal": "@ @ C$list$ EVERY VP @ @ @ C$bool$ COND @ @ C$min$ = Vm C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vm @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl"}, "plain": {"assumptions": ["EVERY (P :\u03b1 -> bool) (l :\u03b1 list)", "(P :\u03b1 -> bool) (h :\u03b1)", "\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (TAKE m l)"], "goal": "EVERY (P :\u03b1 -> bool) (if (m :num) = (0 :num) then ([] :\u03b1 list) else (h :\u03b1)::TAKE (m \u2212 (1 :num)) (l :\u03b1 list))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_SPLIT1, listTheory.FRONT_DEF, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.OPT_MMAP_def]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_THM, boolTheory.OR_DEF, listTheory.GENLIST_GENLIST_AUX, listTheory.EVERY2_LUPDATE_same, boolTheory.EQ_IMP_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (x INSERT s) \u21d4 DISJOINT t s \u2227 x \u2209 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vt @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vt Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (x INSERT s) \u21d4 DISJOINT t s \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vt @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2209 (t :\u03b1 -> bool) \u2228 x' \u2260 (x :\u03b1) \u2227 x' \u2209 (s :\u03b1 -> bool)) \u21d4 (\u2200(x :\u03b1). x \u2209 t \u2228 x \u2209 s) \u2227 x \u2209 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DIFF_DEF, boolTheory.BOTH_EXISTS_AND_THM, pred_setTheory.IN_DISJOINT, boolTheory.LET_RAND, pred_setTheory.IN_INSERT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_DEF, boolTheory.EXISTS_UNIQUE_DEF, pred_setTheory.DIFF_DEF, pred_setTheory.SUBSET_UNION_ABSORPTION, pred_setTheory.SUBSET_UNION]", "reward": 5}]], "(\u2200(x :\u03b1). FRONT [x] = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). FRONT (x::y::z) = x::FRONT (y::z)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ CONS Vx C$list$ NIL C$list$ NIL @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ CONS Vx @ @ C$list$ CONS Vy Vz @ @ C$list$ CONS Vx @ C$list$ FRONT @ @ C$list$ CONS Vy Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). FRONT [x] = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1 list). FRONT (x::y::z) = x::FRONT (y::z)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FRONT_DEF, boolTheory.EQ_TRANS, boolTheory.BETA_THM, listTheory.INDEX_OF_def, listTheory.list_distinct]", "reward": 5}]], "\u2200(f :'z -> 'z). IDEM f \u21d4 \u2200(x :'z). f (f x) = f x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$relation$ IDEM Vf @ C$bool$ ! | Vx @ @ C$min$ = @ Vf @ Vf Vx @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :'z -> 'z). IDEM f \u21d4 \u2200(x :'z). f (f x) = f x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EXISTS_THM, boolTheory.FORALL_BOOL, boolTheory.FUN_EQ_THM, boolTheory.EQ_SYM, relationTheory.IDEM_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2229 s = s DIFF t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DIFF Vs @ @ C$pred_set$ INTER Vt Vs @ @ C$pred_set$ DIFF Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t \u2229 s = s DIFF t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "{x | x \u2208 (s :\u03b1 -> bool) \u2227 (x \u2209 (t :\u03b1 -> bool) \u2228 x \u2209 s)} = {x | x \u2208 s \u2227 x \u2209 t}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.RC_PSUBSET, pred_setTheory.IN_GSPEC, pred_setTheory.IN_DISJOINT, pred_setTheory.DIFF_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA, boolTheory.LEFT_AND_OVER_OR, boolTheory.EQ_SYM_EQ]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). \u00acP x) l \u21d2 SPLITP P l = (l,([] :\u03b1 list))": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$list$ EVERY | Vx @ C$bool$ ~ @ VP Vx Vl @ @ C$min$ = @ @ C$rich_list$ SPLITP VP Vl @ @ C$pair$ , Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). \u00acP x) l \u21d2 SPLITP P l = (l,([] :\u03b1 list))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ EVERY | Vx @ C$bool$ ~ @ VP Vx Vl"], "goal": "@ @ C$min$ = @ @ C$rich_list$ SPLITP VP Vl @ C$pair$ ABS_prod | Va | Vb @ @ C$bool$ /\\ @ @ C$min$ = Va Vl @ @ C$min$ = Vb C$list$ NIL"}, "plain": {"assumptions": ["EVERY (\u03bb(x :\u03b1). \u00ac(P :\u03b1 -> bool) x) (l :\u03b1 list)"], "goal": "SPLITP (P :\u03b1 -> bool) (l :\u03b1 list) = ABS_prod (\u03bb(a :\u03b1 list) (b :\u03b1 list). a = l \u2227 b = ([] :\u03b1 list))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.FLAT, listTheory.LUPDATE_SOME_MAP, listTheory.REVERSE_SNOC_DEF, pairTheory.COMMA_DEF, listTheory.LIST_REL_NIL]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.MAP2_NIL, rich_listTheory.longest_prefix_SING, rich_listTheory.SPLITP_NIL_SND_EVERY, rich_listTheory.ELL_MAP, pairTheory.COMMA_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b4) (x :\u03b1) (y :\u03b3). (f ## g) (x,y) = (f x,g y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$pair$ ## Vf Vg @ @ C$pair$ , Vx Vy @ @ C$pair$ , @ Vf Vx @ Vg Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b3 -> \u03b4) (x :\u03b1) (y :\u03b3). (f ## g) (x,y) = (f x,g y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pairTheory.ELIM_UNCURRY, pairTheory.SND, pairTheory.PAIR_MAP, boolTheory.UNWIND_THM2, pairTheory.FST]", "reward": 5}]], "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) DELETE x = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DELETE C$pred_set$ EMPTY Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). (\u2205 :\u03b1 -> bool) DELETE x = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.DELETE_applied, pred_setTheory.EMPTY_DEF, pred_setTheory.SPECIFICATION, pred_setTheory.EXTENSION, pred_setTheory.INSERT_INSERT]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (LASTN n l) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN Vn @ @ C$rich_list$ LASTN Vn Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 BUTLASTN n (LASTN n l) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.APPEND_FRONT_LAST, listTheory.LENGTH_TAKE, rich_listTheory.BUTLASTN_def, rich_listTheory.LASTN_def, rich_listTheory.SPLITL_def]", "reward": 5}]], "(\u2203(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2203(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vp @ VP Vp @ C$bool$ ? | Vp_1 @ C$bool$ ? | Vp_2 @ VP @ @ C$pair$ , Vp_1 Vp_2"}, "plain": {"assumptions": [], "goal": "(\u2203(p :\u03b1 # \u03b2). (P :\u03b1 # \u03b2 -> bool) p) \u21d4 \u2203(p_1 :\u03b1) (p_2 :\u03b2). P (p_1,p_2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.SWAP_FORALL_THM, pairTheory.ABS_PAIR_THM, boolTheory.EQ_EXPAND, pairTheory.PAIR_EQ, pairTheory.UNCURRY_ONE_ONE_THM]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n l = LASTN (LENGTH l \u2212 n) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn Vl @ @ C$rich_list$ LASTN @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 DROP n l = LASTN (LENGTH l \u2212 n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN_SUC_FRONT, rich_listTheory.LASTN_DROP, arithmeticTheory.SUB_MOD, rich_listTheory.BUTLASTN_LENGTH_APPEND, arithmeticTheory.MIN_DEF]", "reward": 5}]], "(LEAST(n :num). n = (x :num)) = x \u2227 (LEAST(n :num). x = n) = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$while$ LEAST | Vn @ @ C$min$ = Vn Vx Vx @ @ C$min$ = @ C$while$ LEAST | Vn @ @ C$min$ = Vx Vn Vx"}, "plain": {"assumptions": [], "goal": "(LEAST(n :num). n = (x :num)) = x \u2227 (LEAST(n :num). x = n) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[whileTheory.LEAST_ELIM, boolTheory.AND_IMP_INTRO, boolTheory.OR_CLAUSES, boolTheory.COND_RAND, boolTheory.EQ_SYM_EQ]", "reward": 5}]], "((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) ((a :\u03b1),(b :\u03b2)) ((c :\u03b1),(d :\u03b2)) \u21d4 R1 a c \u2228 a = c \u2227 R2 b d": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ @ C$pair$ LEX VR1 VR2 @ @ C$pair$ , Va Vb @ @ C$pair$ , Vc Vd @ @ C$bool$ \\/ @ @ VR1 Va Vc @ @ C$bool$ /\\ @ @ C$min$ = Va Vc @ @ VR2 Vb Vd"}, "plain": {"assumptions": [], "goal": "((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) ((a :\u03b1),(b :\u03b2)) ((c :\u03b1),(d :\u03b2)) \u21d4 R1 a c \u2228 a = c \u2227 R2 b d"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pairTheory.UNCURRY_DEF, pairTheory.PAIR_MAP, pairTheory.CURRY_ONE_ONE_THM, boolTheory.EQ_EXT, pairTheory.LEX_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). R\u207a \u207a = R\u207a": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ TC @ C$relation$ TC VR @ C$relation$ TC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). R\u207a \u207a = R\u207a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.TC_TRANSITIVE, boolTheory.SELECT_REFL, boolTheory.EQ_REFL, relationTheory.transitive_TC_identity, boolTheory.EXISTS_UNIQUE_REFL]", "reward": 5}]], "\u2200(m :num) (n :num). MEM m (COUNT_LIST n) \u21d4 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$bool$ IN Vm @ C$list$ LIST_TO_SET @ C$rich_list$ COUNT_LIST Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). MEM m (COUNT_LIST n) \u21d4 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.COUNT_LIST_GENLIST, rich_listTheory.IS_PREFIX_REVERSE, listTheory.LIST_TO_SET_GENLIST, listTheory.LUPDATE_SAME, listTheory.LIST_REL_APPEND_IMP]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u21d4 DISJOINT s s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$min$ = Vs C$pred_set$ EMPTY @ @ C$pred_set$ DISJOINT Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u21d4 DISJOINT s s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.DISJOINT_DEF, pred_setTheory.EXTENSION, boolTheory.FUN_EQ_THM, pred_setTheory.IN_INTER]", "reward": 5}]], "$! (UNCURRY (f :\u03b1 -> \u03b2 -> bool)) \u21d4 $! (($! :(\u03b2 -> bool) -> bool) \u2218 f)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! @ C$pair$ UNCURRY Vf @ C$bool$ ! @ @ C$combin$ o C$bool$ ! Vf"}, "plain": {"assumptions": [], "goal": "$! (UNCURRY (f :\u03b1 -> \u03b2 -> bool)) \u21d4 $! (($! :(\u03b2 -> bool) -> bool) \u2218 f)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$pair$ UNCURRY Vf Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ Vf Vx Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 # \u03b2). UNCURRY (f :\u03b1 -> \u03b2 -> bool) x) \u21d4 \u2200(x :\u03b1) (x' :\u03b2). f x x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, boolTheory.NOT_DEF, pairTheory.PAIR_MAP, boolTheory.LEFT_AND_OVER_OR, boolTheory.FORALL_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pairTheory.PAIR_MAP_THM, pairTheory.CLOSED_PAIR_EQ, boolTheory.EXCLUDED_MIDDLE, pairTheory.UNCURRY_DEF, pairTheory.ELIM_UNCURRY]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). FUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ @ @ C$pred_set$ FUNSET VP VQ Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VP @ @ C$bool$ IN @ Vf Vx VQ"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (P :\u03b1 -> bool) (Q :\u03b2 -> bool). FUNSET P Q f \u21d4 \u2200(x :\u03b1). x \u2208 P \u21d2 f x \u2208 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, boolTheory.literal_case_THM, pred_setTheory.FUNSET, pred_setTheory.RC_PSUBSET, pred_setTheory.TC_SUBSET_THM]", "reward": 5}]], "transitive (R :\u03b1 -> \u03b1 -> bool) \u21d4 R \u2218\u1d63 R \u2286\u1d63 R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ transitive VR @ @ C$relation$ RSUBSET @ @ C$relation$ O VR VR VR"}, "plain": {"assumptions": [], "goal": "transitive (R :\u03b1 -> \u03b1 -> bool) \u21d4 R \u2218\u1d63 R \u2286\u1d63 R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ C$bool$ ? | Vy' @ @ C$bool$ /\\ @ @ VR Vx Vy' @ @ VR Vy' Vy @ @ VR Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z) \u21d4 \u2200(x :\u03b1) (y :\u03b1). (\u2203(y' :\u03b1). R x y' \u2227 R y' y) \u21d2 R x y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.WF_EQ_WFP, relationTheory.WFREC_COROLLARY, relationTheory.O_DEF, relationTheory.RSUBSET, relationTheory.transitive_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.WF_DEF, relationTheory.inv_DEF, relationTheory.inv_image_thm, relationTheory.RC_DEF, relationTheory.RC_DEF]", "reward": 5}]], "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 irreflexive R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$relation$ WF VR @ C$relation$ irreflexive VR"}, "plain": {"assumptions": [], "goal": "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 irreflexive R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$relation$ WF VR @ C$bool$ ! | Vx @ C$bool$ ~ @ @ VR Vx Vx"}, "plain": {"assumptions": [], "goal": "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 \u2200(x :\u03b1). \u00acR x x"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.RTC_REFL, relationTheory.TC_RTC, relationTheory.SC_DEF, relationTheory.SC_DEF, relationTheory.irreflexive_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.irreflexive_def, relationTheory.WF_NOT_REFL, relationTheory.irreflexive_def, relationTheory.TC_IDEM, relationTheory.transitive_RC]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s DIFF t \u21d4 x \u2208 s \u2227 x \u2209 t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ DIFF Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). x \u2208 s DIFF t \u21d4 x \u2208 s \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_GSPEC_IFF, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION, pred_setTheory.DIFF_DEF]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). IS_SUFFIX l1 l2 \u2227 IS_SUFFIX l2 l3 \u21d2 IS_SUFFIX l1 l3": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$rich_list$ IS_SUFFIX Vl1 Vl2 @ @ C$rich_list$ IS_SUFFIX Vl2 Vl3 @ @ C$rich_list$ IS_SUFFIX Vl1 Vl3"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). IS_SUFFIX l1 l2 \u2227 IS_SUFFIX l2 l3 \u21d2 IS_SUFFIX l1 l3"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, rich_listTheory.IS_SUFFIX_APPEND, boolTheory.LET_RAND, boolTheory.RIGHT_AND_FORALL_THM, boolTheory.PULL_EXISTS]", "reward": 5}]], "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(x :\u03b1). x \u2209 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ C$pred_set$ FINITE C$pred_set$ UNIV @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2203(x :\u03b1). x \u2209 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INTER_applied, boolTheory.IMP_CONG, pred_setTheory.CARD_SING, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.EQ_UNIV]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 WFP R y) \u21d2 WFP R x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vy Vx @ @ C$relation$ WFP VR Vy @ @ C$relation$ WFP VR Vx"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 WFP R y) \u21d2 WFP R x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, relationTheory.WF_DEF, boolTheory.LEFT_EXISTS_AND_THM, relationTheory.WFP_DEF, boolTheory.EXISTS_THM]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT (x INSERT s) t \u21d4 DISJOINT s t \u2227 x \u2209 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ INSERT Vx Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vs Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT (x INSERT s) t \u21d4 DISJOINT s t \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx' Vt @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2209 (x :\u03b1) INSERT (s :\u03b1 -> bool) \u2228 x' \u2209 (t :\u03b1 -> bool)) \u21d4 (\u2200(x :\u03b1). x \u2209 s \u2228 x \u2209 t) \u2227 x \u2209 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DISJOINT, pred_setTheory.DISJOINT_ALT, boolTheory.UNWIND_THM2, pred_setTheory.EXTENSION, boolTheory.LET_RAND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.SWAP_EXISTS_THM, pred_setTheory.IN_INSERT, boolTheory.UNWIND_THM2, boolTheory.JRH_INDUCT_UTIL, boolTheory.boolAxiom]", "reward": 5}]], "\u2200(x :bool) (y :\u03b1 -> bool). (K x :\u03b1 -> bool) \u2286 y \u21d4 \u00acx \u2228 \ud835\udd4c(:\u03b1) \u2286 y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$pred_set$ SUBSET @ C$combin$ K Vx Vy @ @ C$bool$ \\/ @ C$bool$ ~ Vx @ @ C$pred_set$ SUBSET C$pred_set$ UNIV Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :bool) (y :\u03b1 -> bool). (K x :\u03b1 -> bool) \u2286 y \u21d4 \u00acx \u2228 \ud835\udd4c(:\u03b1) \u2286 y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> Vx @ Vy Vx' @ @ C$bool$ \\/ @ C$bool$ ~ Vx @ C$bool$ ! | Vx @ Vy Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). (x :bool) \u21d2 (y :\u03b1 -> bool) x') \u21d4 \u00acx \u2228 \u2200(x :\u03b1). y x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_applied, pred_setTheory.PAIR_IN_GSPEC_2, pred_setTheory.SUBSET_ANTISYM_EQ, pred_setTheory.SUBSET_applied, boolTheory.LEFT_OR_OVER_AND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_THM, boolTheory.FALSITY, boolTheory.BETA_THM, boolTheory.itself_induction, pred_setTheory.EQ_SUBSET_SUBSET]", "reward": 5}]], "longest_prefix (\u2205 :\u03b1 list -> bool) = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$rich_list$ longest_prefix C$pred_set$ EMPTY C$list$ NIL"}, "plain": {"assumptions": [], "goal": "longest_prefix (\u2205 :\u03b1 list -> bool) = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[rich_listTheory.longest_prefix_def, pred_setTheory.NOT_EMPTY_INSERT, listTheory.SUM_eq_0, pred_setTheory.UNION_COMM, listTheory.MAP_EQ_f]", "reward": 5}]], "\u2200(x :\u03b1 -> bool) (y :bool). x \u2286 (K y :\u03b1 -> bool) \u21d4 x \u2286 (\u2205 :\u03b1 -> bool) \u2228 y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$pred_set$ SUBSET Vx @ C$combin$ K Vy @ @ C$bool$ \\/ @ @ C$pred_set$ SUBSET Vx C$pred_set$ EMPTY Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :bool). x \u2286 (K y :\u03b1 -> bool) \u21d4 x \u2286 (\u2205 :\u03b1 -> bool) \u2228 y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vx Vx' Vy @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vx Vx' @ C$pred_set$ EMPTY Vx' Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :bool). (\u2200(x' :\u03b1). x x' \u21d2 y) \u21d4 (\u2200(x' :\u03b1). x x' \u21d2 \u2205 x') \u2228 y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_applied, pred_setTheory.SUBSET_applied, pred_setTheory.SUBSET_reflexive, boolTheory.literal_case_THM, boolTheory.EXISTS_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.DE_MORGAN_THM, pred_setTheory.EMPTY_DEF, boolTheory.NOT_IMP, boolTheory.EQ_TRANS, boolTheory.itself_induction]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). (y INSERT s) x \u21d4 x = y \u2228 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vs @ @ C$min$ = @ @ @ C$pred_set$ INSERT Vy Vs Vx @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). (y INSERT s) x \u21d4 x = y \u2228 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_SYM, pred_setTheory.INSERT_DEF, pred_setTheory.IN_DISJOINT, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.NOT_EQUAL_SETS]", "reward": 5}]], "symmetric (R :\u03b1 -> \u03b1 -> bool) \u21d4 R\u1d40 \u2286\u1d63 R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ symmetric VR @ @ C$relation$ RSUBSET @ C$relation$ inv VR VR"}, "plain": {"assumptions": [], "goal": "symmetric (R :\u03b1 -> \u03b1 -> bool) \u21d4 R\u1d40 \u2286\u1d63 R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ symmetric VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ inv VR Vx Vy @ @ VR Vx Vy"}, "plain": {"assumptions": [], "goal": "symmetric (R :\u03b1 -> \u03b1 -> bool) \u21d4 \u2200(x :\u03b1) (y :\u03b1). R\u1d40 x y \u21d2 R x y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.irreflexive_def, relationTheory.antisymmetric_def, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, relationTheory.RSUBSET, relationTheory.O_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.IDEM_DEF, relationTheory.inv_DEF, relationTheory.symmetric_def, relationTheory.O_DEF, relationTheory.RSUBSET]", "reward": 5}]], "LIST_BIND [(x :\u03b2)] (f :\u03b2 -> \u03b1 list) = f x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_BIND @ @ C$list$ CONS Vx C$list$ NIL Vf @ Vf Vx"}, "plain": {"assumptions": [], "goal": "LIST_BIND [(x :\u03b2)] (f :\u03b2 -> \u03b1 list) = f x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.LIST_BIND_THM, listTheory.MEM_MAP, listTheory.ZIP_MAP, listTheory.APPEND_EQ_SELF, listTheory.EL_restricted]", "reward": 5}]], "\u2200(P :\u03b1 list -> bool) (n :num). (\u2200(l :\u03b1 list). LENGTH l = SUC n \u21d2 P l) \u21d4 \u2200(l :\u03b1 list). LENGTH l = n \u21d2 (\u03bb(l :\u03b1 list). \u2200(x :\u03b1). P (x::l)) l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vn @ @ C$min$ = @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ VP Vl @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Vl Vn @ | Vl @ C$bool$ ! | Vx @ VP @ @ C$list$ CONS Vx Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 list -> bool) (n :num). (\u2200(l :\u03b1 list). LENGTH l = SUC n \u21d2 P l) \u21d4 \u2200(l :\u03b1 list). LENGTH l = n \u21d2 (\u03bb(l :\u03b1 list). \u2200(x :\u03b1). P (x::l)) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl' @ VP Vl @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Vl Vn @ C$bool$ ! | Vx @ VP @ @ C$list$ CONS Vx Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). (\u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = (n :num) \u2227 l = h::l') \u21d2 (P :\u03b1 list -> bool) l) \u21d4 \u2200(l :\u03b1 list). LENGTH l = n \u21d2 \u2200(x :\u03b1). P (x::l)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.NOT_EQ_LIST, boolTheory.NOT_F, boolTheory.IMP_F_EQ_F, boolTheory.DE_MORGAN_THM, listTheory.LENGTH_CONS]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.COND_EXPAND_IMP, listTheory.LIST_TO_SET, listTheory.MAP_EQ_f, boolTheory.DISJ_COMM, boolTheory.OR_IMP_THM]", "reward": 5}]], "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = (NONE :\u03b1 option) \u21d4 \u2200(n :num). G (FUNPOW f n s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ @ C$while$ OWHILE VG Vf Vs C$option$ NONE @ C$bool$ ! | Vn @ VG @ @ @ C$arithmetic$ FUNPOW Vf Vn Vs"}, "plain": {"assumptions": [], "goal": "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = (NONE :\u03b1 option) \u21d4 \u2200(n :num). G (FUNPOW f n s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOUNDED_DEF, arithmeticTheory.FUNPOW_0, whileTheory.OWHILE_def, arithmeticTheory.MOD_EQ_0, arithmeticTheory.NOT_EXP_0]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (f' :\u03b1 -> \u03b2) (s' :\u03b1 -> bool). s = s' \u2227 (\u2200(x :\u03b1). x \u2208 s' \u21d2 f x = f' x) \u21d2 IMAGE f s = IMAGE f' s'": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vf' @ C$bool$ ! | Vs' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vs Vs' @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs' @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE Vf' Vs'"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (f' :\u03b1 -> \u03b2) (s' :\u03b1 -> bool). s = s' \u2227 (\u2200(x :\u03b1). x \u2208 s' \u21d2 f x = f' x) \u21d2 IMAGE f s = IMAGE f' s'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs' @ @ C$min$ = @ Vf Vx @ Vf' Vx", "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vs'"], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$bool$ IN Vx' Vs' @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf' Vx' @ @ C$bool$ IN Vx' Vs'"}, "plain": {"assumptions": ["\u2200(x :\u03b1). x \u2208 (s' :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x = (f' :\u03b1 -> \u03b2) x", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d4 x \u2208 (s' :\u03b1 -> bool)"], "goal": "(\u2203(x' :\u03b1). (x :\u03b2) = (f :\u03b1 -> \u03b2) x' \u2227 x' \u2208 (s' :\u03b1 -> bool)) \u21d4 \u2203(x' :\u03b1). x = (f' :\u03b1 -> \u03b2) x' \u2227 x' \u2208 s'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.IN_IMAGE, pred_setTheory.DELETE_COMM, boolTheory.SWAP_EXISTS_THM, pred_setTheory.IMAGE_INTER]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_DEF, pred_setTheory.INTER_EMPTY, boolTheory.ONE_ONE_THM, boolTheory.COND_DEF, boolTheory.EQ_IMP_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). DISJOINT (s DELETE x) t \u21d4 DISJOINT (t DELETE x) s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ DELETE Vs Vx Vt @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ DELETE Vt Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). DISJOINT (s DELETE x) t \u21d4 DISJOINT (t DELETE x) s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vt @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vt @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). (x' \u2209 (s :\u03b1 -> bool) \u2228 x' = (x :\u03b1)) \u2228 x' \u2209 (t :\u03b1 -> bool)) \u21d4 \u2200(x' :\u03b1). (x' \u2209 t \u2228 x' = x) \u2228 x' \u2209 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.ELT_IN_DELETE, boolTheory.LET_THM, pred_setTheory.IN_DISJOINT, pred_setTheory.UNION_COMM, pred_setTheory.IN_DELETE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.DISJ_IMP_THM, pred_setTheory.UNION_applied, pred_setTheory.SUBSET_K, boolTheory.IMP_F_EQ_F, boolTheory.OR_CLAUSES]", "reward": 5}]], "\u2200(x :\u03b1 + \u03b2). \u00acISR x \u21d4 ISL x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$bool$ ~ @ C$sum$ ISR Vx @ C$sum$ ISL Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 + \u03b2). \u00acISR x \u21d4 ISL x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[sumTheory.INL_DEF, boolTheory.EXCLUDED_MIDDLE, sumTheory.NOT_ISL_ISR, boolTheory.AND_INTRO_THM, boolTheory.RIGHT_EXISTS_AND_THM]", "reward": 5}]], "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u21d2 LENGTH x \u2264 LENGTH y": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u21d2 LENGTH x \u2264 LENGTH y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list). x \u227c ([] :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH (h::y)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `y`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH (h::y)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[arithmeticTheory.PRE_SUB, listTheory.list_CASES, listTheory.LENGTH, listTheory.GENLIST_APPEND, boolTheory.LET_DEF]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"], "goal": "@ @ C$min$ ==> @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH C$list$ NIL @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH y"], "goal": "([] :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 LENGTH ([] :\u03b1 list) \u2264 LENGTH (h::y)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH (h::y)", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 LENGTH (h'::x) \u2264 LENGTH (h::y)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ isPREFIX Vx Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH (h::y)", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u21d2 LENGTH x \u2264 LENGTH y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 LENGTH (h'::x) \u2264 LENGTH (h::y)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[boolTheory.ONTO_THM, listTheory.isPREFIX_THM, listTheory.LENGTH, listTheory.UNZIP, listTheory.GENLIST]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.INJ_MAP_EQ_IFF, listTheory.LENGTH_ZIP, listTheory.SWAP_REVERSE_SYM, listTheory.isPREFIX_THM, listTheory.MEM_dropWhile_IMP]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\ua673 x z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ @ C$relation$ RTC VR Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ @ C$relation$ RTC VR Vy Vz @ @ @ C$relation$ RTC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\ua673 x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | VRTC' @ C$bool$ ? | Va0' @ C$bool$ ? | Va1' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Va1' Va0' @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Va0' Vy @ @ VRTC' Vy Va1' @ C$bool$ ~ @ @ VRTC' Va0' Va1' @ @ VRTC' Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ C$bool$ ? | VRTC' @ C$bool$ ! | Va0' @ C$bool$ ! | Va1' @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Va1' Va0' @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Va0' Vy @ C$bool$ ~ @ @ VRTC' Vy Va1' @ @ VRTC' Va0' Va1' @ C$bool$ ~ @ @ VRTC' Vy Vz @ C$bool$ ! | VRTC' @ C$bool$ ? | Va0' @ C$bool$ ? | Va1' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Va1' Va0' @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Va0' Vy @ @ VRTC' Vy Va1' @ C$bool$ ~ @ @ VRTC' Va0' Va1' @ @ VRTC' Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (RTC' :\u03b1 -> \u03b1 -> bool). \u2203(a0' :\u03b1) (a1' :\u03b1). (a1' = a0' \u2228 \u2203(y :\u03b1). R a0' y \u2227 RTC' y a1') \u2227 \u00acRTC' a0' a1' \u2228 RTC' x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (\u00acR x y \u2228 \u2203(RTC' :\u03b1 -> \u03b1 -> bool). \u2200(a0' :\u03b1) (a1' :\u03b1). (a1' \u2260 a0' \u2227 (\u2200(y :\u03b1). \u00acR a0' y \u2228 \u00acRTC' y a1') \u2228 RTC' a0' a1') \u2227 \u00acRTC' y z) \u2228 \u2200(RTC' :\u03b1 -> \u03b1 -> bool). \u2203(a0' :\u03b1) (a1' :\u03b1). (a1' = a0' \u2228 \u2203(y :\u03b1). R a0' y \u2227 RTC' y a1') \u2227 \u00acRTC' a0' a1' \u2228 RTC' x z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.RTC_def, boolTheory.PULL_EXISTS, boolTheory.COND_RATOR, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.IMP_DISJ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.transitive_def, boolTheory.NOT_CLAUSES, boolTheory.RES_ABSTRACT_DEF, boolTheory.RES_ABSTRACT_DEF, boolTheory.LEFT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). SURJ f s t) \u21d2 \u2203(g :\u03b2 -> \u03b1). INJ g t s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ C$bool$ ? | Vf @ @ @ C$pred_set$ SURJ Vf Vs Vt @ C$bool$ ? | Vg @ @ @ C$pred_set$ INJ Vg Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b2). SURJ f s t) \u21d2 \u2203(g :\u03b2 -> \u03b1). INJ g t s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt"], "goal": "@ C$bool$ ? | Vg @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN @ Vg Vx Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vy Vt @ @ C$min$ ==> @ @ C$min$ = @ Vg Vx @ Vg Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b2). x \u2208 (t :\u03b2 -> bool) \u21d2 \u2203(y :\u03b1). y \u2208 (s :\u03b1 -> bool) \u2227 (f :\u03b1 -> \u03b2) y = x", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool)"], "goal": "\u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). x \u2208 (t :\u03b2 -> bool) \u21d2 g x \u2208 (s :\u03b1 -> bool)) \u2227 \u2200(x :\u03b2) (y :\u03b2). x \u2208 t \u2227 y \u2208 t \u21d2 g x = g y \u21d2 x = y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SURJ_DEF, pred_setTheory.IN_UNION, pred_setTheory.INJ_DEF, boolTheory.IMP_ANTISYM_AX, pred_setTheory.RC_SUBSET_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_GSPEC, boolTheory.itself_case_thm, boolTheory.EQ_IMP_THM, pred_setTheory.NOT_EMPTY_INSERT, boolTheory.SELECT_REFL_2]", "reward": 5}]], "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 s \u2282 \ud835\udd4c(:\u03b1)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ C$pred_set$ FINITE C$pred_set$ UNIV @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ @ C$pred_set$ PSUBSET Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 s \u2282 \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ C$pred_set$ FINITE C$pred_set$ UNIV @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs C$pred_set$ UNIV @ C$bool$ ~ @ @ C$min$ = Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "INFINITE \ud835\udd4c(:\u03b1) \u21d4 \u2200(s :\u03b1 -> bool). FINITE s \u21d2 s \u2286 \ud835\udd4c(:\u03b1) \u2227 s \u2260 \ud835\udd4c(:\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DIFF_SUBSET, pred_setTheory.IN_INTER, pred_setTheory.PSUBSET_DEF, pred_setTheory.INTER_applied, pred_setTheory.EQ_SUBSET_SUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.OR_CONG, pred_setTheory.INTER_FINITE, boolTheory.RES_EXISTS_CONG, pred_setTheory.SURJ_IMP_INJ, pred_setTheory.SUBSET_UNIV]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). x \u2208 P \u00d7 Q \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ CROSS VP VQ @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx VP @ @ C$bool$ IN @ C$pair$ SND Vx VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). x \u2208 P \u00d7 Q \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_GSPEC_IFF, pred_setTheory.CROSS_DEF, boolTheory.CONJ_ASSOC, pred_setTheory.COUNT_applied, pred_setTheory.DIFF_BIGINTER]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). irreflexive R\u1d40 \u21d4 irreflexive R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ irreflexive @ C$relation$ inv VR @ C$relation$ irreflexive VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). irreflexive R\u1d40 \u21d4 irreflexive R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.irreflexive_def, relationTheory.reflexive_def, relationTheory.irreflexive_def, relationTheory.trichotomous, relationTheory.inv_DEF]", "reward": 5}]], "\u2200(s :\u03b2 -> bool). FUNSET (\u2205 :\u03b1 -> bool) s = \ud835\udd4c(:\u03b1 -> \u03b2)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ FUNSET C$pred_set$ EMPTY Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b2 -> bool). FUNSET (\u2205 :\u03b1 -> bool) s = \ud835\udd4c(:\u03b1 -> \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ FUNSET C$pred_set$ EMPTY Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "(((\u2205 :\u03b1 -> bool) \u2192 (s :\u03b2 -> bool)) :(\u03b1 -> \u03b2) -> bool) = \ud835\udd4c(:\u03b1 -> \u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ONE_ONE_THM, pred_setTheory.INJ_EMPTY, pred_setTheory.BIJ_EMPTY, pred_setTheory.INJ_IMAGE_BIJ, boolTheory.EXISTS_REFL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ FUNSET | Vx C$bool$ F Vs Vx @ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> \u03b2). ((\u03bb(x :\u03b1). F) \u2192 (s :\u03b2 -> bool)) x \u21d4 \ud835\udd4c(:\u03b1 -> \u03b2) x"}}], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.FUN_EQ_THM, pred_setTheory.EMPTY_DEF, pred_setTheory.UNION_applied, pred_setTheory.SUBSET_DEF, pred_setTheory.DELETE_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_II, pred_setTheory.UNIV_DEF, pred_setTheory.FUNSET_applied, pred_setTheory.IN_FUNSET]", "reward": 5}]], "INVOL (relinv :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ INVOL C$relation$ inv"}, "plain": {"assumptions": [], "goal": "INVOL (relinv :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.inv_inv, relationTheory.ALT_equivalence, relationTheory.INVOL, relationTheory.symmetric_RC, relationTheory.RTC_IDEM]", "reward": 5}]], "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (x :\u03b1). s1 \u2286 s2 \u21d2 s1 DELETE x \u2286 s2 DELETE x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs1 Vs2 @ @ C$pred_set$ SUBSET @ @ C$pred_set$ DELETE Vs1 Vx @ @ C$pred_set$ DELETE Vs2 Vx"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (x :\u03b1). s1 \u2286 s2 \u21d2 s1 DELETE x \u2286 s2 DELETE x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_SING, pred_setTheory.INSERT_applied, pred_setTheory.IN_APP, pred_setTheory.DELETE_applied, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). CURRY (UNCURRY f) = f": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$pair$ CURRY @ C$pair$ UNCURRY Vf Vf"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b3). CURRY (UNCURRY f) = f"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_THM, boolTheory.RES_SELECT_DEF, boolTheory.NOT_AND, pairTheory.CURRY_DEF, pairTheory.UNCURRY_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). PREIMAGE f s x \u21d4 f x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ PREIMAGE Vf Vs Vx @ @ C$bool$ IN @ Vf Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). PREIMAGE f s x \u21d4 f x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.PREIMAGE_def, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.CROSS_DEF, pred_setTheory.SUBSET_EQ_CARD]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x INSERT y INSERT s = y INSERT x INSERT s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ INSERT Vy Vs @ @ C$pred_set$ INSERT Vy @ @ C$pred_set$ INSERT Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). x INSERT y INSERT s = y INSERT x INSERT s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vy @ @ C$bool$ IN Vx' Vs @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vy @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(x' :\u03b1) = (x :\u03b1) \u2228 x' = (y :\u03b1) \u2228 x' \u2208 (s :\u03b1 -> bool) \u21d4 x' = y \u2228 x' = x \u2228 x' \u2208 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_CONG, pred_setTheory.SUBSET_K, pred_setTheory.IN_INSERT, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_GSPEC_IFF, pred_setTheory.IN_APP, pred_setTheory.IN_APP, pred_setTheory.SUBSET_ANTISYM_EQ, pred_setTheory.UNION_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u2229 t = s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs Vt @ @ C$min$ = @ @ C$pred_set$ INTER Vs Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d4 s \u2229 t = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ INTER Vs Vt Vx @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2209 (s :\u03b1 -> bool) \u2228 x \u2208 (t :\u03b1 -> bool)) \u21d4 \u2200(x :\u03b1). (s \u2229 t) x \u21d4 s x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNION_DEF, pred_setTheory.SUBSET_DEF, boolTheory.FUN_EQ_THM, boolTheory.IMP_DISJ_THM, boolTheory.CONJ_ASSOC]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA, boolTheory.NOT_IMP, boolTheory.RIGHT_EXISTS_AND_THM, pred_setTheory.IN_INTER]", "reward": 5}]], "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_FST l) = LENGTH l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ LENGTH @ C$rich_list$ UNZIP_FST Vl @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :(\u03b1 # \u03b2) list). LENGTH (UNZIP_FST l) = LENGTH l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_NIL_SYM, boolTheory.LEFT_FORALL_IMP_THM, listTheory.ALL_DISTINCT_GENLIST, rich_listTheory.UNZIP_FST_DEF, listTheory.isPREFIX_CONSR]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). total R \u21d2 total (inv_image R f)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vf @ @ C$min$ ==> @ C$relation$ total VR @ C$relation$ total @ @ C$relation$ inv_image VR Vf"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (f :\u03b2 -> \u03b1). total R \u21d2 total (inv_image R f)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.inv_image_def, relationTheory.transitive_def, boolTheory.LEFT_FORALL_IMP_THM, relationTheory.total_def]", "reward": 5}]], "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 -> \u03b2 -> bool) (FST p) (SND p)) \u21d4 \u2200(p1 :\u03b1) (p2 :\u03b2). P p1 p2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vp @ @ VP @ C$pair$ FST Vp @ C$pair$ SND Vp @ C$bool$ ! | Vp1 @ C$bool$ ! | Vp2 @ @ VP Vp1 Vp2"}, "plain": {"assumptions": [], "goal": "(\u2200(p :\u03b1 # \u03b2). (P :\u03b1 -> \u03b2 -> bool) (FST p) (SND p)) \u21d4 \u2200(p1 :\u03b1) (p2 :\u03b2). P p1 p2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_NOT, pairTheory.CURRY_ONE_ONE_THM, boolTheory.OR_INTRO_THM1, pairTheory.PAIR, pairTheory.UNCURRY_DEF]", "reward": 5}]], "(LIST_REL (R :\u03b1 -> \u03b2 -> bool) ([] :\u03b1 list) (y :\u03b2 list) \u21d4 y = ([] :\u03b2 list)) \u2227 (LIST_REL R (x :\u03b1 list) ([] :\u03b2 list) \u21d4 x = ([] :\u03b1 list))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ @ C$list$ LIST_REL VR C$list$ NIL Vy @ @ C$min$ = Vy C$list$ NIL @ @ C$min$ = @ @ @ C$list$ LIST_REL VR Vx C$list$ NIL @ @ C$min$ = Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(LIST_REL (R :\u03b1 -> \u03b2 -> bool) ([] :\u03b1 list) (y :\u03b2 list) \u21d4 y = ([] :\u03b2 list)) \u2227 (LIST_REL R (x :\u03b1 list) ([] :\u03b2 list) \u21d4 x = ([] :\u03b1 list))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.APPEND, listTheory.MEM, listTheory.FILTER_APPEND_DISTRIB, boolTheory.SELECT_ELIM_THM, listTheory.LIST_REL_cases]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (SC R)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$relation$ symmetric @ C$relation$ SC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (SC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ VR Vx Vy @ @ VR Vy Vx @ @ C$bool$ \\/ @ @ VR Vy Vx @ @ VR Vx Vy"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) \u2228 R y x \u21d4 R y x \u2228 R x y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.symmetric_def, relationTheory.SC_DEF, boolTheory.UNWIND_FORALL_THM1, relationTheory.trichotomous, boolTheory.IN_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.SC_DEF, boolTheory.itself_case_thm, boolTheory.NOT_AND, boolTheory.EQ_SYM_EQ, boolTheory.LEFT_OR_OVER_AND]", "reward": 5}]], "(x :\u03b1) \u2208 RDOM ((R :\u03b1 -> \u03b2 -> bool) \\\\ (k :\u03b1)) \u21d4 x \u2208 RDOM R \u2227 x \u2260 k": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$relation$ RDOM @ @ C$relation$ RDOM_DELETE VR Vk @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$relation$ RDOM VR @ C$bool$ ~ @ @ C$min$ = Vx Vk"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 RDOM ((R :\u03b1 -> \u03b2 -> bool) \\\\ (k :\u03b1)) \u21d4 x \u2208 RDOM R \u2227 x \u2260 k"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$relation$ RDOM @ @ C$relation$ RDOM_DELETE VR Vk @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$relation$ RDOM VR @ C$bool$ ~ @ @ C$min$ = Vx Vk"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 RDOM ((R :\u03b1 -> \u03b2 -> bool) \\ (k :\u03b1)) \u21d4 x \u2208 RDOM R \u2227 x \u2260 k"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, relationTheory.WFP_RULES, relationTheory.symmetric_TC, relationTheory.RRESTRICT_DEF, relationTheory.RTC_CASES_TC]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[relationTheory.inv_O, relationTheory.inv_image_def, relationTheory.STRORD_AND_NOT_Id, relationTheory.INVOL_ONE_ENO, relationTheory.EQC_EQUIVALENCE]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (RC R) \u21d4 symmetric R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ symmetric @ C$relation$ RC VR @ C$relation$ symmetric VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). symmetric (RC R) \u21d4 symmetric R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ VR Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ VR Vy Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ VR Vx Vy @ @ VR Vy Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). x = y \u2228 (R :\u03b1 -> \u03b1 -> bool) x y \u21d4 y = x \u2228 R y x) \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 R y x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.SC_DEF, boolTheory.RIGHT_FORALL_IMP_THM, relationTheory.symmetric_def, boolTheory.EQ_TRANS, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.irreflexive_def, boolTheory.EQ_TRANS, boolTheory.EQ_SYM, boolTheory.EXISTS_UNIQUE_DEF, relationTheory.RTC_RTC]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ INTER Vs @ @ C$pred_set$ UNION Vt Vu @ @ C$pred_set$ UNION @ @ C$pred_set$ INTER Vs Vt @ @ C$pred_set$ INTER Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vu @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vu"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 (s :\u03b1 -> bool) \u2227 (x \u2208 (t :\u03b1 -> bool) \u2228 x \u2208 (u :\u03b1 -> bool)) \u21d4 x \u2208 s \u2227 x \u2208 t \u2228 x \u2208 s \u2227 x \u2208 u"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_UNION, pred_setTheory.IN_INTER, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.PAIR_IN_GSPEC_IFF, pred_setTheory.EQ_SUBSET_SUBSET, boolTheory.EQ_EXT, pred_setTheory.EMPTY_UNION]", "reward": 5}]], "(\u2200(l :\u03b1 list). BUTLASTN (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b2) (l :\u03b2 list). BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN C$num$ 0 Vl Vl @ C$bool$ ! | Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN @ C$num$ SUC Vn @ @ C$list$ SNOC Vx Vl @ @ C$rich_list$ BUTLASTN Vn Vl"}, "plain": {"assumptions": [], "goal": "(\u2200(l :\u03b1 list). BUTLASTN (0 :num) l = l) \u2227 \u2200(n :num) (x :\u03b2) (l :\u03b2 list). BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.ZIP_EQ_NIL, rich_listTheory.BUTLASTN_def, listTheory.dropWhile_APPEND_EVERY, listTheory.nub_set, boolTheory.RES_EXISTS_FALSE]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (D :\u03b1 -> bool) (P :\u03b1 -> \u03b2 -> bool) (M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (x :\u03b1). f = WFREC R M \u2227 WF R \u2227 INDUCTIVE_INVARIANT_ON R D P M \u2227 D x \u21d2 P x (f x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VR @ C$bool$ ! | VD @ C$bool$ ! | VP @ C$bool$ ! | VM @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vf @ @ C$relation$ WFREC VR VM @ @ C$bool$ /\\ @ C$relation$ WF VR @ @ C$bool$ /\\ @ @ @ @ C$relation$ INDUCTIVE_INVARIANT_ON VR VD VP VM @ VD Vx @ @ VP Vx @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (R :\u03b1 -> \u03b1 -> bool) (D :\u03b1 -> bool) (P :\u03b1 -> \u03b2 -> bool) (M :(\u03b1 -> \u03b2) -> \u03b1 -> \u03b2) (x :\u03b1). f = WFREC R M \u2227 WF R \u2227 INDUCTIVE_INVARIANT_ON R D P M \u2227 D x \u21d2 P x (f x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.SELECT_THM, relationTheory.INDUCTIVE_INVARIANT_ON_WFREC, relationTheory.RTC_ALT_INDUCT, boolTheory.MONO_COND, relationTheory.transitive_TC_identity]", "reward": 5}]], "\u2200(l :\u03b1 list) (x :\u03b1). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$rich_list$ SEG @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$list$ LENGTH Vl @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (x :\u03b1). SEG (1 :num) (LENGTH l) (SNOC x l) = [x]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.SUB_LEFT_EQ, rich_listTheory.DROP_APPEND2, listTheory.EL_REVERSE, rich_listTheory.FOLDL_SINGLE, rich_listTheory.SEG_TAKE_DROP]", "reward": 5}]], "\u2200(x :\u03b1). x INSERT \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ INSERT Vx C$pred_set$ UNIV C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x INSERT \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ONE_ONE_THM, pred_setTheory.ABSORPTION_RWT, boolTheory.ONE_ONE_THM, boolTheory.DATATYPE_TAG_THM, pred_setTheory.IN_UNIV]", "reward": 5}]], "MIN (0 :num) (x :num) = (0 :num) \u2227 MIN x (0 :num) = (0 :num) \u2227 MIN (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then x else y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$arithmetic$ MIN C$num$ 0 Vx C$num$ 0 @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$arithmetic$ MIN Vx C$num$ 0 C$num$ 0 @ @ C$min$ = @ @ C$arithmetic$ MIN @ C$arithmetic$ NUMERAL Vx @ C$arithmetic$ NUMERAL Vy @ C$arithmetic$ NUMERAL @ @ @ C$bool$ COND @ @ C$prim_rec$ < Vx Vy Vx Vy"}, "plain": {"assumptions": [], "goal": "MIN (0 :num) (x :num) = (0 :num) \u2227 MIN x (0 :num) = (0 :num) \u2227 MIN (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then x else y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.NUMERAL_DEF, prim_recTheory.NOT_LESS_EQ, arithmeticTheory.ONE, arithmeticTheory.MIN_0, arithmeticTheory.MIN_DEF]", "reward": 5}]], "\u2200(xs :\u03b1 list) (h :\u03b1) (i :num). (P :\u03b1 -> bool) h \u2227 EVERY P xs \u21d2 EVERY P (LUPDATE h i xs)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ C$bool$ ! | Vh @ C$bool$ ! | Vi @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vh @ @ C$list$ EVERY VP Vxs @ @ C$list$ EVERY VP @ @ @ C$list$ LUPDATE Vh Vi Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list) (h :\u03b1) (i :num). (P :\u03b1 -> bool) h \u2227 EVERY P xs \u21d2 EVERY P (LUPDATE h i xs)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ @ C$list$ LUPDATE Vh Vi Vxs", "@ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vxs @ VP Ve", "@ VP Vh"], "goal": "@ VP Ve"}, "plain": {"assumptions": ["MEM (e :\u03b1) (LUPDATE (h :\u03b1) (i :num) (xs :\u03b1 list))", "\u2200(e :\u03b1). MEM e (xs :\u03b1 list) \u21d2 (P :\u03b1 -> bool) e", "(P :\u03b1 -> bool) (h :\u03b1)"], "goal": "(P :\u03b1 -> bool) (e :\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, listTheory.EXISTS_MAP, listTheory.DROP_nil, listTheory.EVERY_MEM, listTheory.EL]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.FILTER_EQ_CONS, listTheory.MEM_LUPDATE_E, listTheory.EVERYi_def, boolTheory.AND1_THM, listTheory.LIST_BIND_def]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a (t \u222a u) = s \u222a t \u222a u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ UNION Vs @ @ C$pred_set$ UNION Vt Vu @ @ C$pred_set$ UNION @ @ C$pred_set$ UNION Vs Vt Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a (t \u222a u) = s \u222a t \u222a u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, pred_setTheory.PSUBSET_UNIV, boolTheory.DISJ_ASSOC, pred_setTheory.K_SUBSET]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). SURJ f s t \u21d4 IMAGE f s = t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ @ C$pred_set$ SURJ Vf Vs Vt @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). SURJ f s t \u21d4 IMAGE f s = t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 (\u2200(x :\u03b2). x \u2208 t \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 f y = x) \u21d4 IMAGE f s = t"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.SURJ_DEF, pred_setTheory.SUBSET_DEF, boolTheory.AND1_THM, pred_setTheory.UNION_SUBSET, pred_setTheory.EMPTY_UNION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ IMAGE Vf Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 (\u2200(x :\u03b2). x \u2208 t \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 f y = x) \u21d4 \u2200(x :\u03b2). IMAGE f s x \u21d4 t x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_UNION, pred_setTheory.PAIR_IN_GSPEC_IFF, pred_setTheory.INTER_DEF, pred_setTheory.DELETE_applied, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_EMPTY, pred_setTheory.IN_REST, pred_setTheory.IMAGE_applied, pred_setTheory.REST_DEF]", "reward": 5}]], "SND (p :\u03b2 # \u03b1) = (y :\u03b1) \u21d4 \u2203(x :\u03b2). p = (x,y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$pair$ SND Vp Vy @ C$bool$ ? | Vx @ @ C$min$ = Vp @ @ C$pair$ , Vx Vy"}, "plain": {"assumptions": [], "goal": "SND (p :\u03b2 # \u03b1) = (y :\u03b1) \u21d4 \u2203(x :\u03b2). p = (x,y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.DISJ_ASSOC, pairTheory.PAIR, pairTheory.CURRY_DEF, boolTheory.NOT_F, pairTheory.PAIR_EQ]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R1 :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b1 -> bool) x y) \u2227 (\u2200(x :\u03b2) (y :\u03b2). (R3 :\u03b2 -> \u03b2 -> bool) x y \u21d2 (R4 :\u03b2 -> \u03b2 -> bool) x y) \u21d2 (R1 LEX R3) (x :\u03b1 # \u03b2) (y :\u03b1 # \u03b2) \u21d2 (R2 LEX R4) x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR1 Vx Vy @ @ VR2 Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR3 Vx Vy @ @ VR4 Vx Vy @ @ C$min$ ==> @ @ @ @ C$pair$ LEX VR1 VR3 Vx Vy @ @ @ @ C$pair$ LEX VR2 VR4 Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R1 :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b1 -> bool) x y) \u2227 (\u2200(x :\u03b2) (y :\u03b2). (R3 :\u03b2 -> \u03b2 -> bool) x y \u21d2 (R4 :\u03b2 -> \u03b2 -> bool) x y) \u21d2 (R1 LEX R3) (x :\u03b1 # \u03b2) (y :\u03b1 # \u03b2) \u21d2 (R2 LEX R4) x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.DISJ_IMP_THM, pairTheory.LEX_DEF, boolTheory.EQ_EXPAND, pairTheory.ELIM_UNCURRY, pairTheory.pair_case_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). antisymmetric (RC R) \u21d4 antisymmetric R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ antisymmetric @ C$relation$ RC VR @ C$relation$ antisymmetric VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). antisymmetric (RC R) \u21d4 antisymmetric R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.NOT_FORALL_THM, boolTheory.EXCLUDED_MIDDLE, relationTheory.total_def, relationTheory.RC_DEF, relationTheory.antisymmetric_def]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE y = s DELETE y DELETE x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DELETE @ @ C$pred_set$ DELETE Vs Vx Vy @ @ C$pred_set$ DELETE @ @ C$pred_set$ DELETE Vs Vy Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b1) (s :\u03b1 -> bool). s DELETE x DELETE y = s DELETE y DELETE x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$min$ = Vx' Vy @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ C$bool$ ~ @ @ C$min$ = Vx' Vy @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ @ C$min$ = Vx' Vx @ @ C$min$ = Vx' Vy @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ @ C$min$ = Vx' Vy @ @ C$min$ = Vx' Vx"}, "plain": {"assumptions": [], "goal": "(((x' :\u03b1) \u2208 (s :\u03b1 -> bool) \u2227 x' \u2260 (x :\u03b1)) \u2227 x' \u2260 (y :\u03b1)) \u2227 (x' \u2208 s \u2227 x' \u2260 y) \u2227 x' \u2260 x \u2228 ((x' \u2209 s \u2228 x' = x) \u2228 x' = y) \u2227 ((x' \u2209 s \u2228 x' = y) \u2228 x' = x)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, boolTheory.MONO_EXISTS, pred_setTheory.IN_DELETE, pred_setTheory.EQ_SUBSET_SUBSET, boolTheory.EQ_EXPAND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INTER_applied, pred_setTheory.IN_INTER, boolTheory.DISJ_EQ_IMP, pred_setTheory.MEMBER_NOT_EMPTY, boolTheory.COND_ABS]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s DIFF (\u2205 :\u03b1 -> bool) = s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DIFF Vs C$pred_set$ EMPTY Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s DIFF (\u2205 :\u03b1 -> bool) = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ DIFF Vs | Vx C$bool$ F Vs"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) DIFF (\u03bb(x :\u03b1). F) = s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.T_DEF, boolTheory.TYPE_DEFINITION_THM, pred_setTheory.INTER_applied, pred_setTheory.EMPTY_DEF, boolTheory.NOT_FORALL_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_ABS, pred_setTheory.IN_APP, pred_setTheory.DIFF_applied, pred_setTheory.DIFF_DEF, boolTheory.FUN_EQ_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). x \u2208 PREIMAGE f s \u21d4 f x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$bool$ IN @ Vf Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (x :\u03b1). x \u2208 PREIMAGE f s \u21d4 f x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_INFINITE_NOT_FINITE, pred_setTheory.IN_GSPEC_IFF, boolTheory.COND_RAND, pred_setTheory.PREIMAGE_def, pred_setTheory.DISJOINT_SUBSET]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1). R\u207a x z \u21d2 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ @ C$relation$ TC VR Vx Vz @ @ C$bool$ \\/ @ @ VR Vx Vz @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ @ C$relation$ TC VR Vy Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1). R\u207a x z \u21d2 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.SC_DEF, relationTheory.RTC_CASES1, relationTheory.EXTEND_RTC_TC_EQN, relationTheory.RTC_CASES_TC, relationTheory.EXTEND_RTC_TC_EQN]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (b :\u03b1). Q b \u2227 (\u2200(x :\u03b1) (y :\u03b1). R x y \u2227 Q y \u21d2 Q x) \u21d2 \u2200(x :\u03b1). R\ua673 x b \u21d2 Q x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VQ @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vb @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ VQ Vy @ VQ Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vx Vb @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (Q :\u03b1 -> bool) (b :\u03b1). Q b \u2227 (\u2200(x :\u03b1) (y :\u03b1). R x y \u2227 Q y \u21d2 Q x) \u21d2 \u2200(x :\u03b1). R\ua673 x b \u21d2 Q x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.OR_DEF, relationTheory.RTC_def, boolTheory.IMP_F, relationTheory.RTC_ALT_DEF, boolTheory.AND1_THM]", "reward": 5}]], "\u2200(j :num) (n :num) (h :\u03b1) (t :\u03b1 list). (0 :num) < j \u2227 n + j \u2264 LENGTH t + (1 :num) \u21d2 SEG n j (h::t) = SEG n (j \u2212 (1 :num)) t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vj @ C$bool$ ! | Vn @ C$bool$ ! | Vh @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$prim_rec$ < C$num$ 0 Vj @ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vn Vj @ @ C$arithmetic$ + @ C$list$ LENGTH Vt @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ @ C$min$ = @ @ @ C$rich_list$ SEG Vn Vj @ @ C$list$ CONS Vh Vt @ @ @ C$rich_list$ SEG Vn @ @ C$arithmetic$ - Vj @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vt"}, "plain": {"assumptions": [], "goal": "\u2200(j :num) (n :num) (h :\u03b1) (t :\u03b1 list). (0 :num) < j \u2227 n + j \u2264 LENGTH t + (1 :num) \u21d2 SEG n j (h::t) = SEG n (j \u2212 (1 :num)) t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[rich_listTheory.FILTER_IDEM, listTheory.FRONT_DEF, arithmeticTheory.SUC_SUB1, rich_listTheory.OR_EL_DEF, rich_listTheory.SEG_TAKE_DROP]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 transitive (RC R)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ transitive VR @ C$relation$ transitive @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 transitive (RC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ @ C$relation$ RC VR Vy Vz", "@ @ @ C$relation$ RC VR Vx Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"], "goal": "@ @ @ C$relation$ RC VR Vx Vz"}, "plain": {"assumptions": ["RC (R :\u03b1 -> \u03b1 -> bool) (y :\u03b1) (z :\u03b1)", "RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1)", "\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z"], "goal": "RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EXISTS_UNIQUE_REFL, relationTheory.transitive_def, boolTheory.OR_INTRO_THM2, boolTheory.OR_CONG, boolTheory.BOTH_EXISTS_AND_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.COND_RATOR, relationTheory.RC_DEF, boolTheory.EQ_CLAUSES, relationTheory.RTC_REFL, boolTheory.EXISTS_REFL]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R\ua673 (x :\u03b1) (y :\u03b1) \u21d2 Q\ua673 x y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VQ Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vx Vy @ @ @ C$relation$ RTC VQ Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (Q :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R\ua673 (x :\u03b1) (y :\u03b1) \u21d2 Q\ua673 x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ? | VQ @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ VQ Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vy @ C$bool$ ~ @ @ VR Vy Vz @ VQ Vz @ C$bool$ ~ @ VQ Vy @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ C$bool$ ~ @ @ VQ Vx Vy @ C$bool$ ! | VQ' @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ' Vx @ C$bool$ ? | Vy @ C$bool$ ? | Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ VQ' Vy @ @ VQ Vy Vz @ C$bool$ ~ @ VQ' Vz @ VQ' Vy"}, "plain": {"assumptions": [], "goal": "(\u2203(Q :\u03b1 -> bool). (Q (x :\u03b1) \u2227 \u2200(y :\u03b1) (z :\u03b1). (\u00acQ y \u2228 \u00ac(R :\u03b1 -> \u03b1 -> bool) y z) \u2228 Q z) \u2227 \u00acQ (y :\u03b1)) \u2228 (\u2203(x :\u03b1) (y :\u03b1). R x y \u2227 \u00ac(Q :\u03b1 -> \u03b1 -> bool) x y) \u2228 \u2200(Q' :\u03b1 -> bool). (\u00acQ' x \u2228 \u2203(y :\u03b1) (z :\u03b1). (Q' y \u2227 Q y z) \u2227 \u00acQ' z) \u2228 Q' y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.SC_lifts_monotonicities, boolTheory.AND_INTRO_THM, boolTheory.IMP_DISJ_THM, relationTheory.RTC_ALT_RIGHT_DEF, boolTheory.EQ_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.transitive_RC, relationTheory.TC_STRONG_INDUCT_RIGHT1, boolTheory.itself_case_thm, boolTheory.OR_IMP_THM, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN]", "reward": 5}]], "\u2200(n :num). EL n (l :\u03b1 list) = if n = (0 :num) then HD l else EL (PRE n) (TL l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ EL Vn Vl @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn @ C$list$ TL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). EL n (l :\u03b1 list) = if n = (0 :num) then HD l else EL (PRE n) (TL l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ EL C$num$ 0 Vl @ @ @ C$bool$ COND @ @ C$min$ = C$num$ 0 C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE C$num$ 0 @ C$list$ TL Vl"}, "plain": {"assumptions": [], "goal": "EL (0 :num) (l :\u03b1 list) = if (0 :num) = (0 :num) then HD l else EL (PRE (0 :num)) (TL l)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ EL Vn Vl @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn @ C$list$ TL Vl"], "goal": "@ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn Vl @ @ @ C$bool$ COND @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE @ C$num$ SUC Vn @ C$list$ TL Vl"}, "plain": {"assumptions": ["EL (n :num) (l :\u03b1 list) = if n = (0 :num) then HD l else EL (PRE n) (TL l)"], "goal": "EL (SUC (n :num)) (l :\u03b1 list) = if SUC n = (0 :num) then HD l else EL (PRE (SUC n)) (TL l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ EL Vn Vl @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE Vn @ C$list$ TL Vl"], "goal": "@ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn Vl @ @ @ C$bool$ COND @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ C$list$ HD Vl @ @ C$list$ EL @ C$prim_rec$ PRE @ C$num$ SUC Vn @ C$list$ TL Vl"}, "plain": {"assumptions": ["EL (n :num) (l :\u03b1 list) = if n = (0 :num) then HD l else EL (PRE n) (TL l)"], "goal": "EL (SUC (n :num)) (l :\u03b1 list) = if SUC n = (0 :num) then HD l else EL (PRE (SUC n)) (TL l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.RIGHT_FORALL_OR_THM, listTheory.list_CASES, prim_recTheory.WF_PRED, listTheory.EL, listTheory.EL_MAP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.list_CASES, listTheory.MEM, prim_recTheory.WF_PRED, listTheory.EL, listTheory.EL]", "reward": 5}]], "\u2200(m :num) (l :\u03b1 list) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (l :\u03b1 list) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm C$list$ NIL @ @ C$list$ TAKE Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m ([] :\u03b1 list)) = TAKE n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m (l :\u03b1 list)) = TAKE n l"], "goal": "\u2200(h :\u03b1) (m :num) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m (h::(l :\u03b1 list))) = TAKE n (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m (l :\u03b1 list)) = TAKE n l"], "goal": "\u2200(h :\u03b1) (m :num) (n :num). n \u2264 m \u21d2 TAKE n (TAKE m (h::(l :\u03b1 list))) = TAKE n (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.GENLIST_AUX_compute, listTheory.LIST_REL_SPLIT2, listTheory.nub_def, listTheory.EL_compute, listTheory.SINGL_APPLY_MAP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.ZIP_EQ_NIL, listTheory.dropWhile_APPEND_EXISTS, listTheory.LENGTH_EQ_CONS, listTheory.TAKE_def, rich_listTheory.EVERY2_APPEND_suff]", "reward": 5}]], "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool). irreflexive R2 \u2227 R1 \u2286\u1d63 R2 \u21d2 irreflexive R1": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR1 @ C$bool$ ! | VR2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$relation$ irreflexive VR2 @ @ C$relation$ RSUBSET VR1 VR2 @ C$relation$ irreflexive VR1"}, "plain": {"assumptions": [], "goal": "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool). irreflexive R2 \u2227 R1 \u2286\u1d63 R2 \u21d2 irreflexive R1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.irreflexive_def, boolTheory.literal_case_RAND, relationTheory.inv_DEF, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, relationTheory.RSUBSET]", "reward": 5}]], "\u2200(e :\u03b1) (l :\u03b1 list). LIST_ELEM_COUNT e l > (0 :num) \u21d4 MEM e l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$arithmetic$ > @ @ C$rich_list$ LIST_ELEM_COUNT Ve Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l :\u03b1 list). LIST_ELEM_COUNT e l > (0 :num) \u21d4 MEM e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l :\u03b1 list). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) l) > (0 :num) \u21d4 MEM e l"}}], "parent": 0, "goal": 0, "by_tactic": "simp[rich_listTheory.TAKE_APPEND, rich_listTheory.LIST_ELEM_COUNT_DEF, rich_listTheory.UNZIP_FST_DEF, listTheory.EL_GENLIST, rich_listTheory.BUTLASTN_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve C$list$ NIL C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) ([] :\u03b1 list)) > (0 :num) \u21d4 MEM e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve @ @ C$list$ CONS Vh Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) (l :\u03b1 list)) > (0 :num) \u21d4 MEM e l"], "goal": "\u2200(h :\u03b1) (e :\u03b1). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) (h::(l :\u03b1 list))) > (0 :num) \u21d4 MEM e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$arithmetic$ > @ C$list$ LENGTH @ @ C$list$ FILTER | Vx @ @ C$min$ = Vx Ve @ @ C$list$ CONS Vh Vl C$num$ 0 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) (l :\u03b1 list)) > (0 :num) \u21d4 MEM e l"], "goal": "\u2200(h :\u03b1) (e :\u03b1). LENGTH (FILTER (\u03bb(x :\u03b1). x = e) (h::(l :\u03b1 list))) > (0 :num) \u21d4 MEM e (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[arithmeticTheory.MIN_IDEM, arithmeticTheory.MODEQ_REFL, listTheory.EVERY2_EVERY, arithmeticTheory.ODD_EVEN, arithmeticTheory.MOD_1]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_SING, rich_listTheory.COUNT_LIST_GENLIST, listTheory.SUM_IMAGE_LIST_TO_SET_upper_bound, rich_listTheory.MAP_COUNT_LIST, rich_listTheory.MAP_COUNT_LIST]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 t \u21d2 DISJOINT s u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vs Vt @ @ C$pred_set$ SUBSET Vu Vt @ @ C$pred_set$ DISJOINT Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). DISJOINT s t \u2227 u \u2286 t \u21d2 DISJOINT s u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vu @ @ C$bool$ IN Vx Vt", "@ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vu"}, "plain": {"assumptions": ["\u2200(x :\u03b1). x \u2208 (u :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b1 -> bool)", "\u2200(x :\u03b1). x \u2209 (s :\u03b1 -> bool) \u2228 x \u2209 (t :\u03b1 -> bool)"], "goal": "(x :\u03b1) \u2209 (s :\u03b1 -> bool) \u2228 x \u2209 (u :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, boolTheory.bool_case_thm, boolTheory.literal_case_CONG, pred_setTheory.SUBSET_INTER, pred_setTheory.IN_DISJOINT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.GSPECIFICATION_applied, pred_setTheory.IN_UNION, boolTheory.FUN_EQ_THM, pred_setTheory.EXTENSION, pred_setTheory.NOT_EQUAL_SETS]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y) \u21d2 (DISJOINT (IMAGE f (s1 :\u03b1 -> bool)) (IMAGE f (s2 :\u03b1 -> bool)) \u21d4 DISJOINT s1 s2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ C$min$ = @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ IMAGE Vf Vs1 @ @ C$pred_set$ IMAGE Vf Vs2 @ @ C$pred_set$ DISJOINT Vs1 Vs2"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y) \u21d2 (DISJOINT (IMAGE f (s1 :\u03b1 -> bool)) (IMAGE f (s2 :\u03b1 -> bool)) \u21d4 DISJOINT s1 s2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy"], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$min$ = Vx @ Vf Vx' @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs1 @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$min$ = Vx @ Vf Vx' @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs2 @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs1 @ C$bool$ ~ @ @ C$bool$ IN Vx Vs2"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b1). (f :\u03b1 -> \u03b2) x = f y \u21d4 x = y"], "goal": "(\u2200(x :\u03b2). (\u2200(x' :\u03b1). x = (f :\u03b1 -> \u03b2) x' \u21d2 x' \u2209 (s1 :\u03b1 -> bool)) \u2228 \u2200(x' :\u03b1). x = f x' \u21d2 x' \u2209 (s2 :\u03b1 -> bool)) \u21d4 \u2200(x :\u03b1). x \u2209 s1 \u2228 x \u2209 s2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DISJOINT, boolTheory.UNWIND_FORALL_THM1, boolTheory.LEFT_OR_OVER_AND, pred_setTheory.IMAGE_UNION, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.ETA_THM, pred_setTheory.UNIV_applied, pred_setTheory.FORALL_IN_INSERT, pred_setTheory.IN_DISJOINT, pred_setTheory.UNION_DEF]", "reward": 5}]], "\u2200(e :\u03b1) (s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 s1 \u2286 e INSERT s2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs1 Vs2 @ @ C$pred_set$ SUBSET Vs1 @ @ C$pred_set$ INSERT Ve Vs2"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 s1 \u2286 e INSERT s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM2, pred_setTheory.IN_IMAGE, pred_setTheory.IN_DISJOINT, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_INSERT]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list list). FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list list). FILTER P (FLAT l) = FLAT (MAP (FILTER P) l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). FILTER P (FLAT ([] :\u03b1 list list)) = FLAT (MAP (FILTER P) ([] :\u03b1 list list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). FILTER P (FLAT (l :\u03b1 list list)) = FLAT (MAP (FILTER P) l)"], "goal": "\u2200(h :\u03b1 list) (P :\u03b1 -> bool). FILTER P (FLAT (h::(l :\u03b1 list list))) = FLAT (MAP (FILTER P) (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$min$ = @ @ C$list$ FILTER VP @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ @ C$list$ MAP @ C$list$ FILTER VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). FILTER P (FLAT (l :\u03b1 list list)) = FLAT (MAP (FILTER P) l)"], "goal": "\u2200(h :\u03b1 list) (P :\u03b1 -> bool). FILTER P (FLAT (h::(l :\u03b1 list list))) = FLAT (MAP (FILTER P) (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.oEL_THM, boolTheory.MONO_NOT_EQ, listTheory.FRONT_CONS, listTheory.SET_TO_LIST_IN_MEM, listTheory.LAST_CONS_cond]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.ALL_DISTINCT_REVERSE, listTheory.list_case_compute, listTheory.FILTER_APPEND_DISTRIB, listTheory.TAKE1, listTheory.oEL_TAKE_E]", "reward": 5}]], "DROP (0 :num) (l :\u03b1 list) = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ DROP C$num$ 0 Vl Vl"}, "plain": {"assumptions": [], "goal": "DROP (0 :num) (l :\u03b1 list) = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ DROP C$num$ 0 C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "DROP (0 :num) ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP C$num$ 0 Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ DROP C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["DROP (0 :num) (l :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). DROP (0 :num) (h::(l :\u03b1 list)) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP C$num$ 0 Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ DROP C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["DROP (0 :num) (l :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). DROP (0 :num) (h::(l :\u03b1 list)) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.REVERSE_REVERSE, listTheory.EVERY_NOT_EXISTS, listTheory.DROP_nil, listTheory.FILTER_F, listTheory.LENGTH_NIL]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.FILTER_EQ_APPEND, listTheory.DROP_def, listTheory.MAP_o, listTheory.LENGTH_EQ_NIL]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). (P \u00d7 Q) x \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ CROSS VP VQ Vx @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx VP @ @ C$bool$ IN @ C$pair$ SND Vx VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1 # \u03b2). (P \u00d7 Q) x \u21d4 FST x \u2208 P \u2227 SND x \u2208 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPEC_ETA, pred_setTheory.IN_INTER, pred_setTheory.SUBSET_DEF, pred_setTheory.CROSS_DEF, pred_setTheory.PSUBSET_DEF]", "reward": 5}]], "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2) (s :\u03b1 -> bool). IMAGE (f \u2218 g) s = IMAGE f (IMAGE g s)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ IMAGE @ @ C$combin$ o Vf Vg Vs @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ IMAGE Vg Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2) (s :\u03b1 -> bool). IMAGE (f \u2218 g) s = IMAGE f (IMAGE g s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf @ Vg Vx' @ Vs Vx' @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx' @ Vg Vx @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(x' :\u03b1). (x :\u03b3) = (f :\u03b2 -> \u03b3) ((g :\u03b1 -> \u03b2) x') \u2227 (s :\u03b1 -> bool) x') \u21d4 \u2203(x' :\u03b2). x = f x' \u2227 \u2203(x :\u03b1). x' = g x \u2227 s x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.SPECIFICATION, pred_setTheory.ABSORPTION, pred_setTheory.SUBSET_DEF, pred_setTheory.IMAGE_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_REST, pred_setTheory.REST_applied, pred_setTheory.IMAGE_applied, pred_setTheory.NOT_SING_EMPTY]", "reward": 5}]], "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 l \u21d2 EVERY P1 (FILTER P2 l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP1 @ C$bool$ ! | VP2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$list$ EVERY VP1 Vl @ @ C$list$ EVERY VP1 @ @ C$list$ FILTER VP2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 l \u21d2 EVERY P1 (FILTER P2 l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_MAP2, boolTheory.CONJ_ASSOC, listTheory.MEM_FILTER, listTheory.APPEND_ASSOC, listTheory.EVERY_MEM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (DROP m l)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list) (m :num). EVERY P l \u21d2 EVERY P (DROP m l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP C$list$ NIL @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (m :num). EVERY P ([] :\u03b1 list) \u21d2 EVERY P (DROP m ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (DROP m l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (m :num). EVERY P (h::(l :\u03b1 list)) \u21d2 EVERY P (DROP m (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP @ @ C$list$ CONS Vh Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (DROP m l)"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool) (m :num). EVERY P (h::(l :\u03b1 list)) \u21d2 EVERY P (DROP m (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.GENLIST_CONG, listTheory.ALL_DISTINCT_ZIP, listTheory.TL_GENLIST, listTheory.FOLDL_SNOC, listTheory.FOLDL_SNOC]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ EVERY VP Vl", "@ VP Vh", "@ C$bool$ ! | VP @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$list$ EVERY VP Vl @ @ C$list$ EVERY VP @ @ C$list$ DROP Vm Vl"], "goal": "@ @ C$list$ EVERY VP @ @ @ C$bool$ COND @ @ C$min$ = Vm C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vm @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl"}, "plain": {"assumptions": ["EVERY (P :\u03b1 -> bool) (l :\u03b1 list)", "(P :\u03b1 -> bool) (h :\u03b1)", "\u2200(P :\u03b1 -> bool) (m :num). EVERY P (l :\u03b1 list) \u21d2 EVERY P (DROP m l)"], "goal": "EVERY (P :\u03b1 -> bool) (if (m :num) = (0 :num) then (h :\u03b1)::(l :\u03b1 list) else DROP (m \u2212 (1 :num)) l)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_SPLIT2, listTheory.MEM_LUPDATE, listTheory.DROP_def, listTheory.SING_HD, listTheory.MAP]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.list_CASES, listTheory.MAP_GENLIST, listTheory.DROP_TAKE, listTheory.TL_GENLIST, listTheory.EVERY2_LUPDATE_same]", "reward": 5}]], "UNZIP ([] :(\u03b1 # \u03b2) list) = (([] :\u03b1 list),([] :\u03b2 list)) \u2227 UNZIP (((x :\u03b1),(y :\u03b2))::(t :(\u03b1 # \u03b2) list)) = (let ((L1 :\u03b1 list),(L2 :\u03b2 list)) = UNZIP t in (x::L1,y::L2))": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ UNZIP C$list$ NIL @ @ C$pair$ , C$list$ NIL C$list$ NIL @ @ C$min$ = @ C$list$ UNZIP @ @ C$list$ CONS @ @ C$pair$ , Vx Vy Vt @ @ C$bool$ LET @ C$pair$ UNCURRY | VL1 | VL2 @ @ C$pair$ , @ @ C$list$ CONS Vx VL1 @ @ C$list$ CONS Vy VL2 @ C$list$ UNZIP Vt"}, "plain": {"assumptions": [], "goal": "UNZIP ([] :(\u03b1 # \u03b2) list) = (([] :\u03b1 list),([] :\u03b2 list)) \u2227 UNZIP (((x :\u03b1),(y :\u03b2))::(t :(\u03b1 # \u03b2) list)) = (let ((L1 :\u03b1 list),(L2 :\u03b2 list)) = UNZIP t in (x::L1,y::L2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.LEX_DEF, listTheory.UNZIP, pairTheory.UNCURRY_VAR, pairTheory.UNCURRY_ONE_ONE_THM, boolTheory.ABS_SIMP]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EVERY P (l1 ++ l2) \u21d4 EVERY P l1 \u2227 EVERY P l2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$list$ EVERY VP Vl1 @ @ C$list$ EVERY VP Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l1 :\u03b1 list) (l2 :\u03b1 list). EVERY P (l1 ++ l2) \u21d4 EVERY P l1 \u2227 EVERY P l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ VP Ve @ C$bool$ ! | Ve @ C$bool$ ! | Ve' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ VP Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve' @ C$list$ LIST_TO_SET Vl2 @ VP Ve'"}, "plain": {"assumptions": [], "goal": "(\u2200(e :\u03b1). MEM e ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d2 (P :\u03b1 -> bool) e) \u21d4 \u2200(e :\u03b1) (e' :\u03b1). (MEM e l1 \u21d2 P e) \u2227 (MEM e' l2 \u21d2 P e')"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_MEM, listTheory.NULL_DEF, boolTheory.PULL_FORALL, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.literal_case_CONG]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.EL_MAP2, listTheory.MEM_APPEND, boolTheory.LEFT_FORALL_IMP_THM, boolTheory.SELECT_ELIM_THM, listTheory.MEM_APPEND]", "reward": 5}]], "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 FINITE s \u21d2 CARD (IMAGE f s) = CARD s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ @ C$min$ = @ C$pred_set$ CARD @ @ C$pred_set$ IMAGE Vf Vs @ C$pred_set$ CARD Vs"}, "plain": {"assumptions": [], "goal": "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 FINITE s \u21d2 CARD (IMAGE f s) = CARD s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.REST_PSUBSET, pred_setTheory.FINITE_DIFF_down, pred_setTheory.INJ_CARD_IMAGE, pred_setTheory.UNIV_applied, pred_setTheory.SCHROEDER_CLOSED]", "reward": 5}]], "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n \u2212 LENGTH l1) l2": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). TAKE n (l1 ++ l2) = TAKE n l1 ++ TAKE (n \u2212 LENGTH l1) l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH C$list$ NIL Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l2 :\u03b1 list). TAKE n (([] :\u03b1 list) \u29fa l2) = TAKE n ([] :\u03b1 list) \u29fa TAKE (n \u2212 LENGTH ([] :\u03b1 list)) l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). TAKE n ((l1 :\u03b1 list) \u29fa l2) = TAKE n l1 \u29fa TAKE (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). TAKE n (h::(l1 :\u03b1 list) \u29fa l2) = TAKE n (h::l1) \u29fa TAKE (n \u2212 LENGTH (h::l1)) l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). TAKE n ((l1 :\u03b1 list) \u29fa l2) = TAKE n l1 \u29fa TAKE (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). TAKE n (h::(l1 :\u03b1 list) \u29fa l2) = TAKE n (h::l1) \u29fa TAKE (n \u2212 LENGTH (h::l1)) l2"}}], "parent": 1, "goal": 0, "by_tactic": "fs[arithmeticTheory.ABS_DIFF_SUC_LE, arithmeticTheory.LEFT_ADD_DISTRIB, arithmeticTheory.SUB_LESS, boolTheory.FUN_EQ_THM, listTheory.MAP_GENLIST]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ TAKE Vn Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ @ C$min$ = @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ APPEND @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ @ C$arithmetic$ + @ C$list$ LENGTH Vl1 @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl2 @ @ C$list$ APPEND @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$num$ SUC @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). TAKE n ((l1 :\u03b1 list) \u29fa l2) = TAKE n l1 \u29fa TAKE (n \u2212 LENGTH l1) l2"], "goal": "(if (n :num) = (0 :num) then ([] :\u03b1 list) else (h :\u03b1):: (TAKE (n \u2212 (1 :num)) (l1 :\u03b1 list) \u29fa TAKE (n \u2212 (LENGTH l1 + (1 :num))) (l2 :\u03b1 list))) = (if n = (0 :num) then ([] :\u03b1 list) else h::TAKE (n \u2212 (1 :num)) l1) \u29fa TAKE (n \u2212 SUC (LENGTH l1)) l2"}}], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.MULT_EXP_MONO, arithmeticTheory.SUB_LEFT_EQ, listTheory.TAKE_def, listTheory.DISJOINT_GENLIST_PLUS, listTheory.OPT_MMAP_def]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[arithmeticTheory.WOP_measure, listTheory.LIST_TO_SET_FLAT, arithmeticTheory.SUC_ONE_ADD, listTheory.OPT_MMAP_def, arithmeticTheory.INV_PRE_LESS_EQ]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). WFP R x \u21d2 P x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vy Vx @ VP Vy @ VP Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$relation$ WFP VR Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). WFP R x \u21d2 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.TC_TRANSITIVE, boolTheory.COND_EXPAND_IMP, boolTheory.LEFT_EXISTS_IMP_THM, boolTheory.T_DEF, relationTheory.WFP_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s \u2282 \ud835\udd4c(:\u03b1) \u21d4 \u2203(x :\u03b1). x \u2209 s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ PSUBSET Vs C$pred_set$ UNIV @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s \u2282 \ud835\udd4c(:\u03b1) \u21d4 \u2203(x :\u03b1). x \u2209 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs C$pred_set$ UNIV @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$min$ = @ Vs Vx @ C$pred_set$ UNIV Vx @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2286 \ud835\udd4c(:\u03b1) \u2227 (\u2203(x :\u03b1). s x \u21ce \ud835\udd4c(:\u03b1) x) \u21d4 \u2203(x :\u03b1). x \u2209 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, pred_setTheory.PSUBSET_DEF, pred_setTheory.GSPEC_ETA, boolTheory.AND_IMP_INTRO, boolTheory.LEFT_FORALL_OR_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.SUBSET_DEF, boolTheory.SELECT_REFL_2, pred_setTheory.EQ_UNIV]", "reward": 5}]], "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). IMAGE f s y \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ C$bool$ ! | Vs @ C$bool$ ! | Vf @ @ C$min$ = @ @ @ C$pred_set$ IMAGE Vf Vs Vy @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). IMAGE f s y \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.IMAGE_DEF, boolTheory.FORALL_itself, boolTheory.CONJ_COMM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\u1d40 \u21d4 reflexive R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ reflexive @ C$relation$ inv VR @ C$relation$ reflexive VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R\u1d40 \u21d4 reflexive R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.irreflexive_def, boolTheory.ONTO_THM, relationTheory.reflexive_def, relationTheory.inv_RC, relationTheory.inv_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2208 POW s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ IN C$pred_set$ EMPTY @ C$pred_set$ POW Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u2208 POW s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$pred_set$ SUBSET C$pred_set$ EMPTY Vs"}, "plain": {"assumptions": [], "goal": "(\u2205 :\u03b1 -> bool) \u2286 (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_BIJ, boolTheory.BOOL_FUN_CASES_THM, pred_setTheory.BIGINTER_SING, pred_setTheory.IN_POW, pred_setTheory.BIGUNION_INSERT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.REST_applied, pred_setTheory.FINITE_DEF, pred_setTheory.EMPTY_SUBSET, pred_setTheory.FINITE_BIJ, pred_setTheory.CROSS_SINGS]", "reward": 5}]], "\u2200(l :\u03b1 list) (n1 :num) (n2 :num). ALL_DISTINCT l \u2227 n1 < LENGTH l \u2227 n2 < LENGTH l \u21d2 (EL n1 l = EL n2 l \u21d4 n1 = n2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vn1 @ C$bool$ ! | Vn2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$list$ ALL_DISTINCT Vl @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn1 @ C$list$ LENGTH Vl @ @ C$prim_rec$ < Vn2 @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$min$ = @ @ C$list$ EL Vn1 Vl @ @ C$list$ EL Vn2 Vl @ @ C$min$ = Vn1 Vn2"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (n1 :num) (n2 :num). ALL_DISTINCT l \u2227 n1 < LENGTH l \u2227 n2 < LENGTH l \u21d2 (EL n1 l = EL n2 l \u21d4 n1 = n2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.EL_ALL_DISTINCT_EL_EQ, listTheory.MAP_EQ_f, listTheory.NOT_EXISTS, prim_recTheory.LESS_SUC, boolTheory.LCOMM_THM]", "reward": 5}]], "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF (y \u222a z) = x DIFF y DIFF z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$pred_set$ DIFF Vx @ @ C$pred_set$ UNION Vy Vz @ @ C$pred_set$ DIFF @ @ C$pred_set$ DIFF Vx Vy Vz"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool). x DIFF (y \u222a z) = x DIFF y DIFF z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' @ @ C$pred_set$ UNION Vy Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vy @ C$bool$ ~ @ @ C$bool$ IN Vx' Vz"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool) (z :\u03b1 -> bool) (x' :\u03b1). x' \u2208 x \u2227 x' \u2209 y \u222a z \u21d4 (x' \u2208 x \u2227 x' \u2209 y) \u2227 x' \u2209 z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_DIFF, pred_setTheory.EMPTY_applied, pred_setTheory.INTER_DEF, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.IN_INTER, pred_setTheory.IN_UNION, pred_setTheory.GSPEC_ETA, boolTheory.JRH_INDUCT_UTIL]", "reward": 5}]], "MAP (f :num -> \u03b1) (COUNT_LIST (n :num)) = GENLIST f n": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ GENLIST Vf Vn"}, "plain": {"assumptions": [], "goal": "MAP (f :num -> \u03b1) (COUNT_LIST (n :num)) = GENLIST f n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST C$num$ 0 @ @ C$list$ GENLIST Vf C$num$ 0"}, "plain": {"assumptions": [], "goal": "MAP (f :num -> \u03b1) (COUNT_LIST (0 :num)) = GENLIST f (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ GENLIST Vf Vn"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn"}, "plain": {"assumptions": ["MAP (f :num -> \u03b1) (COUNT_LIST (n :num)) = GENLIST f n"], "goal": "MAP (f :num -> \u03b1) (COUNT_LIST (SUC (n :num))) = GENLIST f (SUC n)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ GENLIST Vf Vn"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn"}, "plain": {"assumptions": ["MAP (f :num -> \u03b1) (COUNT_LIST (n :num)) = GENLIST f n"], "goal": "MAP (f :num -> \u03b1) (COUNT_LIST (SUC (n :num))) = GENLIST f (SUC n)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDL_UNION_BIGUNION_paired, rich_listTheory.COUNT_LIST_GENLIST, listTheory.GENLIST_ID, rich_listTheory.COUNT_LIST_def, listTheory.FILTER_EQ_ID]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.GENLIST, rich_listTheory.TL_SNOC, rich_listTheory.BUTLASTN_FRONT, rich_listTheory.COUNT_LIST_SNOC, listTheory.FINITE_LIST_TO_SET]", "reward": 5}]], "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). (\u2200(n :num). PRIM_REC_FUN x f (0 :num) n = x) \u2227 \u2200(m :num) (n :num). PRIM_REC_FUN x f (SUC m) n = f (PRIM_REC_FUN x f m (PRE n)) n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vn @ @ C$min$ = @ @ @ @ C$prim_rec$ PRIM_REC_FUN Vx Vf C$num$ 0 Vn Vx @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ @ @ C$prim_rec$ PRIM_REC_FUN Vx Vf @ C$num$ SUC Vm Vn @ @ Vf @ @ @ @ C$prim_rec$ PRIM_REC_FUN Vx Vf Vm @ C$prim_rec$ PRE Vn Vn"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). (\u2200(n :num). PRIM_REC_FUN x f (0 :num) n = x) \u2227 \u2200(m :num) (n :num). PRIM_REC_FUN x f (SUC m) n = f (PRIM_REC_FUN x f m (PRE n)) n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[prim_recTheory.PRIM_REC_FUN, prim_recTheory.SIMP_REC_THM, boolTheory.ONE_ONE_THM, boolTheory.UNWIND_THM1, boolTheory.EQ_IMP_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 \u2203(x :\u03b1). x \u2209 s \u2227 x INSERT s \u2286 t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ PSUBSET Vs Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$pred_set$ SUBSET @ @ C$pred_set$ INSERT Vx Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2282 t \u21d4 \u2203(x :\u03b1). x \u2209 s \u2227 x INSERT s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ @ C$pred_set$ SUBSET @ @ C$pred_set$ INSERT Vx Vs Vt"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2286 (t :\u03b1 -> bool) \u2227 (\u2203(x :\u03b1). x \u2208 s \u21ce x \u2208 t) \u21d4 \u2203(x :\u03b1). x \u2209 s \u2227 x INSERT s \u2286 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.UNION_applied, boolTheory.IMP_DISJ_THM, pred_setTheory.PSUBSET_DEF, boolTheory.CONJ_ASSOC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vx @ C$bool$ ~ @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b1 -> bool)) \u2227 (\u2203(x :\u03b1). x \u2208 s \u21ce x \u2208 t) \u21d4 \u2203(x :\u03b1). x \u2209 s \u2227 \u2200(x' :\u03b1). x' \u2208 x INSERT s \u21d2 x' \u2208 t"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, boolTheory.LEFT_OR_CONG, pred_setTheory.UNION_DEF, pred_setTheory.IN_DELETE]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.CONJ_COMM, pred_setTheory.INTER_applied, pred_setTheory.IN_INSERT, pred_setTheory.GSPEC_ETA, pred_setTheory.DELETE_applied]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2282 s \u21d2 FINITE t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ PSUBSET Vt Vs @ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2282 s \u21d2 FINITE t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$pred_set$ PSUBSET Vt Vs", "@ C$pred_set$ FINITE Vs"], "goal": "@ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) \u2282 (s :\u03b1 -> bool)", "FINITE (s :\u03b1 -> bool)"], "goal": "FINITE (t :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.CHOICE_INSERT_REST, boolTheory.DISJ_EQ_IMP, pred_setTheory.GSPEC_ETA, pred_setTheory.BIJ_SYM, pred_setTheory.IMAGE_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.PSUBSET_DEF, pred_setTheory.SUBSET_FINITE_I, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_COMM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u00acEXISTS (\u03bb(x :\u03b1). \u00acP x) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP Vl @ C$bool$ ~ @ @ C$list$ EXISTS | Vx @ C$bool$ ~ @ VP Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). EVERY P l \u21d4 \u00acEXISTS (\u03bb(x :\u03b1). \u00acP x) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.IMP_DISJ_THM, listTheory.EXISTS_MEM, listTheory.EVERY_MEM, listTheory.FIND_def, boolTheory.NOT_F]", "reward": 5}]], "FINITE (s :\u03b1 -> bool) \u2227 SURJ (f :\u03b1 -> \u03b2) s (t :\u03b2 -> bool) \u21d2 FINITE t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ FINITE Vs @ @ @ C$pred_set$ SURJ Vf Vs Vt @ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": [], "goal": "FINITE (s :\u03b1 -> bool) \u2227 SURJ (f :\u03b1 -> \u03b2) s (t :\u03b2 -> bool) \u21d2 FINITE t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SURJ_CARD, pred_setTheory.NOT_IN_EMPTY, boolTheory.IMP_F, pred_setTheory.INSERT_applied, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 y \u227c x \u21d2 x = y": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 y \u227c x \u21d2 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$list$ isPREFIX C$list$ NIL Vx @ @ C$min$ = Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list). x \u227c ([] :\u03b1 list) \u2227 ([] :\u03b1 list) \u227c x \u21d2 x = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy Vx @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 y \u227c x \u21d2 x = y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u2227 h::y \u227c x \u21d2 x = h::y"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `y`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy Vx @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 y \u227c x \u21d2 x = y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u2227 h::y \u227c x \u21d2 x = h::y"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.GENLIST, boolTheory.EQ_REFL, listTheory.SET_TO_LIST_THM, listTheory.SNOC_APPEND, listTheory.nub_NIL]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"], "goal": "@ @ C$min$ ==> @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vh Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy C$list$ NIL @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 y \u227c x \u21d2 x = y"], "goal": "([] :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 h::y \u227c ([] :\u03b1 list) \u21d2 ([] :\u03b1 list) = h::y"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy Vx @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy @ @ C$list$ CONS Vh' Vx @ @ C$min$ = @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 h::y \u227c x \u21d2 x = h::y", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 y \u227c x \u21d2 x = y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 h::y \u227c h'::x \u21d2 h'::x = h::y"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy Vx @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$list$ isPREFIX Vy Vx @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vy @ @ C$list$ CONS Vh' Vx @ @ C$min$ = @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 h::y \u227c x \u21d2 x = h::y", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 y \u227c x \u21d2 x = y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u21d2 h::y \u227c h'::x \u21d2 h'::x = h::y"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.ZIP_EQ_NIL, listTheory.SNOC_11, listTheory.ZIP_def, listTheory.SUM_SUM_ACC, listTheory.OPT_MMAP_def]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.nub_def, listTheory.UNZIP, listTheory.list_size_def, listTheory.GENLIST, listTheory.OPT_MMAP_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\u207a x y \u2227 R\u207a y z \u21d2 R\u207a x z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ @ C$relation$ TC VR Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ TC VR Vx Vy @ @ @ C$relation$ TC VR Vy Vz @ @ @ C$relation$ TC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 R\u207a x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\u207a x y \u2227 R\u207a y z \u21d2 R\u207a x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ C$bool$ ! | VP @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ C$bool$ ? | Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ C$bool$ ~ @ @ VP Vx Vz @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | VP @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ~ @ @ VP Vy Vz @ @ VP Vx Vz @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ? | VP @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ~ @ @ VP Vy Vz @ @ VP Vx Vz @ C$bool$ ~ @ @ VP Vy Vz @ C$bool$ ! | VP @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ C$bool$ ? | Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ C$bool$ ~ @ @ VP Vx Vz @ @ VP Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). \u00acR x y \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). ((\u2203(x :\u03b1) (y :\u03b1). R x y \u2227 \u00acP x y) \u2228 \u2203(x :\u03b1) (y :\u03b1) (z :\u03b1). (P x y \u2227 P y z) \u2227 \u00acP x z) \u2228 P x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). ((\u2203(P :\u03b1 -> \u03b1 -> bool). ((\u2200(x :\u03b1) (y :\u03b1). \u00acR x y \u2228 P x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (\u00acP x y \u2228 \u00acP y z) \u2228 P x z) \u2227 \u00acP x y) \u2228 \u2203(P :\u03b1 -> \u03b1 -> bool). ((\u2200(x :\u03b1) (y :\u03b1). \u00acR x y \u2228 P x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (\u00acP x y \u2228 \u00acP y z) \u2228 P x z) \u2227 \u00acP y z) \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). ((\u2203(x :\u03b1) (y :\u03b1). R x y \u2227 \u00acP x y) \u2228 \u2203(x :\u03b1) (y :\u03b1) (z :\u03b1). (P x y \u2227 P y z) \u2227 \u00acP x z) \u2228 P x z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.EQ_SYM_EQ, relationTheory.TC_DEF, boolTheory.IMP_DISJ_THM, boolTheory.itself_TY_DEF, relationTheory.transitive_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_AND_FORALL_THM, boolTheory.RES_EXISTS_DEF, boolTheory.T_DEF, boolTheory.NOT_CLAUSES, boolTheory.COND_RATOR]", "reward": 5}]], "\u2200(R1 :\u03b1 -> \u03b2 -> bool) (R2 :\u03b1 -> \u03b2 -> bool). R1 \u2286\u1d63 R2 \u2227 R2 \u2286\u1d63 R1 \u21d2 R1 = R2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR1 @ C$bool$ ! | VR2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$relation$ RSUBSET VR1 VR2 @ @ C$relation$ RSUBSET VR2 VR1 @ @ C$min$ = VR1 VR2"}, "plain": {"assumptions": [], "goal": "\u2200(R1 :\u03b1 -> \u03b2 -> bool) (R2 :\u03b1 -> \u03b2 -> bool). R1 \u2286\u1d63 R2 \u2227 R2 \u2286\u1d63 R1 \u21d2 R1 = R2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR2 Vx Vy @ @ VR1 Vx Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR1 Vx Vy @ @ VR2 Vx Vy"], "goal": "@ @ C$min$ = @ @ VR1 Vx Vx' @ @ VR2 Vx Vx'"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b2). (R2 :\u03b1 -> \u03b2 -> bool) x y \u21d2 (R1 :\u03b1 -> \u03b2 -> bool) x y", "\u2200(x :\u03b1) (y :\u03b2). (R1 :\u03b1 -> \u03b2 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b2 -> bool) x y"], "goal": "(R1 :\u03b1 -> \u03b2 -> bool) (x :\u03b1) (x' :\u03b2) \u21d4 (R2 :\u03b1 -> \u03b2 -> bool) x x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.RSUBSET, boolTheory.FUN_EQ_THM, relationTheory.SC_lifts_monotonicities, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.BOTH_EXISTS_AND_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.WFP_DEF, relationTheory.WF_RECURSION_THM, boolTheory.COND_CLAUSES, relationTheory.approx_def, relationTheory.RUNION_COMM]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2228 Q x} = {x | P x} \u222a {x | Q x}": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ VP Vx @ VQ Vx @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VP Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). {x | P x \u2228 Q x} = {x | P x} \u222a {x | Q x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNION_DEF, pred_setTheory.FINITE_COUNT, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "count (0 :num) = (\u2205 :num -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ count C$num$ 0 C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "count (0 :num) = (\u2205 :num -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DEF, pred_setTheory.FINITE_EMPTY, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_SING_UNION, pred_setTheory.count_def]", "reward": 5}]], "(\u2200(x :num). pair_to_num (num_to_pair x) = x) \u2227 \u2200(x :num) (y :num). num_to_pair (pair_to_num (x,y)) = (x,y)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ C$pred_set$ pair_to_num @ C$pred_set$ num_to_pair Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ C$pred_set$ num_to_pair @ C$pred_set$ pair_to_num @ @ C$pair$ , Vx Vy @ @ C$pair$ , Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :num). pair_to_num (num_to_pair x) = x) \u2227 \u2200(x :num) (y :num). num_to_pair (pair_to_num (x,y)) = (x,y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DEF, pred_setTheory.PSUBSET_MEMBER, pred_setTheory.num_to_pair_def, pred_setTheory.INJ_LINV_OPT, pred_setTheory.pair_to_num_def]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 \u2200(t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ INSERT Vx Vt @ @ C$pred_set$ SUBSET Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2209 s \u21d2 \u2200(t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$bool$ IN Vx Vs"], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": ["(x :\u03b1) \u2209 (s :\u03b1 -> bool)"], "goal": "(\u2200(x' :\u03b1). x' \u2208 (s :\u03b1 -> bool) \u21d2 x' \u2208 (x :\u03b1) INSERT (t :\u03b1 -> bool)) \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.MEMBER_NOT_EMPTY, pred_setTheory.GSPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.CONJ_COMM, pred_setTheory.DIFF_DEF, pred_setTheory.IN_INSERT, boolTheory.EQ_SYM_EQ, pred_setTheory.INSERT_UNION_EQ]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). RC R x y \u21d2 R\ua673 x y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RC VR Vx Vy @ @ @ C$relation$ RTC VR Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). RC R x y \u21d2 R\ua673 x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RC VR Vx Vy @ C$bool$ ! | VRTC' @ @ C$min$ ==> @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Va1 Va0 @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Va0 Vy @ @ VRTC' Vy Va1 @ @ VRTC' Va0 Va1 @ @ VRTC' Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). RC R x y \u21d2 \u2200(RTC' :\u03b1 -> \u03b1 -> bool). (\u2200(a0 :\u03b1) (a1 :\u03b1). a1 = a0 \u2228 (\u2203(y :\u03b1). R a0 y \u2227 RTC' y a1) \u21d2 RTC' a0 a1) \u21d2 RTC' x y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.F_DEF, boolTheory.AND_IMP_INTRO, relationTheory.RTC_def, boolTheory.BOTH_EXISTS_IMP_THM, boolTheory.ONE_ONE_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.SC_DEF, boolTheory.FORALL_THM, boolTheory.DISJ_EQ_IMP, relationTheory.RC_DEF, boolTheory.EQ_EXT]", "reward": 5}]], "DIV2 (BIT1 (x :num)) = x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$arithmetic$ DIV2 @ C$arithmetic$ BIT1 Vx Vx"}, "plain": {"assumptions": [], "goal": "DIV2 (BIT1 (x :num)) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.BIT1, arithmeticTheory.ABS_DIFF_ZERO, arithmeticTheory.DIV2_def, arithmeticTheory.ADD_EQ_0, arithmeticTheory.LESS_DIV_EQ_ZERO]", "reward": 5}]], "symmetric (R :\u03b1 -> \u03b1 -> bool)^=": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ symmetric @ C$relation$ EQC VR"}, "plain": {"assumptions": [], "goal": "symmetric (R :\u03b1 -> \u03b1 -> bool)^="}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$relation$ EQC VR Vx Vy @ @ @ C$relation$ EQC VR Vy Vx"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool)^= (x :\u03b1) (y :\u03b1) \u21d4 R^= y x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.RTC_CASES_RTC_TWICE, relationTheory.symmetric_def, relationTheory.RC_DEF, relationTheory.RTC_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.reflexive_def, relationTheory.EQC_SYM, relationTheory.RC_DEF, relationTheory.RC_DEF, relationTheory.reflexive_def]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). COMPL s x \u21d4 x \u2209 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ COMPL Vs Vx @ C$bool$ ~ @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). COMPL s x \u21d4 x \u2209 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_COMPL, pred_setTheory.EXTENSION, pred_setTheory.IN_DISJOINT, pred_setTheory.IN_REST]", "reward": 5}]], "\u2200(x :\u03b1 + \u03b2). ISR x \u21d2 (INR (OUTR x) :\u03b1 + \u03b2) = x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ C$sum$ ISR Vx @ @ C$min$ = @ C$sum$ INR @ C$sum$ OUTR Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 + \u03b2). ISR x \u21d2 (INR (OUTR x) :\u03b1 + \u03b2) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ C$sum$ ISR @ C$sum$ INL Vx @ @ C$min$ = @ C$sum$ INR @ C$sum$ OUTR @ C$sum$ INL Vx @ C$sum$ INL Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). ISR (INL x :\u03b1 + \u03b2) \u21d2 (INR (OUTR (INL x :\u03b1 + \u03b2)) :\u03b1 + \u03b2) = (INL x :\u03b1 + \u03b2)"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ @ C$min$ ==> @ C$sum$ ISR @ C$sum$ INR Vy @ @ C$min$ = @ C$sum$ INR @ C$sum$ OUTR @ C$sum$ INR Vy @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2). ISR (INR y :\u03b1 + \u03b2) \u21d2 (INR (OUTR (INR y :\u03b1 + \u03b2)) :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ @ C$min$ ==> @ C$sum$ ISR @ C$sum$ INR Vy @ @ C$min$ = @ C$sum$ INR @ C$sum$ OUTR @ C$sum$ INR Vy @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2). ISR (INR y :\u03b1 + \u03b2) \u21d2 (INR (OUTR (INR y :\u03b1 + \u03b2)) :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2)"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.itself_Axiom, boolTheory.RES_SELECT_DEF, sumTheory.sum_distinct1, sumTheory.ISR, sumTheory.ISL_OR_ISR]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.IMP_DISJ_THM, boolTheory.SWAP_FORALL_THM, sumTheory.OUTR, boolTheory.literal_case_RATOR, boolTheory.LEFT_FORALL_OR_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u2227 countable t \u21d2 countable s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ C$pred_set$ countable Vt @ C$pred_set$ countable Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u2227 countable t \u21d2 countable s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.GSPEC_ETA, pred_setTheory.CROSS_SINGS, boolTheory.IMP_F, boolTheory.NOT_EXISTS_THM, pred_setTheory.subset_countable]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 \u2200(f :\u03b1 -> \u03b2). IMAGE f s \u2286 IMAGE f t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs Vt @ C$bool$ ! | Vf @ @ C$pred_set$ SUBSET @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 t \u21d2 \u2200(f :\u03b1 -> \u03b2). IMAGE f s \u2286 IMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ Vs Vx'", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt Vx"], "goal": "@ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx' @ Vf Vx'' @ Vt Vx''"}, "plain": {"assumptions": ["(s :\u03b1 -> bool) (x' :\u03b1)", "\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b1 -> bool) x"], "goal": "\u2203(x'' :\u03b1). (f :\u03b1 -> \u03b2) (x' :\u03b1) = f x'' \u2227 (t :\u03b1 -> bool) x''"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.PAIR_IN_GSPEC_1, pred_setTheory.IMAGE_applied, pred_setTheory.SUBSET_DEF, pred_setTheory.DISJOINT_UNION_BOTH]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.NOT_SING_EMPTY, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_applied, pred_setTheory.INSERT_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 R\u207a = R": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ transitive VR @ @ C$min$ = @ C$relation$ TC VR VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R \u21d2 R\u207a = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"], "goal": "@ @ C$min$ = @ C$relation$ TC VR VR"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z"], "goal": "(R :\u03b1 -> \u03b1 -> bool)\u207a = R"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, boolTheory.AND_CLAUSES, relationTheory.transitive_def, boolTheory.COND_RATOR, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vx' @ @ VR Vx Vx'"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z"], "goal": "\u2200(x :\u03b1) (x' :\u03b1). (\u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x x') \u21d4 R x x'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, boolTheory.FORALL_BOOL, boolTheory.BETA_THM, boolTheory.LEFT_FORALL_IMP_THM, relationTheory.TC_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_CONG, relationTheory.TC_DEF, relationTheory.symmetric_def, relationTheory.TC_INDUCT, relationTheory.irreflexive_def]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s DELETE x \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ INSERT Vx Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ DELETE Vs Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2286 x INSERT t \u21d4 s DELETE x \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' Vs @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vt @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' @ @ C$pred_set$ DELETE Vs Vx @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2208 (s :\u03b1 -> bool) \u21d2 x' = (x :\u03b1) \u2228 x' \u2208 (t :\u03b1 -> bool)) \u21d4 \u2200(x' :\u03b1). x' \u2208 s DELETE x \u21d2 x' \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INSERT, pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_INTER1, boolTheory.CONJ_ASSOC]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.UNION_SUBSET, pred_setTheory.SUBSET_DEF, boolTheory.NOT_IMP, pred_setTheory.IN_DELETE, pred_setTheory.INSERT_DIFF]", "reward": 5}]], "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u222a s = \ud835\udd4c(:\u03b1)) \u2227 \u2200(s :\u03b1 -> bool). s \u222a \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ UNION C$pred_set$ UNIV Vs C$pred_set$ UNIV @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ UNION Vs C$pred_set$ UNIV C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u222a s = \ud835\udd4c(:\u03b1)) \u2227 \u2200(s :\u03b1 -> bool). s \u222a \ud835\udd4c(:\u03b1) = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.EXTENSION, pred_setTheory.UNIV_DEF, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.UNION_applied]", "reward": 5}]], "\u2200(x :\u03b1). {x} DELETE x = (\u2205 :\u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DELETE @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). {x} DELETE x = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.itself_TY_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.UNIV_SUBSET, pred_setTheory.DIFF_EQ_EMPTY, pred_setTheory.DELETE_DEF]", "reward": 5}]], "([] :\u03b1 list) \u2208 (s :\u03b1 list -> bool) \u21d2 longest_prefix s = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ IN C$list$ NIL Vs @ @ C$min$ = @ C$rich_list$ longest_prefix Vs C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2208 (s :\u03b1 list -> bool) \u21d2 longest_prefix s = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.longest_prefix_def, listTheory.MAP, rich_listTheory.FILTER_FLAT, listTheory.DISJOINT_GENLIST_PLUS, rich_listTheory.common_prefixes_NIL]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). x INSERT s \u2286 t \u21d4 x \u2208 t \u2227 s \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ SUBSET @ @ C$pred_set$ INSERT Vx Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ @ C$pred_set$ SUBSET Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). x INSERT s \u2286 t \u21d4 x \u2208 t \u2227 s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' = (x :\u03b1) \u2228 x' \u2208 (s :\u03b1 -> bool) \u21d2 x' \u2208 (t :\u03b1 -> bool)) \u21d4 x \u2208 t \u2227 \u2200(x :\u03b1). x \u2208 s \u21d2 x \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_THM, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_INSERT, pred_setTheory.UNION_applied, pred_setTheory.EMPTY_UNION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.LEFT_FORALL_IMP_THM, pred_setTheory.NOT_EMPTY_INSERT, boolTheory.EQ_IMP_THM, boolTheory.DISJ_IMP_THM, pred_setTheory.UNION_OVER_INTER]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d4 x INSERT s = s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$pred_set$ INSERT Vx Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d4 x INSERT s = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 (s :\u03b1 -> bool) \u21d4 \u2200(x' :\u03b1). x' = x \u2228 x' \u2208 s \u21d4 x' \u2208 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_applied, pred_setTheory.IN_INSERT, pred_setTheory.DIFF_DIFF, pred_setTheory.EXTENSION, boolTheory.RES_FORALL_CONG]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INTER_DEF, pred_setTheory.COMPONENT, boolTheory.literal_case_THM, pred_setTheory.IN_UNION, pred_setTheory.DIFF_INTER2]", "reward": 5}]], "MAX_SET (\u2205 :num -> bool) = (0 :num) \u2227 MAX_SET {(e :num)} = e": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$pred_set$ MAX_SET C$pred_set$ EMPTY C$num$ 0 @ @ C$min$ = @ C$pred_set$ MAX_SET @ @ C$pred_set$ INSERT Ve C$pred_set$ EMPTY Ve"}, "plain": {"assumptions": [], "goal": "MAX_SET (\u2205 :num -> bool) = (0 :num) \u2227 MAX_SET {(e :num)} = e"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.MAX_SET_THM, pred_setTheory.FINITE_EMPTY, pred_setTheory.IN_IMAGE, pred_setTheory.PROD_SET_DEF, pred_setTheory.SPECIFICATION]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b2) (z :\u03b1). (if (P :bool) then (INR x :\u03b2 + \u03b1) else (INL y :\u03b2 + \u03b1)) = (INR z :\u03b2 + \u03b1) \u21d4 P \u2227 z = x) \u2227 (\u2200(x :\u03b3) (y :\u03b4) (z :\u03b4). (if P then (INR x :\u03b4 + \u03b3) else (INL y :\u03b4 + \u03b3)) = (INL z :\u03b4 + \u03b3) \u21d4 \u00acP \u2227 z = y) \u2227 (\u2200(x :\u03b5) (y :\u03b6) (z :\u03b5). (if P then (INL x :\u03b5 + \u03b6) else (INR y :\u03b5 + \u03b6)) = (INL z :\u03b5 + \u03b6) \u21d4 P \u2227 z = x) \u2227 \u2200(x :\u03b7) (y :\u03b8) (z :\u03b8). (if P then (INL x :\u03b7 + \u03b8) else (INR y :\u03b7 + \u03b8)) = (INR z :\u03b7 + \u03b8) \u21d4 \u00acP \u2227 z = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$min$ = @ @ @ C$bool$ COND VP @ C$sum$ INR Vx @ C$sum$ INL Vy @ C$sum$ INR Vz @ @ C$bool$ /\\ VP @ @ C$min$ = Vz Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$min$ = @ @ @ C$bool$ COND VP @ C$sum$ INR Vx @ C$sum$ INL Vy @ C$sum$ INL Vz @ @ C$bool$ /\\ @ C$bool$ ~ VP @ @ C$min$ = Vz Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$min$ = @ @ @ C$bool$ COND VP @ C$sum$ INL Vx @ C$sum$ INR Vy @ C$sum$ INL Vz @ @ C$bool$ /\\ VP @ @ C$min$ = Vz Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ = @ @ C$min$ = @ @ @ C$bool$ COND VP @ C$sum$ INL Vx @ C$sum$ INR Vy @ C$sum$ INR Vz @ @ C$bool$ /\\ @ C$bool$ ~ VP @ @ C$min$ = Vz Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b2) (z :\u03b1). (if (P :bool) then (INR x :\u03b2 + \u03b1) else (INL y :\u03b2 + \u03b1)) = (INR z :\u03b2 + \u03b1) \u21d4 P \u2227 z = x) \u2227 (\u2200(x :\u03b3) (y :\u03b4) (z :\u03b4). (if P then (INR x :\u03b4 + \u03b3) else (INL y :\u03b4 + \u03b3)) = (INL z :\u03b4 + \u03b3) \u21d4 \u00acP \u2227 z = y) \u2227 (\u2200(x :\u03b5) (y :\u03b6) (z :\u03b5). (if P then (INL x :\u03b5 + \u03b6) else (INR y :\u03b5 + \u03b6)) = (INL z :\u03b5 + \u03b6) \u21d4 P \u2227 z = x) \u2227 \u2200(x :\u03b7) (y :\u03b8) (z :\u03b8). (if P then (INL x :\u03b7 + \u03b8) else (INR y :\u03b7 + \u03b8)) = (INR z :\u03b7 + \u03b8) \u21d4 \u00acP \u2227 z = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.boolAxiom, boolTheory.DATATYPE_BOOL, sumTheory.ISR, boolTheory.LEFT_OR_OVER_AND, sumTheory.sum_case_def]", "reward": 5}]], "(\u2203(l :\u03b1 list). (P :\u03b1 list -> bool) l) \u21d4 P ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). P (h::t)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ VP Vl @ @ C$bool$ \\/ @ VP C$list$ NIL @ C$bool$ ? | Vh @ C$bool$ ? | Vt @ VP @ @ C$list$ CONS Vh Vt"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). (P :\u03b1 list -> bool) l) \u21d4 P ([] :\u03b1 list) \u2228 \u2203(h :\u03b1) (t :\u03b1 list). P (h::t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.list_CASES, listTheory.LAST_DEF, listTheory.LAST_APPEND_CONS, listTheory.ZIP_MAP, listTheory.REVERSE_EQ_NIL]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). P x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u2227 P y z \u21d2 P x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 P x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ VP Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ C$bool$ /\\ @ @ @ C$relation$ RTC VR Vy Vz @ @ VP Vy Vz @ @ VP Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vx Vy @ @ VP Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). P x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u2227 P y z \u21d2 P x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 P x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.FUN_EQ_THM, boolTheory.NOT_CLAUSES, boolTheory.NOT_IMP, boolTheory.AND_CLAUSES, relationTheory.RTC_strongind]", "reward": 5}]], "transitive (R1 :\u03b1 -> \u03b1 -> bool) \u2227 transitive (R2 :\u03b1 -> \u03b1 -> bool) \u21d2 transitive (R1 \u2229\u1d63 R2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$relation$ transitive VR1 @ C$relation$ transitive VR2 @ C$relation$ transitive @ @ C$relation$ RINTER VR1 VR2"}, "plain": {"assumptions": [], "goal": "transitive (R1 :\u03b1 -> \u03b1 -> bool) \u2227 transitive (R2 :\u03b1 -> \u03b1 -> bool) \u21d2 transitive (R1 \u2229\u1d63 R2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR1 Vx Vy @ @ VR1 Vy Vz @ @ VR1 Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR2 Vx Vy @ @ VR2 Vy Vz @ @ VR2 Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VR1 Vx Vy @ @ VR2 Vx Vy @ @ C$bool$ /\\ @ @ VR1 Vy Vz @ @ VR2 Vy Vz @ @ C$bool$ /\\ @ @ VR1 Vx Vz @ @ VR2 Vx Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R1 :\u03b1 -> \u03b1 -> bool) x y \u2227 R1 y z \u21d2 R1 x z) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R2 :\u03b1 -> \u03b1 -> bool) x y \u2227 R2 y z \u21d2 R2 x z) \u21d2 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R1 x y \u2227 R2 x y) \u2227 R1 y z \u2227 R2 y z \u21d2 R1 x z \u2227 R2 x z"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.INVOL, relationTheory.RINTER, relationTheory.transitive_def, relationTheory.RINTER, relationTheory.RUNION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RTC_ALT_RIGHT_DEF, boolTheory.COND_EXPAND_OR, relationTheory.RTC_CASES1, relationTheory.RTC_ALT_DEF, boolTheory.EXISTS_itself]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). s DIFF (x INSERT t) = s DELETE x DIFF t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DIFF Vs @ @ C$pred_set$ INSERT Vx Vt @ @ C$pred_set$ DIFF @ @ C$pred_set$ DELETE Vs Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). s DIFF (x INSERT t) = s DELETE x DIFF t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx' @ @ C$pred_set$ DIFF Vs @ @ C$pred_set$ INSERT Vx Vt @ @ C$bool$ IN Vx' @ @ C$pred_set$ DIFF @ @ C$pred_set$ DELETE Vs Vx Vt"}, "plain": {"assumptions": [], "goal": "(x' :\u03b1) \u2208 (s :\u03b1 -> bool) DIFF ((x :\u03b1) INSERT (t :\u03b1 -> bool)) \u21d4 x' \u2208 s DELETE x DIFF t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.EMPTY_DEF, pred_setTheory.DIFF_DIFF_SUBSET, pred_setTheory.IN_DISJOINT, pred_setTheory.IN_DISJOINT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.DELETE_applied, pred_setTheory.DIFF_DEF, pred_setTheory.INSERT_applied, boolTheory.CONJ_ASSOC]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u222a t) = IMAGE f s \u222a IMAGE f t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ UNION @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u222a t) = IMAGE f s \u222a IMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ \\/ @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$bool$ IN Vx' Vs @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": [], "goal": "(\u2203(x' :\u03b1). (x :\u03b2) = (f :\u03b1 -> \u03b2) x' \u2227 (x' \u2208 (s :\u03b1 -> bool) \u2228 x' \u2208 (t :\u03b1 -> bool))) \u21d4 (\u2203(x' :\u03b1). x = f x' \u2227 x' \u2208 s) \u2228 \u2203(x' :\u03b1). x = f x' \u2227 x' \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_IMAGE, pred_setTheory.DISJOINT_ALT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.SUBSET_DISJOINT, pred_setTheory.INSERT_INSERT, pred_setTheory.REST_SING]", "reward": 5}]], "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (s :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' s": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VP' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ VQ Vy @ VQ' Vy @ @ C$min$ ==> @ @ @ C$sum$ SUM_ALL VP VQ Vs @ @ @ C$sum$ SUM_ALL VP' VQ' Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (s :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VP' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ VQ Vy @ VQ' Vy @ @ C$min$ ==> @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INL Vx @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INL Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). (\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (INL x :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' (INL x :\u03b1 + \u03b2)"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VP' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ VQ Vy @ VQ' Vy @ @ C$min$ ==> @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INR Vy @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2). (\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (INR y :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' (INR y :\u03b1 + \u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `s`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ VP Vx @ VP' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ VQ Vy @ VQ' Vy @ @ C$min$ ==> @ @ @ C$sum$ SUM_ALL VP VQ @ C$sum$ INR Vy @ @ @ C$sum$ SUM_ALL VP' VQ' @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2). (\u2200(x :\u03b1). (P :\u03b1 -> bool) x \u21d2 (P' :\u03b1 -> bool) x) \u2227 (\u2200(y :\u03b2). (Q :\u03b2 -> bool) y \u21d2 (Q' :\u03b2 -> bool) y) \u21d2 SUM_ALL P Q (INR y :\u03b1 + \u03b2) \u21d2 SUM_ALL P' Q' (INR y :\u03b1 + \u03b2)"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.UNWIND_THM2, sumTheory.sum_case_def, boolTheory.NOT_AND, sumTheory.SUM_ALL_def, boolTheory.literal_case_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[sumTheory.SUM_ALL_def, sumTheory.cond_sum_expand, boolTheory.LEFT_AND_CONG, sumTheory.SUM_MAP_def, boolTheory.JRH_INDUCT_UTIL]", "reward": 5}]], "\u2200(m :num) (n :num) (l :\u03b1 list). m \u2264 n \u2227 n \u2264 LENGTH l \u21d2 BUTLASTN m (LASTN n l) = LASTN (n \u2212 m) (BUTLASTN m l)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$arithmetic$ <= Vm Vn @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ BUTLASTN Vm @ @ C$rich_list$ LASTN Vn Vl @ @ C$rich_list$ LASTN @ @ C$arithmetic$ - Vn Vm @ @ C$rich_list$ BUTLASTN Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num) (l :\u03b1 list). m \u2264 n \u2227 n \u2264 LENGTH l \u21d2 BUTLASTN m (LASTN n l) = LASTN (n \u2212 m) (BUTLASTN m l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP_DROP, rich_listTheory.LASTN_BUTLASTN, boolTheory.OR_CLAUSES, boolTheory.DISJ_IMP_THM, boolTheory.LEFT_AND_OVER_OR]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (s DIFF t) \u2227 DISJOINT (s DIFF t) t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vt @ @ C$pred_set$ DIFF Vs Vt @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ DIFF Vs Vt Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT t (s DIFF t) \u2227 DISJOINT (s DIFF t) t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.INTER_applied, pred_setTheory.IN_DIFF, pred_setTheory.EXTENSION, pred_setTheory.DISJOINT_ALT, boolTheory.FUN_EQ_THM]", "reward": 5}]], "((\u2200(n :num). \u00ac(P :num -> bool) n) \u21d2 (Q :num option -> bool) (NONE :num option)) \u2227 (\u2200(n :num). P n \u2227 (\u2200(m :num). m < n \u21d2 \u00acP m) \u21d2 Q (SOME n)) \u21d2 Q ($OLEAST P)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ ==> @ C$bool$ ! | Vn @ C$bool$ ~ @ VP Vn @ VQ C$option$ NONE @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ VP Vn @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ C$bool$ ~ @ VP Vm @ VQ @ C$option$ SOME Vn @ VQ @ C$while$ OLEAST VP"}, "plain": {"assumptions": [], "goal": "((\u2200(n :num). \u00ac(P :num -> bool) n) \u21d2 (Q :num option -> bool) (NONE :num option)) \u2227 (\u2200(n :num). P n \u2227 (\u2200(m :num). m < n \u21d2 \u00acP m) \u21d2 Q (SOME n)) \u21d2 Q ($OLEAST P)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[whileTheory.OLEAST_def, whileTheory.LEAST_EXISTS_IMP, boolTheory.SELECT_ELIM_THM, boolTheory.SELECT_ELIM_THM, whileTheory.LEAST_INTRO]", "reward": 5}]], "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2282 s2 \u21d4 s1 \u2286 s2 \u2227 \u00ac(s2 \u2286 s1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ @ C$min$ = @ @ C$pred_set$ PSUBSET Vs1 Vs2 @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs1 Vs2 @ C$bool$ ~ @ @ C$pred_set$ SUBSET Vs2 Vs1"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2282 s2 \u21d4 s1 \u2286 s2 \u2227 \u00ac(s2 \u2286 s1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.CROSS_BIGUNION, pred_setTheory.PSUBSET_MEMBER, pred_setTheory.SUBSET_DEF, boolTheory.UNWIND_FORALL_THM2, pred_setTheory.PSUBSET_DEF]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = l2 \u21d4 l1 = REVERSE l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = @ C$list$ REVERSE Vl1 Vl2 @ @ C$min$ = Vl1 @ C$list$ REVERSE Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = l2 \u21d4 l1 = REVERSE l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.LENGTH_GENLIST, listTheory.EVERY_SNOC, listTheory.REVERSE_REVERSE, listTheory.LENGTH_LUPDATE, listTheory.LENGTH_FRONT_CONS]", "reward": 5}]], "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 DROP n (DROP m l) = DROP (n + m) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vn Vm @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 DROP n (DROP m l) = DROP (n + m) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.adjacent_cases, arithmeticTheory.MODEQ_THM, listTheory.EL_DROP, listTheory.LIST_EQ_REWRITE, listTheory.LENGTH_TAKE_EQ]", "reward": 5}]], "\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (ys :\u03b2 list) (n :num). LIST_REL P xs ys \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vys @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn Vys"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (ys :\u03b2 list) (n :num). LIST_REL P xs ys \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs C$list$ NIL @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs ([] :\u03b2 list) \u21d2 LIST_REL P (TAKE n xs) (TAKE n ([] :\u03b2 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn Vys"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs @ @ C$list$ CONS Vh Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vys"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs (ys :\u03b2 list) \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)"], "goal": "\u2200(h :\u03b2) (P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs (h::(ys :\u03b2 list)) \u21d2 LIST_REL P (TAKE n xs) (TAKE n (h::ys))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ys`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn Vys"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs @ @ C$list$ CONS Vh Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vys"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs (ys :\u03b2 list) \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)"], "goal": "\u2200(h :\u03b2) (P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs (h::(ys :\u03b2 list)) \u21d2 LIST_REL P (TAKE n xs) (TAKE n (h::ys))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FLAT, listTheory.LUPDATE_SOME_MAP, listTheory.GENLIST_AUX, listTheory.list_distinct, listTheory.MAP2]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ @ C$list$ LIST_REL VP Vxs' Vys", "@ @ VP Vx Vh", "@ @ C$min$ = Vxs @ @ C$list$ CONS Vx Vxs'", "@ C$bool$ ! | VP @ C$bool$ ! | Vxs @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ @ C$list$ LIST_REL VP Vxs Vys @ @ @ C$list$ LIST_REL VP @ @ C$list$ TAKE Vn Vxs @ @ C$list$ TAKE Vn Vys"], "goal": "@ @ @ C$list$ LIST_REL VP @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vx @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vxs' @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vys"}, "plain": {"assumptions": ["LIST_REL (P :\u03b1 -> \u03b2 -> bool) (xs' :\u03b1 list) (ys :\u03b2 list)", "(P :\u03b1 -> \u03b2 -> bool) (x :\u03b1) (h :\u03b2)", "(xs :\u03b1 list) = (x :\u03b1)::(xs' :\u03b1 list)", "\u2200(P :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) (n :num). LIST_REL P xs (ys :\u03b2 list) \u21d2 LIST_REL P (TAKE n xs) (TAKE n ys)"], "goal": "LIST_REL (P :\u03b1 -> \u03b2 -> bool) (if (n :num) = (0 :num) then ([] :\u03b1 list) else ((x :\u03b1)::TAKE (n \u2212 (1 :num)) (xs' :\u03b1 list))) (if n = (0 :num) then ([] :\u03b2 list) else (h :\u03b2)::TAKE (n \u2212 (1 :num)) (ys :\u03b2 list))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_SPLIT2, listTheory.TL_GENLIST, listTheory.TAKE_def, listTheory.LIST_APPLY_def, listTheory.UNZIP]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_MEM_IMP, listTheory.EQ_LIST, listTheory.EL_LENGTH_SNOC, listTheory.list_case_cong, listTheory.EVERY2_LUPDATE_same]", "reward": 5}]], "\u2200(P :\u03b1 -> bool). P \u00d7 (\u2205 :\u03b2 -> bool) = (\u2205 :\u03b1 # \u03b2 -> bool) \u2227 (\u2205 :\u03b3 -> bool) \u00d7 P = (\u2205 :\u03b3 # \u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ CROSS VP C$pred_set$ EMPTY C$pred_set$ EMPTY @ @ C$min$ = @ @ C$pred_set$ CROSS C$pred_set$ EMPTY VP C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). P \u00d7 (\u2205 :\u03b2 -> bool) = (\u2205 :\u03b1 # \u03b2 -> bool) \u2227 (\u2205 :\u03b3 -> bool) \u00d7 P = (\u2205 :\u03b3 # \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$bool$ /\\ @ @ C$min$ = @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp VP @ @ C$bool$ IN @ C$pair$ SND Vp | Vx C$bool$ F | Vx C$bool$ F @ @ C$min$ = @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp | Vx C$bool$ F @ @ C$bool$ IN @ C$pair$ SND Vp VP | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). {p | FST p \u2208 P \u2227 SND p \u2208 (\u03bb(x :\u03b2). F)} = (\u03bb(x :\u03b1 # \u03b2). F) \u2227 {p | FST p \u2208 (\u03bb(x :\u03b3). F) \u2227 SND p \u2208 P} = (\u03bb(x :\u03b3 # \u03b1). F)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.ETA_THM, pred_setTheory.INTER_applied, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_applied, pred_setTheory.CROSS_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.FUNSET_DFUNSET, pred_setTheory.UNIV_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_applied]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) DIFF s = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ DIFF C$pred_set$ EMPTY Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) DIFF s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ DIFF | Vx C$bool$ F Vs | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). F) DIFF (s :\u03b1 -> bool) = (\u03bb(x :\u03b1). F)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.ABS_REP_THM, pred_setTheory.EMPTY_SUBSET, pred_setTheory.SUBSET_transitive, pred_setTheory.TC_PSUBSET, pred_setTheory.EMPTY_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.DISJOINT_EMPTY_REFL, pred_setTheory.IN_DIFF, pred_setTheory.EXTENSION, pred_setTheory.PSUBSET_DEF]", "reward": 5}]], "\u2200(m :num) (n :num). m \u2208 count n \u21d4 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$bool$ IN Vm @ C$pred_set$ count Vn @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m \u2208 count n \u21d4 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.count_def, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_DISJOINT, pred_setTheory.UNION_UNIV]", "reward": 5}]], "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). PRIM_REC x f (0 :num) = x \u2227 \u2200(m :num). PRIM_REC x f (SUC m) = f (PRIM_REC x f m) m": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ @ C$prim_rec$ PRIM_REC Vx Vf C$num$ 0 Vx @ C$bool$ ! | Vm @ @ C$min$ = @ @ @ C$prim_rec$ PRIM_REC Vx Vf @ C$num$ SUC Vm @ @ Vf @ @ @ C$prim_rec$ PRIM_REC Vx Vf Vm Vm"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (f :\u03b1 -> num -> \u03b1). PRIM_REC x f (0 :num) = x \u2227 \u2200(m :num). PRIM_REC x f (SUC m) = f (PRIM_REC x f m) m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[prim_recTheory.PRIM_REC_EQN, boolTheory.EXISTS_OR_THM, prim_recTheory.PRIM_REC, boolTheory.LEFT_EXISTS_IMP_THM, boolTheory.COND_RAND]", "reward": 5}]], "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). y \u2208 IMAGE f s \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vy @ C$bool$ ! | Vs @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(y :\u03b2) (s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). y \u2208 IMAGE f s \u21d4 \u2203(x :\u03b1). y = f x \u2227 x \u2208 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RIGHT_FORALL_OR_THM, pred_setTheory.SPECIFICATION, pred_setTheory.PSUBSET_INSERT_SUBSET, pred_setTheory.IMAGE_DEF, pred_setTheory.GSPECIFICATION_applied]", "reward": 5}]], "\u2200(f :(\u03b1 -> bool) -> bool) (g :(\u03b1 -> bool) -> bool). f \u2286 g \u21d2 BIGUNION f \u2286 BIGUNION g": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vf Vg @ @ C$pred_set$ SUBSET @ C$pred_set$ BIGUNION Vf @ C$pred_set$ BIGUNION Vg"}, "plain": {"assumptions": [], "goal": "\u2200(f :(\u03b1 -> bool) -> bool) (g :(\u03b1 -> bool) -> bool). f \u2286 g \u21d2 BIGUNION f \u2286 BIGUNION g"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION Vf", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vf @ @ C$bool$ IN Vx Vg"], "goal": "@ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION Vg"}, "plain": {"assumptions": ["(x :\u03b1) \u2208 BIGUNION (f :(\u03b1 -> bool) -> bool)", "\u2200(x :\u03b1 -> bool). x \u2208 (f :(\u03b1 -> bool) -> bool) \u21d2 x \u2208 (g :(\u03b1 -> bool) -> bool)"], "goal": "(x :\u03b1) \u2208 BIGUNION (g :(\u03b1 -> bool) -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.FUNSET, pred_setTheory.CARD_EQ_0]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vs Vf", "@ @ C$bool$ IN Vx Vs", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vf @ @ C$bool$ IN Vx Vg"], "goal": "@ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vs Vg"}, "plain": {"assumptions": ["(s :\u03b1 -> bool) \u2208 (f :(\u03b1 -> bool) -> bool)", "(x :\u03b1) \u2208 (s :\u03b1 -> bool)", "\u2200(x :\u03b1 -> bool). x \u2208 (f :(\u03b1 -> bool) -> bool) \u21d2 x \u2208 (g :(\u03b1 -> bool) -> bool)"], "goal": "\u2203(s :\u03b1 -> bool). (x :\u03b1) \u2208 s \u2227 s \u2208 (g :(\u03b1 -> bool) -> bool)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.BIGUNION_SUBSET, pred_setTheory.IN_BIGUNION, pred_setTheory.DFUNSET_applied, boolTheory.PULL_EXISTS, pred_setTheory.GSPEC_ETA]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.GSPEC_ETA, pred_setTheory.IN_IMAGE, pred_setTheory.EMPTY_DIFF, pred_setTheory.REL_RESTRICT_EMPTY, pred_setTheory.FINITE_BIGUNION_EQ]", "reward": 5}]], "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION P \u2286 X \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 Y \u2286 X": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VX @ C$bool$ ! | VP @ @ C$min$ = @ @ C$pred_set$ SUBSET @ C$pred_set$ BIGUNION VP VX @ C$bool$ ! | VY @ @ C$min$ ==> @ @ C$bool$ IN VY VP @ @ C$pred_set$ SUBSET VY VX"}, "plain": {"assumptions": [], "goal": "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION P \u2286 X \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 Y \u2286 X"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION VP @ @ C$bool$ IN Vx VX @ C$bool$ ! | VY @ @ C$min$ ==> @ @ C$bool$ IN VY VP @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VY @ @ C$bool$ IN Vx VX"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 BIGUNION (P :(\u03b1 -> bool) -> bool) \u21d2 x \u2208 (X :\u03b1 -> bool)) \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 \u2200(x :\u03b1). x \u2208 Y \u21d2 x \u2208 X"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_DEF, boolTheory.RIGHT_EXISTS_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_APP, pred_setTheory.IN_BIGUNION, pred_setTheory.IN_DELETE_EQ, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b3 -> bool) (t :\u03b1 -> bool). s \u00d7 BIGUNION (IMAGE f t) = BIGUNION (IMAGE (\u03bb(n :\u03b1). s \u00d7 f n) t)": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ CROSS Vs @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE Vf Vt @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE | Vn @ @ C$pred_set$ CROSS Vs @ Vf Vn Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b3 -> bool) (t :\u03b1 -> bool). s \u00d7 BIGUNION (IMAGE f t) = BIGUNION (IMAGE (\u03bb(n :\u03b1). s \u00d7 f n) t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ CROSS Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs @ @ C$pred_set$ IMAGE Vf Vt @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ C$bool$ IN Vs' @ @ C$pred_set$ IMAGE | Vn @ @ C$pred_set$ CROSS Vs @ Vf Vn Vt @ @ C$bool$ IN Vx Vs'"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> bool) (s :\u03b3 -> bool) (t :\u03b1 -> bool). ((s \u00d7 {x | \u2203(s :\u03b2 -> bool). s \u2208 IMAGE f t \u2227 x \u2208 s}) :\u03b3 # \u03b2 -> bool) = {x | \u2203(s' :\u03b3 # \u03b2 -> bool). s' \u2208 IMAGE (\u03bb(n :\u03b1). ((s \u00d7 f n) :\u03b3 # \u03b2 -> bool)) t \u2227 x \u2208 s'}"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.BIGUNION, pred_setTheory.SUBSET_UNION_ABSORPTION, pred_setTheory.DFUNSET_applied, boolTheory.UNWIND_THM1, pred_setTheory.IN_ABS]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp Vs @ @ C$bool$ IN @ C$pair$ SND Vp @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs @ @ C$pred_set$ IMAGE Vf Vt @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ C$bool$ IN Vs' @ @ C$pred_set$ IMAGE | Vn @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp Vs @ @ C$bool$ IN @ C$pair$ SND Vp @ Vf Vn Vt @ @ C$bool$ IN Vx Vs'"}, "plain": {"assumptions": [], "goal": "{p | FST p \u2208 (s :\u03b3 -> bool) \u2227 SND p \u2208 {x | \u2203(s :\u03b2 -> bool). s \u2208 IMAGE (f :\u03b1 -> \u03b2 -> bool) (t :\u03b1 -> bool) \u2227 x \u2208 s}} = {x | \u2203(s' :\u03b3 # \u03b2 -> bool). s' \u2208 IMAGE (\u03bb(n :\u03b1). {p | FST p \u2208 s \u2227 SND p \u2208 f n}) t \u2227 x \u2208 s'}"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.CROSS_DEF, pred_setTheory.SUBSET_applied, pred_setTheory.CROSS_DEF, pred_setTheory.IN_DFUNSET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vp @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vp @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ @ C$pred_set$ IMAGE Vf Vt Vs @ Vs @ C$pair$ SND Vp | Vx @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ @ C$pred_set$ IMAGE | Vn | Vp @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vp @ @ Vf Vn @ C$pair$ SND Vp Vt Vs' @ Vs' Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(p :\u03b3 # \u03b2). (s :\u03b3 -> bool) (FST p) \u2227 \u2203(s :\u03b2 -> bool). IMAGE (f :\u03b1 -> \u03b2 -> bool) (t :\u03b1 -> bool) s \u2227 s (SND p)) = (\u03bb(x :\u03b3 # \u03b2). \u2203(s' :\u03b3 # \u03b2 -> bool). IMAGE (\u03bb(n :\u03b1) (p :\u03b3 # \u03b2). s (FST p) \u2227 f n (SND p)) t s' \u2227 s' x)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.DIFF_BIGINTER, pred_setTheory.INTER_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vp @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vp @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vs @ Vf Vx @ Vt Vx @ Vs @ C$pair$ SND Vp | Vx @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ @ C$min$ = Vs' | Vp @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vp @ @ Vf Vn @ C$pair$ SND Vp @ Vt Vn @ Vs' Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(p :\u03b3 # \u03b2). (s :\u03b3 -> bool) (FST p) \u2227 \u2203(s :\u03b2 -> bool). (\u2203(x :\u03b1). s = (f :\u03b1 -> \u03b2 -> bool) x \u2227 (t :\u03b1 -> bool) x) \u2227 s (SND p)) = (\u03bb(x :\u03b3 # \u03b2). \u2203(s' :\u03b3 # \u03b2 -> bool). (\u2203(n :\u03b1). s' = (\u03bb(p :\u03b3 # \u03b2). s (FST p) \u2227 f n (SND p)) \u2227 t n) \u2227 s' x)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPECIFICATION, pred_setTheory.SUBSET_BIGUNION_I, pred_setTheory.IMAGE_applied, pred_setTheory.FINITE_DIFF_down]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vp @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vp @ @ C$bool$ /\\ @ Vt Vx @ @ Vf Vx @ C$pair$ SND Vp | Vx @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ Vt Vn @ @ C$bool$ /\\ @ Vs @ C$pair$ FST Vx @ @ Vf Vn @ C$pair$ SND Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(p :\u03b3 # \u03b2). \u2203(x :\u03b1). (s :\u03b3 -> bool) (FST p) \u2227 (t :\u03b1 -> bool) x \u2227 (f :\u03b1 -> \u03b2 -> bool) x (SND p)) = (\u03bb(x :\u03b3 # \u03b2). \u2203(n :\u03b1). t n \u2227 s (FST x) \u2227 f n (SND x))"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.DISJOINT_DIFFS, pred_setTheory.GSPECIFICATION_applied, boolTheory.PULL_EXISTS, pred_setTheory.SUBSET_BIGUNION_I, pred_setTheory.EQ_SUBSET_SUBSET]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.IN_FUNSET, pred_setTheory.IMAGE_applied, pred_setTheory.FINITE_INJ, pred_setTheory.IN_APP]", "reward": 5}]], "\ud835\udd4c(:\u03b1 + \u03b2) = \ud835\udd4c(:\u03b1) \u2294 \ud835\udd4c(:\u03b2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = C$pred_set$ UNIV @ @ C$pred_set$ disjUNION C$pred_set$ UNIV C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1 + \u03b2) = \ud835\udd4c(:\u03b1) \u2294 \ud835\udd4c(:\u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ C$sum$ INL Vx @ @ C$bool$ IN Vx C$pred_set$ UNIV @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ C$sum$ INR Vx @ @ C$bool$ IN Vx C$pred_set$ UNIV @ @ C$pred_set$ disjUNION C$pred_set$ UNIV C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "{(INL x :\u03b1 + \u03b2) | x \u2208 \ud835\udd4c(:\u03b1)} \u222a {(INR x :\u03b1 + \u03b2) | x \u2208 \ud835\udd4c(:\u03b2)} = \ud835\udd4c(:\u03b1) \u2294 \ud835\udd4c(:\u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_HAS_SIZE, pred_setTheory.HAS_SIZE_0, pred_setTheory.IMAGE_DEF, pred_setTheory.SUM_UNIV, pred_setTheory.schroeder_close_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_BIGUNION, pred_setTheory.DIFF_BIGINTER, pred_setTheory.INJ_IFF, pred_setTheory.disjUNION_def, pred_setTheory.BIGINTER_applied]", "reward": 5}]], "RC ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ RC C$pred_set$ SUBSET C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "RC ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET @ C$relation$ RC C$pred_set$ SUBSET C$pred_set$ SUBSET @ @ C$relation$ RSUBSET C$pred_set$ SUBSET @ C$relation$ RC C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "RC ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2227 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 RC ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.TC_CASES1, pred_setTheory.GSPEC_ETA, relationTheory.EqIsBothRSUBSET, relationTheory.SC_DEF, relationTheory.STRORD]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$pred_set$ SUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x = y \u2228 x \u2286 y \u21d2 x \u2286 y"}}], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.inv_Id, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPECIFICATION_applied, relationTheory.RSUBSET, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx' Vx", "@ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' Vx @ @ C$bool$ IN Vx' Vy"], "goal": "@ @ C$bool$ IN Vx' Vy"}, "plain": {"assumptions": ["(x' :\u03b1) \u2208 (x :\u03b1 -> bool)", "\u2200(x' :\u03b1). x' \u2208 (x :\u03b1 -> bool) \u21d4 x' \u2208 (y :\u03b1 -> bool)"], "goal": "(x' :\u03b1) \u2208 (y :\u03b1 -> bool)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[relationTheory.approx_def, pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, relationTheory.antisymmetric_def]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, relationTheory.approx_def, pred_setTheory.SUBSET_DEF, relationTheory.inv_DEF, relationTheory.IDEM_DEF]", "reward": 5}]], "\u2200(l :bool list). AND_EL l \u21d4 FOLDR $/\\ T l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$rich_list$ AND_EL Vl @ @ @ C$list$ FOLDR C$bool$ /\\ C$bool$ T Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :bool list). AND_EL l \u21d4 FOLDR $/\\ T l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP_SNOC, rich_listTheory.FLAT_FLAT, listTheory.GENLIST_PLUS_APPEND, rich_listTheory.AND_EL_DEF, rich_listTheory.EVERY_FOLDR_MAP]", "reward": 5}]], "(([(f :\u03b2 -> \u03b1)] <*> (l :\u03b2 list)) :\u03b1 list) = MAP f l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_APPLY @ @ C$list$ CONS Vf C$list$ NIL Vl @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "(([(f :\u03b2 -> \u03b1)] <*> (l :\u03b2 list)) :\u03b1 list) = MAP f l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_BIND_THM, listTheory.LIST_APPLY_def, listTheory.FRONT_DEF, listTheory.DROP_LENGTH_TOO_LONG, listTheory.SINGL_LIST_APPLY_L]", "reward": 5}]], "REPLICATE (x :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 x = (0 :num)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE Vx Vy C$list$ NIL @ @ C$min$ = Vx C$num$ 0"}, "plain": {"assumptions": [], "goal": "REPLICATE (x :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 x = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE C$num$ 0 Vy C$list$ NIL @ @ C$min$ = C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "REPLICATE (0 :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 (0 :num) = (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE Vx Vy C$list$ NIL @ @ C$min$ = Vx C$num$ 0"], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vx Vy C$list$ NIL @ @ C$min$ = @ C$num$ SUC Vx C$num$ 0"}, "plain": {"assumptions": ["REPLICATE (x :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 x = (0 :num)"], "goal": "REPLICATE (SUC (x :num)) (y :\u03b1) = ([] :\u03b1 list) \u21d4 SUC x = (0 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE Vx Vy C$list$ NIL @ @ C$min$ = Vx C$num$ 0"], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vx Vy C$list$ NIL @ @ C$min$ = @ C$num$ SUC Vx C$num$ 0"}, "plain": {"assumptions": ["REPLICATE (x :num) (y :\u03b1) = ([] :\u03b1 list) \u21d4 x = (0 :num)"], "goal": "REPLICATE (SUC (x :num)) (y :\u03b1) = ([] :\u03b1 list) \u21d4 SUC x = (0 :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.REPLICATE, listTheory.exists_list_GENLIST, listTheory.LAST_CONS, listTheory.list_case_def, listTheory.list_case_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_EQ_REWRITE, rich_listTheory.REPLICATE_GENLIST, rich_listTheory.LASTN_APPEND1, listTheory.LENGTH_EQ_NIL, listTheory.SWAP_REVERSE_SYM]", "reward": 5}]], "{x | T} = \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx C$bool$ T C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "{x | T} = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.UNIV_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.FINITE_UNION, pred_setTheory.EXTENSION, pred_setTheory.COUNT_11]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE (REST s) \u21d4 FINITE s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$pred_set$ FINITE @ C$pred_set$ REST Vs @ C$pred_set$ FINITE Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE (REST s) \u21d4 FINITE s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ FINITE @ C$pred_set$ REST Vs @ C$pred_set$ FINITE Vs"}, "plain": {"assumptions": [], "goal": "FINITE (REST (s :\u03b1 -> bool)) \u21d4 FINITE s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_FORALL_OR_THM, boolTheory.MONO_EXISTS, pred_setTheory.UNIV_SUBSET, boolTheory.LEFT_FORALL_IMP_THM, pred_setTheory.INSERT_UNION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.FINITE_DELETE, pred_setTheory.REST_DEF, pred_setTheory.SPECIFICATION, pred_setTheory.BIJ_IMAGE, pred_setTheory.INTER_OVER_UNION]", "reward": 5}]], "GSPEC (f :\u03b2 -> \u03b1 # bool) = IMAGE ((FST :\u03b1 # bool -> \u03b1) \u2218 f) ((SND :\u03b1 # bool -> bool) \u2218 f)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC Vf @ @ C$pred_set$ IMAGE @ @ C$combin$ o C$pair$ FST Vf @ @ C$combin$ o C$pair$ SND Vf"}, "plain": {"assumptions": [], "goal": "GSPEC (f :\u03b2 -> \u03b1 # bool) = IMAGE ((FST :\u03b1 # bool -> \u03b1) \u2218 f) ((SND :\u03b1 # bool -> bool) \u2218 f)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC Vf @ C$pred_set$ GSPEC | Vx @ Vf Vx"}, "plain": {"assumptions": [], "goal": "GSPEC (f :\u03b2 -> \u03b1 # bool) = GSPEC (\u03bb(x :\u03b2). f x)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.IN_DIFF, pred_setTheory.IMAGE_DEF, pred_setTheory.IN_DISJOINT, pred_setTheory.SUBSET_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.IN_IMAGE, pred_setTheory.INSERT_DEF, pred_setTheory.UNIV_applied]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 \u2203(x :\u03b1). x \u2208 s \u2227 x \u2209 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ~ @ C$pred_set$ FINITE Vs @ C$pred_set$ FINITE Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 \u2203(x :\u03b1). x \u2208 s \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$pred_set$ FINITE Vt", "@ C$bool$ ~ @ C$pred_set$ FINITE Vs"], "goal": "@ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": ["FINITE (t :\u03b1 -> bool)", "INFINITE (s :\u03b1 -> bool)"], "goal": "\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 x \u2209 (t :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNION_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.BIJ_DEF, pred_setTheory.EXTENSION, pred_setTheory.BIJ_FINITE_SUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.COND_RATOR, pred_setTheory.IN_APP, boolTheory.RES_EXISTS_FALSE, pred_setTheory.INFINITE_SUBSET, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = REVERSE l2 \u21d4 l1 = l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = @ C$list$ REVERSE Vl1 @ C$list$ REVERSE Vl2 @ @ C$min$ = Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). REVERSE l1 = REVERSE l2 \u21d4 l1 = l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_CONG, listTheory.REVERSE_REVERSE, listTheory.LIST_REL_EVERY_ZIP, boolTheory.EXISTS_UNIQUE_DEF, listTheory.EVERY_FILTER]", "reward": 5}]], "trichotomous (RC (R :\u03b1 -> \u03b1 -> bool)) \u21d4 trichotomous R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ trichotomous @ C$relation$ RC VR @ C$relation$ trichotomous VR"}, "plain": {"assumptions": [], "goal": "trichotomous (RC (R :\u03b1 -> \u03b1 -> bool)) \u21d4 trichotomous R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Va Vb @ @ VR Va Vb @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Vb Va @ @ VR Vb Va @ @ C$min$ = Va Vb @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$bool$ \\/ @ @ VR Va Vb @ @ C$bool$ \\/ @ @ VR Vb Va @ @ C$min$ = Va Vb"}, "plain": {"assumptions": [], "goal": "(\u2200(a :\u03b1) (b :\u03b1). (a = b \u2228 (R :\u03b1 -> \u03b1 -> bool) a b) \u2228 (b = a \u2228 R b a) \u2228 a = b) \u21d4 \u2200(a :\u03b1) (b :\u03b1). R a b \u2228 R b a \u2228 a = b"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.trichotomous, relationTheory.RC_DEF, relationTheory.RESTRICT_LEMMA, relationTheory.RCOMPL, relationTheory.StrongOrder]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.irreflexive_inv, relationTheory.RTC_cases, relationTheory.RSUBSET, relationTheory.SC_IDEM, relationTheory.inv_image_def]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 IMAGE f s \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ IMAGE Vf Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 IMAGE f s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ @ C$pred_set$ IMAGE Vf Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 (\u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 f x = f y \u21d2 x = y) \u21d2 \u2200(x :\u03b2). IMAGE f s x \u21d2 t x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.UNION_applied, pred_setTheory.INJ_DEF, pred_setTheory.INTER_DEF, pred_setTheory.IN_DELETE, pred_setTheory.SUBSET_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.REST_SING, pred_setTheory.IMAGE_applied, pred_setTheory.IN_INSERT, pred_setTheory.UNIV_applied]", "reward": 5}]], "PROD_ALL (P :\u03b1 -> bool) (Q :\u03b2 -> bool) ((x :\u03b1),(y :\u03b2)) \u21d4 P x \u2227 Q y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$pair$ PROD_ALL VP VQ @ @ C$pair$ , Vx Vy @ @ C$bool$ /\\ @ VP Vx @ VQ Vy"}, "plain": {"assumptions": [], "goal": "PROD_ALL (P :\u03b1 -> bool) (Q :\u03b2 -> bool) ((x :\u03b1),(y :\u03b2)) \u21d4 P x \u2227 Q y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_THM, boolTheory.IN_DEF, pairTheory.PAIR, pairTheory.CLOSED_PAIR_EQ, pairTheory.PROD_ALL_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (RTC' :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). RTC' x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 RTC' y z \u21d2 RTC' x z) \u21d2 \u2200(a0 :\u03b1) (a1 :\u03b1). R\ua673 a0 a1 \u21d2 RTC' a0 a1": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VRTC' @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ VRTC' Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VRTC' Vy Vz @ @ VRTC' Vx Vz @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Va0 Va1 @ @ VRTC' Va0 Va1"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (RTC' :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). RTC' x x) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 RTC' y z \u21d2 RTC' x z) \u21d2 \u2200(a0 :\u03b1) (a1 :\u03b1). R\ua673 a0 a1 \u21d2 RTC' a0 a1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ? | VRTC' @ C$bool$ ! | Va0' @ C$bool$ ! | Va1' @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Va1' Va0' @ C$bool$ ~ @ @ VR Va0' Vy @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Va1' Va0' @ C$bool$ ~ @ @ VRTC' Vy Va1' @ @ VRTC' Va0' Va1' @ C$bool$ ~ @ @ VRTC' Va0 Va1 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ C$bool$ ~ @ @ VRTC' Vx Vx @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ C$bool$ ? | Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VRTC' Vy Vz @ C$bool$ ~ @ @ VRTC' Vx Vz @ @ VRTC' Va0 Va1"}, "plain": {"assumptions": [], "goal": "(\u2203(RTC' :\u03b1 -> \u03b1 -> bool). \u2200(a0' :\u03b1) (a1' :\u03b1). ((\u2200(y :\u03b1). a1' \u2260 a0' \u2227 \u00ac(R :\u03b1 -> \u03b1 -> bool) a0' y \u2228 a1' \u2260 a0' \u2227 \u00acRTC' y a1') \u2228 RTC' a0' a1') \u2227 \u00acRTC' (a0 :\u03b1) (a1 :\u03b1)) \u2228 ((\u2203(x :\u03b1). \u00ac(RTC' :\u03b1 -> \u03b1 -> bool) x x) \u2228 \u2203(x :\u03b1) (y :\u03b1) (z :\u03b1). (R x y \u2227 RTC' y z) \u2227 \u00acRTC' x z) \u2228 RTC' a0 a1"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.RTC_def, boolTheory.PULL_FORALL, boolTheory.UNWIND_THM1, boolTheory.LEFT_AND_OVER_OR, boolTheory.IMP_DISJ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.OR_IMP_THM, relationTheory.TC_DEF, relationTheory.symmetric_def, relationTheory.reflexive_def, relationTheory.reflexive_def]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = x INSERT s \u222a t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ UNION @ @ C$pred_set$ INSERT Vx Vs Vt @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ UNION Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = x INSERT s \u222a t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx Vt"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx' @ @ C$pred_set$ UNION Vs Vt @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' @ @ C$pred_set$ UNION Vs Vt"}, "plain": {"assumptions": ["(x :\u03b1) \u2208 (t :\u03b1 -> bool)"], "goal": "(x' :\u03b1) \u2208 (s :\u03b1 -> bool) \u222a (t :\u03b1 -> bool) \u21d4 x' = (x :\u03b1) \u2228 x' \u2208 s \u222a t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INSERT, pred_setTheory.EXTENSION, pred_setTheory.INSERT_UNION, pred_setTheory.DIFF_DEF, boolTheory.CONJ_ASSOC]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_INSERT, pred_setTheory.IN_UNION, pred_setTheory.UNION_applied, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.SUBSET_ANTISYM_EQ]", "reward": 5}]], "(pair_CASE (p :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = (v :\u03b1) \u21d4 \u2203(x :\u03b2) (y :\u03b3). p = (x,y) \u2227 f x y = v": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$pair$ pair_CASE Vp Vf Vv @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vp @ @ C$pair$ , Vx Vy @ @ C$min$ = @ @ Vf Vx Vy Vv"}, "plain": {"assumptions": [], "goal": "(pair_CASE (p :\u03b2 # \u03b3) (f :\u03b2 -> \u03b3 -> \u03b1) :\u03b1) = (v :\u03b1) \u21d4 \u2203(x :\u03b2) (y :\u03b3). p = (x,y) \u2227 f x y = v"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.OR_CONG, pairTheory.PAIR, pairTheory.pair_case_def, pairTheory.CURRY_DEF, pairTheory.COMMA_DEF]", "reward": 5}]], "\u2200(x :\u03b1 -> bool). BIGUNION {x} = x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$pred_set$ BIGUNION @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool). BIGUNION {x} = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ BIGUNION @ @ C$pred_set$ INSERT Vx | Vx C$bool$ F Vx' @ Vx Vx'"}, "plain": {"assumptions": [], "goal": "BIGUNION ((x :\u03b1 -> bool) INSERT (\u03bb(x :\u03b1 -> bool). F)) (x' :\u03b1) \u21d4 x x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, pred_setTheory.HAS_SIZE_CARD, pred_setTheory.GSPEC_ETA, pred_setTheory.DELETE_DEF, pred_setTheory.EMPTY_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.BIGUNION_applied, pred_setTheory.IN_DELETE, pred_setTheory.INSERT_applied, pred_setTheory.BIGUNION_applied]", "reward": 5}]], "\u2200(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT Vl @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :num list list). SUM (FLAT l) = SUM (MAP SUM l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT C$list$ NIL @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUM (FLAT ([] :num list list)) = SUM (MAP SUM ([] :num list list))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT Vl @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (FLAT (l :num list list)) = SUM (MAP SUM l)"], "goal": "\u2200(h :num list). SUM (FLAT (h::(l :num list list))) = SUM (MAP SUM (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT Vl @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ SUM @ C$list$ FLAT @ @ C$list$ CONS Vh Vl @ C$list$ SUM @ @ C$list$ MAP C$list$ SUM @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["SUM (FLAT (l :num list list)) = SUM (MAP SUM l)"], "goal": "\u2200(h :num list). SUM (FLAT (h::(l :num list list))) = SUM (MAP SUM (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.OPT_MMAP_cong, listTheory.NRC_LRC, listTheory.oEL_def, listTheory.APPEND_LENGTH_EQ, boolTheory.EQ_SYM_EQ]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.every_zip_fst, listTheory.MEM_ZIP, listTheory.LIST_EQ_REWRITE, listTheory.SUM_APPEND, listTheory.SNOC_APPEND]", "reward": 5}]], "(\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool)) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 (P :\u03b1 -> bool) x) \u21d2 P (CHOICE s)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ VP Vx @ VP @ C$pred_set$ CHOICE Vs"}, "plain": {"assumptions": [], "goal": "(\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool)) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 (P :\u03b1 -> bool) x) \u21d2 P (CHOICE s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.CHOICE_DEF, boolTheory.AND_CLAUSES, pred_setTheory.IN_GSPEC_IFF, boolTheory.COND_RAND, pred_setTheory.MEMBER_NOT_EMPTY]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (u :\u03b1 -> bool) (t :\u03b2 -> bool). s \u2286 u \u2227 IMAGE f u \u2286 t \u21d2 IMAGE f s \u2286 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vu @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vu @ @ C$pred_set$ SUBSET @ @ C$pred_set$ IMAGE Vf Vu Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ IMAGE Vf Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (u :\u03b1 -> bool) (t :\u03b2 -> bool). s \u2286 u \u2227 IMAGE f u \u2286 t \u21d2 IMAGE f s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vu @ @ C$bool$ IN Vx Vt", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vu"], "goal": "@ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": ["(x :\u03b2) \u2208 IMAGE (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool)", "\u2200(x :\u03b2). x \u2208 IMAGE (f :\u03b1 -> \u03b2) (u :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b2 -> bool)", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 x \u2208 (u :\u03b1 -> bool)"], "goal": "(x :\u03b2) \u2208 (t :\u03b2 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_INSERT_RIGHT, boolTheory.EQ_SYM_EQ, boolTheory.CONJ_ASSOC, pred_setTheory.SURJ_COMPOSE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.DISJOINT_DEF, pred_setTheory.IN_IMAGE, pred_setTheory.IN_DIFF, pred_setTheory.SING_applied, boolTheory.FUN_EQ_THM]", "reward": 5}]], "BIJ (f :\u03b1 -> \u03b2) \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) \u21d2 \u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d4 x = y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ @ C$pred_set$ BIJ Vf C$pred_set$ UNIV C$pred_set$ UNIV @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "BIJ (f :\u03b1 -> \u03b2) \ud835\udd4c(:\u03b1) \ud835\udd4c(:\u03b2) \u21d2 \u2200(x :\u03b1) (y :\u03b1). f x = f y \u21d4 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_EMPTY, pred_setTheory.PAIR_IN_GSPEC_IFF, pred_setTheory.BIJ_DEF, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.INJ_IFF]", "reward": 5}]], "\u2200(n1 :num) (n2 :num). count n1 = count n2 \u21d4 n1 = n2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn1 @ C$bool$ ! | Vn2 @ @ C$min$ = @ @ C$min$ = @ C$pred_set$ count Vn1 @ C$pred_set$ count Vn2 @ @ C$min$ = Vn1 Vn2"}, "plain": {"assumptions": [], "goal": "\u2200(n1 :num) (n2 :num). count n1 = count n2 \u21d4 n1 = n2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.PAIR_IN_GSPEC_1, boolTheory.RIGHT_AND_FORALL_THM, pred_setTheory.CARD_COUNT, pred_setTheory.IN_ABS, pred_setTheory.SUBSET_TRANS]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). (\u03bb(x :\u03b1). x) PERMUTES s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ @ C$pred_set$ BIJ | Vx Vx Vs Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u03bb(x :\u03b1). x) PERMUTES s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SURJ_DEF, pred_setTheory.BIJ_DEF, pred_setTheory.INJ_IFF, boolTheory.UNWIND_THM1, boolTheory.LCOMM_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R y z \u21d2 R\ua673 x z": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ @ C$relation$ RTC VR Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ RTC VR Vx Vy @ @ VR Vy Vz @ @ @ C$relation$ RTC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1). R\ua673 x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R y z \u21d2 R\ua673 x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, relationTheory.RTC_rules, boolTheory.literal_case_id, relationTheory.RTC_RTC, relationTheory.RTC_RTC]", "reward": 5}]], "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u222a y DIFF x = y DIFF x \u2227 x \u222a y DIFF y = x DIFF y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ DIFF @ @ C$pred_set$ UNION Vx Vy Vx @ @ C$pred_set$ DIFF Vy Vx @ @ C$min$ = @ @ C$pred_set$ DIFF @ @ C$pred_set$ UNION Vx Vy Vy @ @ C$pred_set$ DIFF Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u222a y DIFF x = y DIFF x \u2227 x \u222a y DIFF y = x DIFF y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' Vx @ @ C$bool$ IN Vx' Vy @ C$bool$ ~ @ @ C$bool$ IN Vx' Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vy @ C$bool$ ~ @ @ C$bool$ IN Vx' Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' Vx @ @ C$bool$ IN Vx' Vy @ C$bool$ ~ @ @ C$bool$ IN Vx' Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). (\u2200(x' :\u03b1). (x' \u2208 x \u2228 x' \u2208 y) \u2227 x' \u2209 x \u21d4 x' \u2208 y \u2227 x' \u2209 x) \u2227 \u2200(x' :\u03b1). (x' \u2208 x \u2228 x' \u2208 y) \u2227 x' \u2209 y \u21d4 x' \u2208 x \u2227 x' \u2209 y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.NOT_PSUBSET_EMPTY, pred_setTheory.EXTENSION, pred_setTheory.DIFF_DEF, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.IN_UNION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_K, pred_setTheory.SUBSET_DEF, boolTheory.LCOMM_THM, pred_setTheory.SUBSET_DISJOINT]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f (x INSERT s) t \u21d4 INJ f s t \u2227 f x \u2208 t \u2227 \u2200(y :\u03b1). y \u2208 s \u2227 f x = f y \u21d2 x = y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ @ C$pred_set$ INJ Vf @ @ C$pred_set$ INSERT Vx Vs Vt @ @ C$bool$ /\\ @ @ @ C$pred_set$ INJ Vf Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f (x INSERT s) t \u21d4 INJ f s t \u2227 f x \u2208 t \u2227 \u2200(y :\u03b1). y \u2208 s \u2227 f x = f y \u21d2 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ IN @ Vf Vx' Vt @ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ IN Vy @ @ C$pred_set$ INSERT Vx Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx' @ Vf Vy @ @ C$min$ = Vx' Vy @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2208 (x :\u03b1) INSERT (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x' \u2208 (t :\u03b2 -> bool)) \u2227 (\u2200(x' :\u03b1) (y :\u03b1). x' \u2208 x INSERT s \u2227 y \u2208 x INSERT s \u21d2 f x' = f y \u21d2 x' = y) \u21d4 ((\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 f x = f y \u21d2 x = y) \u2227 f x \u2208 t \u2227 \u2200(y :\u03b1). y \u2208 s \u2227 f x = f y \u21d2 x = y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_applied, boolTheory.OR_CLAUSES, pred_setTheory.DELETE_SUBSET, pred_setTheory.INJ_DEF, pred_setTheory.PSUBSET_INSERT_SUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_I, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_applied, boolTheory.FUN_EQ_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 \u2203(u :\u03b1). R x u \u2227 R\ua673 u y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$relation$ RTC VR Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ C$bool$ ? | Vu @ @ C$bool$ /\\ @ @ VR Vx Vu @ @ @ C$relation$ RTC VR Vu Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 \u2203(u :\u03b1). R x u \u2227 R\ua673 u y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, relationTheory.RTC_cases, boolTheory.OR_DEF, relationTheory.RTC_cases, relationTheory.EXTEND_RTC_TC_EQN]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ DIFF Vs Vt @ @ C$pred_set$ DIFF @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$pred_set$ PREIMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s DIFF t) = PREIMAGE f s DIFF PREIMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE Vf @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE Vf Vs @ C$bool$ ~ @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 PREIMAGE (f :\u03b1 -> \u03b2) {x | x \u2208 (s :\u03b2 -> bool) \u2227 x \u2209 (t :\u03b2 -> bool)} \u21d4 x \u2208 {x | x \u2208 PREIMAGE f s \u2227 x \u2209 PREIMAGE f t}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_BIGUNION, pred_setTheory.UNION_DEF, pred_setTheory.DIFF_DEF, pred_setTheory.EXTENSION, pred_setTheory.INJ_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.IMAGE_DEF, pred_setTheory.FINITE_PSUBSET_UNIV, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_PREIMAGE, pred_setTheory.GSPECIFICATION]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). DISJOINT s t \u21d2 DISJOINT (PREIMAGE f s) (PREIMAGE f t)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ DISJOINT Vs Vt @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$pred_set$ PREIMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). DISJOINT s t \u21d2 DISJOINT (PREIMAGE f s) (PREIMAGE f t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DELETE_DEF, pred_setTheory.DISJOINT_ALT, pred_setTheory.IN_PREIMAGE, pred_setTheory.UNIQUE_MEMBER_SING, pred_setTheory.INSERT_DEF]", "reward": 5}]], "\u2200(f :\u03b1 # \u03b2 -> \u03b3). UNCURRY (CURRY f) = f": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$pair$ UNCURRY @ C$pair$ CURRY Vf Vf"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 # \u03b2 -> \u03b3). UNCURRY (CURRY f) = f"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[pairTheory.PAIR, boolTheory.RES_SELECT_DEF, boolTheory.NOT_EXISTS_THM, pairTheory.CURRY_DEF, pairTheory.UNCURRY_VAR]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2286 s \u21d2 FINITE t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vt Vs @ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). t \u2286 s \u21d2 FINITE t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$pred_set$ UNION Vt Vs Vs", "@ C$pred_set$ FINITE Vs"], "goal": "@ C$pred_set$ FINITE Vt"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) \u222a (s :\u03b1 -> bool) = s", "FINITE (s :\u03b1 -> bool)"], "goal": "FINITE (t :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_DELETE, boolTheory.NOT_EXISTS_THM, pred_setTheory.BIJ_DEF, pred_setTheory.INSERT_applied, pred_setTheory.SUBSET_UNION_ABSORPTION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.FINITE_UNION, pred_setTheory.FINITE_INSERT, pred_setTheory.IN_UNION, pred_setTheory.FINITE_UNION, pred_setTheory.SUBSET_INSERT]", "reward": 5}]], "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c c \u21d2 a \u227c c": [16, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a ++ b \u227c c \u21d2 a \u227c c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(b :\u03b1 list) (c :\u03b1 list). ([] :\u03b1 list) \u29fa b \u227c c \u21d2 ([] :\u03b1 list) \u227c c"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va Vc"}, "plain": {"assumptions": ["\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "\u2200(h :\u03b1) (b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c c \u21d2 h::a \u227c c"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va Vc"}, "plain": {"assumptions": ["\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "\u2200(h :\u03b1) (b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c c \u21d2 h::a \u227c c"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL C$list$ NIL Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :\u03b1 list). ([] :\u03b1 list) \u29fa ([] :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"}, "plain": {"assumptions": ["\u2200(c :\u03b1 list). ([] :\u03b1 list) \u29fa (b :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"], "goal": "\u2200(h :\u03b1) (c :\u03b1 list). ([] :\u03b1 list) \u29fa h::(b :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `b`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL C$list$ NIL Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :\u03b1 list). ([] :\u03b1 list) \u29fa ([] :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc"}, "plain": {"assumptions": ["\u2200(c :\u03b1 list). ([] :\u03b1 list) \u29fa (b :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"], "goal": "\u2200(h :\u03b1) (c :\u03b1 list). ([] :\u03b1 list) \u29fa h::(b :\u03b1 list) \u227c c \u21d2 ([] :\u03b1 list) \u227c c"}}, {"polished": {"assumptions": ["@ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc", "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ @ @ C$list$ list_CASE Vc C$bool$ F | Vh' | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vh Vh' @ @ C$list$ isPREFIX Va Vt'"}, "plain": {"assumptions": ["(h :\u03b1)::(a :\u03b1 list) \u29fa (b :\u03b1 list) \u227c (c :\u03b1 list)", "\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "case (c :\u03b1 list) of ([] :\u03b1 list) => F | h'::t' => (h :\u03b1) = h' \u2227 (a :\u03b1 list) \u227c t'"}}], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.IMP_ANTISYM_AX, boolTheory.EQ_TRANS, listTheory.list_distinct, listTheory.LENGTH_NIL, listTheory.TAKE_APPEND2]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va Vc"}, "plain": {"assumptions": ["\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "\u2200(h :\u03b1) (b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c c \u21d2 h::a \u227c c"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.LEN_LENGTH_LEM, listTheory.MAP_MAP_o, listTheory.FRONT_DEF, listTheory.PAD_LEFT, listTheory.DROP_TAKE]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ @ C$list$ list_CASE Vc C$bool$ F | Vh' | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vh Vh' @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vt'", "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ @ @ C$list$ list_CASE Vc C$bool$ F | Vh' | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vh Vh' @ @ C$list$ isPREFIX Va Vt'"}, "plain": {"assumptions": ["case (c :\u03b1 list) of ([] :\u03b1 list) => F | h'::t' => (h :\u03b1) = h' \u2227 (a :\u03b1 list) \u29fa (b :\u03b1 list) \u227c t'", "\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "case (c :\u03b1 list) of ([] :\u03b1 list) => F | h'::t' => (h :\u03b1) = h' \u2227 (a :\u03b1 list) \u227c t'"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.DROP_TAKE, listTheory.PAD_RIGHT, listTheory.ALL_DISTINCT_APPEND, listTheory.adjacent_cases, rich_listTheory.EVERY2_APPEND_suff]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ C$list$ TL Vc", "@ @ C$min$ = Vh @ C$list$ HD Vc", "@ C$bool$ ~ @ C$list$ NULL Vc", "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ @ C$list$ isPREFIX Va @ C$list$ TL Vc"}, "plain": {"assumptions": ["(a :\u03b1 list) \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list)", "(h :\u03b1) = HD (c :\u03b1 list)", "\u00acNULL (c :\u03b1 list)", "\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "(a :\u03b1 list) \u227c TL (c :\u03b1 list)"}}], "parent": 4, "goal": 0, "by_tactic": "fs[boolTheory.EQ_IMP_THM, listTheory.list_case_compute, listTheory.UNIQUE_DEF, listTheory.ZIP_EQ_NIL, listTheory.LIST_REL_cases]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc", "@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc"], "goal": "@ @ @ C$list$ list_CASE Vc C$bool$ F | Vh' | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vh Vh' @ @ C$list$ isPREFIX Va Vt'"}, "plain": {"assumptions": ["(h :\u03b1)::(a :\u03b1 list) \u29fa (b :\u03b1 list) \u227c (c :\u03b1 list)", "\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c"], "goal": "case (c :\u03b1 list) of ([] :\u03b1 list) => F | h'::t' => (h :\u03b1) = h' \u2227 (a :\u03b1 list) \u227c t'"}}], "parent": 4, "goal": 0, "by_tactic": "simp[listTheory.DROP_TAKE, listTheory.EL_REVERSE, listTheory.MEM_MAP, listTheory.LIST_IGNORE_BIND_def, listTheory.LIST_TO_SET_GENLIST]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = Vh @ C$list$ HD Vc", "@ C$bool$ ~ @ C$list$ NULL Vc"], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb Vc @ @ C$list$ isPREFIX C$list$ NIL Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND C$list$ NIL Vb @ C$list$ TL Vc @ @ C$list$ isPREFIX C$list$ NIL @ C$list$ TL Vc"}, "plain": {"assumptions": ["(h :\u03b1) = HD (c :\u03b1 list)", "\u00acNULL (c :\u03b1 list)"], "goal": "(\u2200(b :\u03b1 list) (c :\u03b1 list). ([] :\u03b1 list) \u29fa b \u227c c \u21d2 ([] :\u03b1 list) \u227c c) \u21d2 ([] :\u03b1 list) \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list) \u21d2 ([] :\u03b1 list) \u227c TL c"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ C$list$ TL Vc @ @ C$list$ isPREFIX Va @ C$list$ TL Vc", "@ @ C$min$ = Vh @ C$list$ HD Vc", "@ C$bool$ ~ @ C$list$ NULL Vc"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb @ C$list$ TL Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va @ C$list$ TL Vc"}, "plain": {"assumptions": ["(\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c) \u21d2 a \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list) \u21d2 a \u227c TL c", "(h :\u03b1) = HD (c :\u03b1 list)", "\u00acNULL (c :\u03b1 list)"], "goal": "\u2200(h :\u03b1). (\u2200(b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c c \u21d2 h::a \u227c c) \u21d2 h::a \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list) \u21d2 h::a \u227c TL c"}}], "parent": 6, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb Vc @ @ C$list$ isPREFIX Va Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND Va Vb @ C$list$ TL Vc @ @ C$list$ isPREFIX Va @ C$list$ TL Vc", "@ @ C$min$ = Vh @ C$list$ HD Vc", "@ C$bool$ ~ @ C$list$ NULL Vc"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Va Vb @ C$list$ TL Vc @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Va @ C$list$ TL Vc"}, "plain": {"assumptions": ["(\u2200(b :\u03b1 list) (c :\u03b1 list). (a :\u03b1 list) \u29fa b \u227c c \u21d2 a \u227c c) \u21d2 a \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list) \u21d2 a \u227c TL c", "(h :\u03b1) = HD (c :\u03b1 list)", "\u00acNULL (c :\u03b1 list)"], "goal": "\u2200(h :\u03b1). (\u2200(b :\u03b1 list) (c :\u03b1 list). h::(a :\u03b1 list) \u29fa b \u227c c \u21d2 h::a \u227c c) \u21d2 h::a \u29fa (b :\u03b1 list) \u227c TL (c :\u03b1 list) \u21d2 h::a \u227c TL c"}}], "parent": 8, "goal": 0, "by_tactic": "rw[listTheory.LIST_GUARD_def, boolTheory.SKOLEM_THM, listTheory.LENGTH_FRONT_CONS, listTheory.INDEX_OF_def, listTheory.PAD_RIGHT]", "reward": 0.2}, {"content": [], "parent": 9, "goal": 0, "by_tactic": "metis_tac[listTheory.SHORTLEX_def, listTheory.LENGTH_FRONT_CONS, listTheory.MEM_FILTER, listTheory.MEM_LUPDATE_E, listTheory.MEM_APPEND]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (BUTLASTN n l) = LENGTH l \u2212 n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ BUTLASTN Vn Vl @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LENGTH (BUTLASTN n l) = LENGTH l \u2212 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN_def, arithmeticTheory.MULT_EXP_MONO, rich_listTheory.NOT_NIL_SNOC, arithmeticTheory.DIV_EQ_X, arithmeticTheory.X_MOD_Y_EQ_X]", "reward": 5}]], "BIGUNION (\u2205 :(\u03b1 -> bool) -> bool) = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ BIGUNION C$pred_set$ EMPTY C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "BIGUNION (\u2205 :(\u03b1 -> bool) -> bool) = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION | Vx C$bool$ F @ @ C$bool$ IN Vx | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x \u2208 BIGUNION (\u03bb(x :\u03b1 -> bool). F) \u21d4 x \u2208 (\u03bb(x :\u03b1). F)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.EXTENSION, pred_setTheory.EMPTY_DEF, pred_setTheory.FINITE_REST_EQ, pred_setTheory.INTER_applied, pred_setTheory.RTC_SUBSET_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_BIGUNION, pred_setTheory.INTER_applied, pred_setTheory.EXTENSION]", "reward": 5}]], "(y :\u03b1) \u2208 RRANGE (R :\u03b2 -> \u03b1 -> bool) \u21d4 \u2203(x :\u03b2). R x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$relation$ RRANGE VR @ C$bool$ ? | Vx @ @ VR Vx Vy"}, "plain": {"assumptions": [], "goal": "(y :\u03b1) \u2208 RRANGE (R :\u03b2 -> \u03b1 -> bool) \u21d4 \u2203(x :\u03b2). R x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.IN_DEF, boolTheory.LET_DEF, relationTheory.RRANGE, relationTheory.RCOMPL, relationTheory.RC_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ = @ @ C$pred_set$ UNION Vs @ @ C$pred_set$ INTER Vt Vu @ @ C$pred_set$ INTER @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ UNION Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vu @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vu"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 (s :\u03b1 -> bool) \u2228 x \u2208 (t :\u03b1 -> bool) \u2227 x \u2208 (u :\u03b1 -> bool) \u21d4 (x \u2208 s \u2228 x \u2208 t) \u2227 (x \u2208 s \u2228 x \u2208 u)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.IN_INTER, pred_setTheory.IN_UNION, pred_setTheory.INTER_DEF, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.IN_INTER, pred_setTheory.IN_EQ_UNIV_IMP, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). (DISJOINT (s \u222a t) u \u21d4 DISJOINT s u \u2227 DISJOINT t u) \u2227 (DISJOINT u (s \u222a t) \u21d4 DISJOINT s u \u2227 DISJOINT t u)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ DISJOINT @ @ C$pred_set$ UNION Vs Vt Vu @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vs Vu @ @ C$pred_set$ DISJOINT Vt Vu @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vu @ @ C$pred_set$ UNION Vs Vt @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT Vs Vu @ @ C$pred_set$ DISJOINT Vt Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). (DISJOINT (s \u222a t) u \u21d4 DISJOINT s u \u2227 DISJOINT t u) \u2227 (DISJOINT u (s \u222a t) \u21d4 DISJOINT s u \u2227 DISJOINT t u)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$bool$ /\\ @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx @ @ C$pred_set$ UNION Vs Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ C$bool$ ~ @ @ C$bool$ IN Vx @ @ C$pred_set$ UNION Vs Vt @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vu @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). ((\u2200(x :\u03b1). x \u2209 s \u222a t \u2228 x \u2209 u) \u21d4 (\u2200(x :\u03b1). x \u2209 s \u2228 x \u2209 u) \u2227 \u2200(x :\u03b1). x \u2209 t \u2228 x \u2209 u) \u2227 ((\u2200(x :\u03b1). x \u2209 u \u2228 x \u2209 s \u222a t) \u21d4 (\u2200(x :\u03b1). x \u2209 s \u2228 x \u2209 u) \u2227 \u2200(x :\u03b1). x \u2209 t \u2228 x \u2209 u)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.EXTENSION, pred_setTheory.IN_DISJOINT, pred_setTheory.GSPECIFICATION, pred_setTheory.SUBSET_DEF, boolTheory.EQ_CLAUSES]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.UNION_EMPTY, pred_setTheory.EMPTY_DEF, boolTheory.LEFT_OR_EXISTS_THM, pred_setTheory.IN_UNION]", "reward": 5}]], "(R1 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R2 :\u03b1 -> \u03b2 -> bool) \u2227 (S1 :\u03b3 -> \u03b1 -> bool) \u2286\u1d63 (S2 :\u03b3 -> \u03b1 -> bool) \u21d2 R1 \u2218\u1d63 S1 \u2286\u1d63 R2 \u2218\u1d63 S2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$relation$ RSUBSET VR1 VR2 @ @ C$relation$ RSUBSET VS1 VS2 @ @ C$relation$ RSUBSET @ @ C$relation$ O VR1 VS1 @ @ C$relation$ O VR2 VS2"}, "plain": {"assumptions": [], "goal": "(R1 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R2 :\u03b1 -> \u03b2 -> bool) \u2227 (S1 :\u03b3 -> \u03b1 -> bool) \u2286\u1d63 (S2 :\u03b3 -> \u03b1 -> bool) \u21d2 R1 \u2218\u1d63 S1 \u2286\u1d63 R2 \u2218\u1d63 S2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR1 Vx Vy @ @ VR2 Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VS1 Vx Vy @ @ VS2 Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ C$bool$ ? | Vy' @ @ C$bool$ /\\ @ @ VS1 Vx Vy' @ @ VR1 Vy' Vy @ C$bool$ ? | Vy' @ @ C$bool$ /\\ @ @ VS2 Vx Vy' @ @ VR2 Vy' Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b2). (R1 :\u03b1 -> \u03b2 -> bool) x y \u21d2 (R2 :\u03b1 -> \u03b2 -> bool) x y) \u2227 (\u2200(x :\u03b3) (y :\u03b1). (S1 :\u03b3 -> \u03b1 -> bool) x y \u21d2 (S2 :\u03b3 -> \u03b1 -> bool) x y) \u21d2 \u2200(x :\u03b3) (y :\u03b2). (\u2203(y' :\u03b1). S1 x y' \u2227 R1 y' y) \u21d2 \u2203(y' :\u03b1). S2 x y' \u2227 R2 y' y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.IDEM_DEF, relationTheory.NOT_INVOL, relationTheory.O_DEF, relationTheory.WeakOrder_EQ, relationTheory.RSUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.RES_FORALL_DEF, relationTheory.approx_def, relationTheory.total_def, relationTheory.O_ASSOC, relationTheory.ALT_equivalence]", "reward": 5}]], "\u2200(n :num). SUM_SET {n} = n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ C$pred_set$ SUM_SET @ @ C$pred_set$ INSERT Vn C$pred_set$ EMPTY Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). SUM_SET {n} = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUM_SET_DEF, pred_setTheory.SUM_IMAGE_SING, pred_setTheory.FINITE_EMPTY, pred_setTheory.HAS_SIZE_0, pred_setTheory.FINITE_COUNT]", "reward": 5}]], "\u2200(x :\u03b1) (sos :(\u03b1 -> bool) -> bool). BIGUNION sos x \u21d4 \u2203(s :\u03b1 -> bool). x \u2208 s \u2227 s \u2208 sos": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vsos @ @ C$min$ = @ @ C$pred_set$ BIGUNION Vsos Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vs Vsos"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (sos :(\u03b1 -> bool) -> bool). BIGUNION sos x \u21d4 \u2203(s :\u03b1 -> bool). x \u2208 s \u2227 s \u2208 sos"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs Vsos @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vs Vsos"}, "plain": {"assumptions": [], "goal": "(\u2203(s :\u03b1 -> bool). s \u2208 (sos :(\u03b1 -> bool) -> bool) \u2227 (x :\u03b1) \u2208 s) \u21d4 \u2203(s :\u03b1 -> bool). x \u2208 s \u2227 s \u2208 sos"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPEC_ETA, pred_setTheory.BIGUNION, pred_setTheory.UNION_DEF, pred_setTheory.INSERT_applied, pred_setTheory.IMAGE_COMPOSE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_NOT_EQ, pred_setTheory.FINITE_DELETE, pred_setTheory.IN_APP, pred_setTheory.IN_APP, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGINTER (s1 \u222a s2) = BIGINTER s1 \u2229 BIGINTER s2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ @ C$min$ = @ C$pred_set$ BIGINTER @ @ C$pred_set$ UNION Vs1 Vs2 @ @ C$pred_set$ INTER @ C$pred_set$ BIGINTER Vs1 @ C$pred_set$ BIGINTER Vs2"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGINTER (s1 \u222a s2) = BIGINTER s1 \u2229 BIGINTER s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ BIGINTER @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ IN Vx Vs2 @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$pred_set$ BIGINTER Vs1 @ @ C$bool$ IN Vx @ C$pred_set$ BIGINTER Vs2"}, "plain": {"assumptions": [], "goal": "BIGINTER {x | x \u2208 (s1 :(\u03b1 -> bool) -> bool) \u2228 x \u2208 (s2 :(\u03b1 -> bool) -> bool)} = {x | x \u2208 BIGINTER s1 \u2227 x \u2208 BIGINTER s2}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_applied, pred_setTheory.UNION_DEF, pred_setTheory.INTER_DEF, pred_setTheory.IN_INSERT, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ \\/ @ Vs1 Vs @ Vs2 Vs @ Vs Vx | Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ ==> @ Vs1 Vs @ Vs Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ Vs2 Vs @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). \u2200(s :\u03b1 -> bool). (s1 :(\u03b1 -> bool) -> bool) s \u2228 (s2 :(\u03b1 -> bool) -> bool) s \u21d2 s x) = (\u03bb(x :\u03b1). (\u2200(s :\u03b1 -> bool). s1 s \u21d2 s x) \u2227 \u2200(s :\u03b1 -> bool). s2 s \u21d2 s x)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.DIFF_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA, pred_setTheory.BIGINTER]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.CHOICE_SING, pred_setTheory.EMPTY_DEF, pred_setTheory.IMAGE_applied, pred_setTheory.IMAGE_applied]", "reward": 5}]], "{x | (y :\u03b1) = x} = {y}": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$min$ = Vy Vx @ @ C$pred_set$ INSERT Vy C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "{x | (y :\u03b1) = x} = {y}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE @ @ C$combin$ o C$pair$ FST | Vx @ @ C$pair$ , Vx @ @ C$min$ = Vy Vx @ @ C$combin$ o C$pair$ SND | Vx @ @ C$pair$ , Vx @ @ C$min$ = Vy Vx @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$bool$ IN Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 IMAGE ((FST :\u03b1 # bool -> \u03b1) \u2218 (\u03bb(x :\u03b1). (x,(y :\u03b1) = x))) ((SND :\u03b1 # bool -> bool) \u2218 (\u03bb(x :\u03b1). (x,y = x))) \u21d4 x = y \u2228 x \u2208 (\u2205 :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_HAS_SIZE, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_T, pred_setTheory.GSPEC_IMAGE, pred_setTheory.IN_INSERT]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = Vy Vx @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "(y :\u03b1) = (x :\u03b1) \u21d4 x = y \u2228 \u2205 x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pairTheory.PAIR_MAP, pred_setTheory.IMAGE_applied, pred_setTheory.IN_INSERT, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_FINITE_I, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.BIGINTER_UNION, pred_setTheory.DELETE_applied]", "reward": 5}]], "\u2200(adjacent' :\u03b1 list -> \u03b1 -> \u03b1 -> bool). (\u2200(a :\u03b1) (b :\u03b1) (t :\u03b1 list). adjacent' (a::b::t) a b) \u2227 (\u2200(a :\u03b1) (b :\u03b1) (h :\u03b1) (t :\u03b1 list). adjacent' t a b \u21d2 adjacent' (h::t) a b) \u21d2 \u2200(a0 :\u03b1 list) (a1 :\u03b1) (a2 :\u03b1). adjacent a0 a1 a2 \u21d2 adjacent' a0 a1 a2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vadjacent' @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vt @ @ @ Vadjacent' @ @ C$list$ CONS Va @ @ C$list$ CONS Vb Vt Va Vb @ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vh @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ @ Vadjacent' Vt Va Vb @ @ @ Vadjacent' @ @ C$list$ CONS Vh Vt Va Vb @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ C$bool$ ! | Va2 @ @ C$min$ ==> @ @ @ C$list$ adjacent Va0 Va1 Va2 @ @ @ Vadjacent' Va0 Va1 Va2"}, "plain": {"assumptions": [], "goal": "\u2200(adjacent' :\u03b1 list -> \u03b1 -> \u03b1 -> bool). (\u2200(a :\u03b1) (b :\u03b1) (t :\u03b1 list). adjacent' (a::b::t) a b) \u2227 (\u2200(a :\u03b1) (b :\u03b1) (h :\u03b1) (t :\u03b1 list). adjacent' t a b \u21d2 adjacent' (h::t) a b) \u21d2 \u2200(a0 :\u03b1 list) (a1 :\u03b1) (a2 :\u03b1). adjacent a0 a1 a2 \u21d2 adjacent' a0 a1 a2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_IMP_THM, listTheory.lupdate_append2, boolTheory.EQ_IMP_THM, listTheory.adjacent_def, listTheory.adjacent_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\ua673": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$relation$ transitive @ C$relation$ RTC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\ua673"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ RTC VR Vx Vy @ @ @ C$relation$ RTC VR Vy Vz @ @ @ C$relation$ RTC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R\ua673 x y \u2227 R\ua673 y z \u21d2 R\ua673 x z"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.trichotomous, relationTheory.antisymmetric_def, relationTheory.transitive_def, boolTheory.COND_RAND, boolTheory.COND_CLAUSES]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_CONG, boolTheory.itself_case_thm, boolTheory.EXISTS_SIMP, boolTheory.bool_case_CONG, relationTheory.RTC_RTC]", "reward": 5}]], "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 antisymmetric R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$relation$ WF VR @ C$relation$ antisymmetric VR"}, "plain": {"assumptions": [], "goal": "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 antisymmetric R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | VB @ @ C$min$ ==> @ C$bool$ ? | Vw @ VB Vw @ C$bool$ ? | Vmin @ @ C$bool$ /\\ @ VB Vmin @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ VR Vb Vmin @ C$bool$ ~ @ VB Vb @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vx @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(B :\u03b1 -> bool). (\u2203(w :\u03b1). B w) \u21d2 \u2203(min :\u03b1). B min \u2227 \u2200(b :\u03b1). (R :\u03b1 -> \u03b1 -> bool) b min \u21d2 \u00acB b) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R x y \u2227 R y x \u21d2 x = y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.WF_DEF, relationTheory.SC_DEF, relationTheory.EMPTY_REL_DEF, relationTheory.irreflexive_def, relationTheory.antisymmetric_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.SC_DEF, relationTheory.EXTEND_RTC_TC_EQN, relationTheory.reflexive_def, relationTheory.EQC_DEF, relationTheory.RC_DEF]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). PREFIX P l \u227c l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (l :\u03b1 list). PREFIX P l \u227c l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). PREFIX P ([] :\u03b1 list) \u227c ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). PREFIX P (l :\u03b1 list) \u227c l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). PREFIX P (h::(l :\u03b1 list)) \u227c h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ C$rich_list$ PREFIX VP @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). PREFIX P (l :\u03b1 list) \u227c l"], "goal": "\u2200(h :\u03b1) (P :\u03b1 -> bool). PREFIX P (h::(l :\u03b1 list)) \u227c h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.PREFIX, listTheory.LENGTH_DROP, listTheory.REVERSE_DEF, listTheory.ITSET_eq_FOLDL_SET_TO_LIST, listTheory.LENGTH_EQ_NUM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VP @ @ C$list$ isPREFIX @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' C$list$ NIL C$list$ NIL Vl Vl"], "goal": "@ @ C$list$ isPREFIX @ @ @ C$bool$ COND @ VP Vh @ @ C$list$ CONS Vh @ @ @ C$list$ FOLDR | Vx | Vl' @ @ @ C$bool$ COND @ VP Vx @ @ C$list$ CONS Vx Vl' C$list$ NIL C$list$ NIL Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(P :\u03b1 -> bool). FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else ([] :\u03b1 list)) ([] :\u03b1 list) (l :\u03b1 list) \u227c l"], "goal": "(if (P :\u03b1 -> bool) (h :\u03b1) then h:: FOLDR (\u03bb(x :\u03b1) (l' :\u03b1 list). if P x then x::l' else ([] :\u03b1 list)) ([] :\u03b1 list) (l :\u03b1 list) else ([] :\u03b1 list)) \u227c h::l"}}], "parent": 2, "goal": 0, "by_tactic": "fs[rich_listTheory.PREFIX_FOLDR, listTheory.REVERSE_SNOC, rich_listTheory.FLAT_SNOC, rich_listTheory.LASTN_def, rich_listTheory.LENGTH_NOT_NULL]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_EQ_EMPTY, listTheory.FILTER_EQ_APPEND, listTheory.dropWhile_eq_nil, listTheory.LAST_CONS_cond, boolTheory.BOTH_FORALL_OR_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2286 s \u21d2 s DIFF (s DIFF t) = t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vt Vs @ @ C$min$ = @ @ C$pred_set$ DIFF Vs @ @ C$pred_set$ DIFF Vs Vt Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2286 s \u21d2 s DIFF (s DIFF t) = t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vs"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ DIFF Vs @ @ C$pred_set$ DIFF Vs Vt @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": ["\u2200(x :\u03b1). x \u2208 (t :\u03b1 -> bool) \u21d2 x \u2208 (s :\u03b1 -> bool)"], "goal": "(x :\u03b1) \u2208 (s :\u03b1 -> bool) DIFF (s DIFF (t :\u03b1 -> bool)) \u21d4 x \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_ALT, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF, pred_setTheory.INTER_applied, pred_setTheory.IN_UNION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_DEF, pred_setTheory.IN_DISJOINT, pred_setTheory.IN_DIFF, pred_setTheory.PSUBSET_DEF, pred_setTheory.DIFF_DEF]", "reward": 5}]], "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2229 s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u2229 \ud835\udd4c(:\u03b1) = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ INTER C$pred_set$ UNIV Vs Vs @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ INTER Vs C$pred_set$ UNIV Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 -> bool). \ud835\udd4c(:\u03b1) \u2229 s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u2229 \ud835\udd4c(:\u03b1) = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.EXTENSION, pred_setTheory.UNIV_DEF, pred_setTheory.UNION_DEF, pred_setTheory.IN_INTER]", "reward": 5}]], "\u2200(X :\u03b1 -> bool) (Y :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). Y \u2208 P \u2227 DISJOINT Y X \u21d2 DISJOINT X (BIGINTER P) \u2227 DISJOINT (BIGINTER P) X": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VX @ C$bool$ ! | VY @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN VY VP @ @ C$pred_set$ DISJOINT VY VX @ @ C$bool$ /\\ @ @ C$pred_set$ DISJOINT VX @ C$pred_set$ BIGINTER VP @ @ C$pred_set$ DISJOINT @ C$pred_set$ BIGINTER VP VX"}, "plain": {"assumptions": [], "goal": "\u2200(X :\u03b1 -> bool) (Y :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). Y \u2208 P \u2227 DISJOINT Y X \u21d2 DISJOINT X (BIGINTER P) \u2227 DISJOINT (BIGINTER P) X"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VX @ C$bool$ ! | VY @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN VY VP @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VY @ C$bool$ ~ @ @ C$bool$ IN Vx VX @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx VX @ C$bool$ ? | VP' @ @ C$bool$ /\\ @ @ C$bool$ IN VP' VP @ C$bool$ ~ @ @ C$bool$ IN Vx VP'"}, "plain": {"assumptions": [], "goal": "\u2200(X :\u03b1 -> bool) (Y :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). Y \u2208 P \u2227 (\u2200(x :\u03b1). x \u2208 Y \u21d2 x \u2209 X) \u21d2 \u2200(x :\u03b1). x \u2208 X \u21d2 \u2203(P' :\u03b1 -> bool). P' \u2208 P \u2227 x \u2209 P'"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_BIGINTER, pred_setTheory.IN_FUNSET, pred_setTheory.DISJOINT_ALT, pred_setTheory.BIJ_FINITE_SUBSET, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EQ_SUBSET_SUBSET, pred_setTheory.SURJ_COMPOSE, pred_setTheory.SPECIFICATION, pred_setTheory.INJ_DEF, pred_setTheory.SCHROEDER_CLOSED]", "reward": 5}]], "(R :\u03b1 -> \u03b2 -> bool) \u2218\u1d63 ($= :\u03b1 -> \u03b1 -> bool) = R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$relation$ O VR C$min$ = VR"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b2 -> bool) \u2218\u1d63 ($= :\u03b1 -> \u03b1 -> bool) = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ @ C$relation$ O VR C$min$ = Vx Vy @ @ VR Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ @ @ C$relation$ O VR C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b2). ((R :\u03b1 -> \u03b2 -> bool) \u2218\u1d63 ($= :\u03b1 -> \u03b1 -> bool)) x y \u21d2 R x y) \u2227 \u2200(x :\u03b1) (y :\u03b2). R x y \u21d2 (R \u2218\u1d63 ($= :\u03b1 -> \u03b1 -> bool)) x y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.RTC_REFL, relationTheory.RSUBSET, relationTheory.SC_DEF, relationTheory.antisymmetric_def, relationTheory.EqIsBothRSUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[relationTheory.transitive_inv_image, relationTheory.O_DEF, relationTheory.O_DEF, relationTheory.RESTRICT_LEMMA, relationTheory.inv_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2282 t \u2227 t \u2286 u \u21d2 s \u2282 u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ PSUBSET Vs Vt @ @ C$pred_set$ SUBSET Vt Vu @ @ C$pred_set$ PSUBSET Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2282 t \u2227 t \u2286 u \u21d2 s \u2282 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vu", "@ C$bool$ ~ @ @ C$bool$ IN Vy Vs", "@ @ C$bool$ IN Vy Vt", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"], "goal": "@ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vu @ C$bool$ ~ @ @ C$bool$ IN Vy Vs"}, "plain": {"assumptions": ["\u2200(x :\u03b1). x \u2208 (t :\u03b1 -> bool) \u21d2 x \u2208 (u :\u03b1 -> bool)", "(y :\u03b1) \u2209 (s :\u03b1 -> bool)", "(y :\u03b1) \u2208 (t :\u03b1 -> bool)", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 x \u2208 (t :\u03b1 -> bool)"], "goal": "\u2203(y :\u03b1). y \u2208 (u :\u03b1 -> bool) \u2227 y \u2209 (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INFINITE_NOT_FINITE, pred_setTheory.SUBSET_DEF, pred_setTheory.COMPONENT, pred_setTheory.PSUBSET_MEMBER, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.PSUBSET_DEF, pred_setTheory.IN_INFINITE_NOT_FINITE, pred_setTheory.SPECIFICATION, pred_setTheory.FINITE_REST, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ APPEND Vl C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l ++ ([] :\u03b1 list) = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u29fa ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ APPEND Vl C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u29fa ([] :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u29fa ([] :\u03b1 list) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ APPEND Vl C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u29fa ([] :\u03b1 list) = l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u29fa ([] :\u03b1 list) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.list_case_compute, listTheory.MAP, listTheory.EL, listTheory.APPEND, boolTheory.TRUTH]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.SELECT_REFL_2, boolTheory.DISJ_EQ_IMP, listTheory.APPEND, boolTheory.RIGHT_FORALL_IMP_THM, listTheory.TL]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 RC R = R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ reflexive VR @ @ C$min$ = @ C$relation$ RC VR VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). reflexive R \u21d2 RC R = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$relation$ reflexive VR"], "goal": "@ @ C$min$ = @ @ @ C$relation$ RC VR Vx Vx' @ @ VR Vx Vx'"}, "plain": {"assumptions": ["(reflexive (R :\u03b1 -> \u03b1 -> bool) :bool)"], "goal": "RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (x' :\u03b1) \u21d4 R x x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.RTC_REFL, boolTheory.FUN_EQ_THM, relationTheory.EQC_DEF, boolTheory.COND_RATOR, relationTheory.RTC_SINGLE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.reflexive_def, boolTheory.SELECT_REFL, relationTheory.RC_DEF, boolTheory.LEFT_AND_FORALL_THM, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2227 t \u2286 s \u21d2 countable t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$pred_set$ countable Vs @ @ C$pred_set$ SUBSET Vt Vs @ C$pred_set$ countable Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). countable s \u2227 t \u2286 s \u21d2 countable t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx Vs", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx C$pred_set$ UNIV"], "goal": "@ C$bool$ ? | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN @ Vf Vx C$pred_set$ UNIV @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vy Vt @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1). x \u2208 (t :\u03b1 -> bool) \u21d2 x \u2208 (s :\u03b1 -> bool)", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u21d2 (f :\u03b1 -> num) x = f y \u21d2 x = y", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> num) x \u2208 \ud835\udd4c(:num)"], "goal": "\u2203(f :\u03b1 -> num). (\u2200(x :\u03b1). x \u2208 (t :\u03b1 -> bool) \u21d2 f x \u2208 \ud835\udd4c(:num)) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 t \u2227 y \u2208 t \u21d2 f x = f y \u21d2 x = y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.LINV_OPT_def, pred_setTheory.countable_def, pred_setTheory.SUBSET_DEF, pred_setTheory.INJ_DEF, pred_setTheory.IN_INTER]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.FUN_EQ_THM, pred_setTheory.REST_SING, pred_setTheory.EMPTY_DEF, boolTheory.IMP_CONJ_THM, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R^= x y \u2227 R^= y z \u21d2 R^= x z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ EQC VR Vx Vy @ @ @ C$relation$ EQC VR Vy Vz @ @ @ C$relation$ EQC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R^= x y \u2227 R^= y z \u21d2 R^= x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ SC VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vz @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ SC VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vy Vz @ @ C$bool$ \\/ @ @ C$min$ = Vx Vz @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ SC VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). (x = y \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x y) \u2227 (y = z \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P y z) \u21d2 x = z \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). SC R x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.RTC_def, relationTheory.TC_DEF, relationTheory.RC_DEF, relationTheory.EQC_DEF, boolTheory.OR_INTRO_THM2]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RTC_ALT_DEF, boolTheory.FORALL_BOOL, boolTheory.bool_case_ID, boolTheory.OR_IMP_THM, boolTheory.JRH_INDUCT_UTIL]", "reward": 5}]], "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 R\u207a (x :\u03b1) (y :\u03b1) \u21d2 x \u2260 y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$relation$ WF VR @ @ C$min$ ==> @ @ @ C$relation$ TC VR Vx Vy @ C$bool$ ~ @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "WF (R :\u03b1 -> \u03b1 -> bool) \u21d2 R\u207a (x :\u03b1) (y :\u03b1) \u21d2 x \u2260 y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ @ C$relation$ TC VR Vx Vy", "@ C$bool$ ! | VB @ @ C$min$ ==> @ C$bool$ ? | Vw @ VB Vw @ C$bool$ ? | Vmin @ @ C$bool$ /\\ @ VB Vmin @ C$bool$ ! | Vb @ @ C$min$ ==> @ @ VR Vb Vmin @ C$bool$ ~ @ VB Vb"], "goal": "@ C$bool$ ~ @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": ["(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (y :\u03b1)", "\u2200(B :\u03b1 -> bool). (\u2203(w :\u03b1). B w) \u21d2 \u2203(min :\u03b1). B min \u2227 \u2200(b :\u03b1). (R :\u03b1 -> \u03b1 -> bool) b min \u21d2 \u00acB b"], "goal": "(x :\u03b1) \u2260 (y :\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.DISJ_EQ_IMP, relationTheory.WF_DEF, boolTheory.COND_RAND, boolTheory.IMP_F_EQ_F, boolTheory.BETA_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.symmetric_TC, relationTheory.TC_CASES2_E, relationTheory.RC_REFLEXIVE, boolTheory.OR_IMP_THM, relationTheory.RC_SUBSET]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). EVERY P (SNOC x l) \u21d4 EVERY P l \u2227 P x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP @ @ C$list$ SNOC Vx Vl @ @ C$bool$ /\\ @ @ C$list$ EVERY VP Vl @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (x :\u03b1) (l :\u03b1 list). EVERY P (SNOC x l) \u21d4 EVERY P l \u2227 P x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx' @ C$list$ LIST_TO_SET @ @ C$list$ SNOC Vx Vl @ VP Vx' @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ VP Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). \u00acMEM x' (SNOC (x :\u03b1) (l :\u03b1 list)) \u2228 (P :\u03b1 -> bool) x') \u21d4 (\u2200(x :\u03b1). \u00acMEM x l \u2228 P x) \u2227 P x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.RIGHT_FORALL_OR_THM, listTheory.EXISTS_MEM, boolTheory.LEFT_FORALL_OR_THM, boolTheory.itself_case_thm, listTheory.EVERY_NOT_EXISTS]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' @ C$list$ LIST_TO_SET Vl @ VP Vx' @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ VP Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2260 (x :\u03b1) \u2227 \u00acMEM x' (l :\u03b1 list) \u2228 (P :\u03b1 -> bool) x') \u21d4 (\u2200(x :\u03b1). \u00acMEM x l \u2228 P x) \u2227 P x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.FILTER_NEQ_ID, listTheory.MAP_EQ_f, listTheory.LIST_TO_SET_SNOC, boolTheory.SELECT_REFL_2, listTheory.ALL_DISTINCT_SET_TO_LIST]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.FILTER_EQ_CONS, listTheory.LENGTH_FRONT_CONS, listTheory.LIST_REL_MAP1, boolTheory.AND2_THM, boolTheory.LEFT_AND_FORALL_THM]", "reward": 5}]], "\u2200(m :num) (n :num). count n m \u21d4 m < n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$pred_set$ count Vn Vm @ @ C$prim_rec$ < Vm Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). count n m \u21d4 m < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.ABSORPTION_RWT, pred_setTheory.count_def, pred_setTheory.GSPEC_ETA, pred_setTheory.transitive_PSUBSET, pred_setTheory.SET_EQ_SUBSET]", "reward": 5}]], "\u2200(Q :num -> bool) (P :num -> bool). (\u2203(n :num). P n) \u2227 (\u2200(n :num). (\u2200(m :num). m < n \u21d2 \u00acP m) \u2227 P n \u21d2 Q n) \u21d2 Q ($LEAST P)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VQ @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ? | Vn @ VP Vn @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ C$bool$ ~ @ VP Vm @ VP Vn @ VQ Vn @ VQ @ C$while$ LEAST VP"}, "plain": {"assumptions": [], "goal": "\u2200(Q :num -> bool) (P :num -> bool). (\u2203(n :num). P n) \u2227 (\u2200(n :num). (\u2200(m :num). m < n \u21d2 \u00acP m) \u2227 P n \u21d2 Q n) \u21d2 Q ($LEAST P)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[arithmeticTheory.LESS_MONO_EQ, prim_recTheory.LESS_DEF, prim_recTheory.LESS_LEMMA2, whileTheory.LESS_LEAST, whileTheory.LEAST_INTRO]", "reward": 5}]], "\u2200(l :\u03b1 list) (x :\u03b1). l \u2260 x::l \u2227 x::l \u2260 l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl @ @ C$list$ CONS Vx Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (x :\u03b1). l \u2260 x::l \u2227 x::l \u2260 l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). ([] :\u03b1 list) \u2260 [x] \u2227 [x] \u2260 ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl @ @ C$list$ CONS Vx Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). (l :\u03b1 list) \u2260 x::l \u2227 x::l \u2260 l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). h::(l :\u03b1 list) \u2260 x::h::l \u2227 x::h::l \u2260 h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl @ @ C$list$ CONS Vx Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). (l :\u03b1 list) \u2260 x::l \u2227 x::l \u2260 l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). h::(l :\u03b1 list) \u2260 x::h::l \u2227 x::h::l \u2260 h::l"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.EL_MAP2, listTheory.LENGTH_EQ_NUM_compute, listTheory.NOT_CONS_NIL, listTheory.list_distinct, listTheory.list_distinct]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.EL_MAP2, listTheory.TL_DEF, listTheory.EXISTS_MAP, listTheory.LENGTH_EQ_SUM, boolTheory.EXISTS_UNIQUE_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH l)) l = HD l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH Vl Vl @ C$list$ HD Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH l)) l = HD l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH C$list$ NIL C$list$ NIL @ C$list$ HD C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH ([] :\u03b1 list))) ([] :\u03b1 list) = HD ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH Vl Vl @ C$list$ HD Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl @ C$list$ HD @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH l)) l = HD l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH (h::l))) (h::l) = HD (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH Vl Vl @ C$list$ HD Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl @ C$list$ HD @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH l)) l = HD l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 ELL (PRE (LENGTH (h::l))) (h::l) = HD (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.LIST_TO_SET_EQ_EMPTY, rich_listTheory.BUTLASTN_SEG, listTheory.LEN_LENGTH_LEM, listTheory.LIST_TO_SET_GENLIST, listTheory.LIST_APPLY_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EL_REVERSE, listTheory.MEM_DROP, listTheory.LIST_REL_MAP_inv_image, rich_listTheory.ELL, rich_listTheory.ELL_LENGTH_CONS]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (ls :\u03b1 list). NULL (FILTER P ls) \u21d4 \u2200(x :\u03b1). MEM x ls \u21d2 \u00acP x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vls @ @ C$min$ = @ C$list$ NULL @ @ C$list$ FILTER VP Vls @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ C$bool$ ~ @ VP Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (ls :\u03b1 list). NULL (FILTER P ls) \u21d4 \u2200(x :\u03b1). MEM x ls \u21d2 \u00acP x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ NULL @ @ C$list$ FILTER VP Vls @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ C$bool$ ~ @ VP Vx"}, "plain": {"assumptions": [], "goal": "NULL (FILTER (P :\u03b1 -> bool) (ls :\u03b1 list)) \u21d4 \u2200(x :\u03b1). MEM x ls \u21d2 \u00acP x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_NIL_SYM, listTheory.TL_DEF, boolTheory.LEFT_AND_OVER_OR, boolTheory.DISJ_EQ_IMP, boolTheory.LET_CONG]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.NULL_EQ, listTheory.FILTER_NEQ_NIL, boolTheory.DISJ_COMM, boolTheory.DISJ_EQ_IMP, boolTheory.DATATYPE_TAG_THM]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE @ C$num$ SUC Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). n < LENGTH ([] :\u03b1 list) \u21d2 SNOC (EL n ([] :\u03b1 list)) (TAKE n ([] :\u03b1 list)) = TAKE (SUC n) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"], "goal": "\u2200(h :\u03b1) (n :num). n < LENGTH (h::(l :\u03b1 list)) \u21d2 SNOC (EL n (h::l)) (TAKE n (h::l)) = TAKE (SUC n) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"], "goal": "\u2200(h :\u03b1) (n :num). n < LENGTH (h::(l :\u03b1 list)) \u21d2 SNOC (EL n (h::l)) (TAKE n (h::l)) = TAKE (SUC n) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[prim_recTheory.LESS_SUC_IMP, prim_recTheory.EQ_LESS, numTheory.INV_SUC, prim_recTheory.LESS_MONO, listTheory.EL_REVERSE]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC C$num$ 0 @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"], "goal": "(0 :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 SNOC (EL (0 :num) (h::l)) (TAKE (0 :num) (h::l)) = TAKE (SUC (0 :num)) (h::l)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 SNOC (EL n (h::l)) (TAKE n (h::l)) = TAKE (SUC n) (h::l)", "\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 SNOC (EL (SUC n) (h::l)) (TAKE (SUC n) (h::l)) = TAKE (SUC (SUC n)) (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL Vn Vl @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE @ C$num$ SUC Vn Vl"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ SNOC @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE @ C$num$ SUC @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 SNOC (EL n (h::l)) (TAKE n (h::l)) = TAKE (SUC n) (h::l)", "\u2200(n :num). n < LENGTH (l :\u03b1 list) \u21d2 SNOC (EL n l) (TAKE n l) = TAKE (SUC n) l"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l :\u03b1 list)) \u21d2 SNOC (EL (SUC n) (h::l)) (TAKE (SUC n) (h::l)) = TAKE (SUC (SUC n)) (h::l)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.NULL_LENGTH, prim_recTheory.num_Axiom_old, listTheory.LIST_IGNORE_BIND_def, listTheory.SUM, listTheory.all_distinct_nub]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.TAKE_LENGTH_ID, listTheory.EVERY_MEM, prim_recTheory.SIMP_REC_REL_UNIQUE_RESULT, listTheory.LENGTH_GENLIST, prim_recTheory.num_Axiom_old]", "reward": 5}]], "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (DROP m l) \u21d2 EXISTS P l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vm @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (DROP m l) \u21d2 EXISTS P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP C$num$ 0 Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (0 :num) l) \u21d2 EXISTS P l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (SUC (m :num)) l) \u21d2 EXISTS P l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `m`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (SUC (m :num)) l) \u21d2 EXISTS P l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.ALL_DISTINCT_FILTER, listTheory.ALL_DISTINCT_FILTER_EL_IMP, listTheory.FILTER_REVERSE, listTheory.NOT_CONS_NIL, listTheory.DROP_TAKE]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm C$list$ NIL @ @ C$list$ EXISTS VP C$list$ NIL"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (m :num) l) \u21d2 EXISTS P l"], "goal": "EXISTS (P :\u03b1 -> bool) (DROP (SUC (m :num)) ([] :\u03b1 list)) \u21d2 EXISTS P ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl", "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["EXISTS (P :\u03b1 -> bool) (DROP (SUC (m :num)) (l :\u03b1 list)) \u21d2 EXISTS P l", "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(h :\u03b1). EXISTS (P :\u03b1 -> bool) (DROP (SUC (m :num)) (h::(l :\u03b1 list))) \u21d2 EXISTS P (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl", "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ DROP @ C$num$ SUC Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["EXISTS (P :\u03b1 -> bool) (DROP (SUC (m :num)) (l :\u03b1 list)) \u21d2 EXISTS P l", "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (DROP (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(h :\u03b1). EXISTS (P :\u03b1 -> bool) (DROP (SUC (m :num)) (h::(l :\u03b1 list))) \u21d2 EXISTS P (h::l)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.MEM_ZIP, listTheory.APPEND_11, listTheory.oEL_def, listTheory.APPEND_eq_NIL, listTheory.UNZIP]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.ZIP_EQ_NIL, listTheory.UNZIP, listTheory.SUM, listTheory.UNZIP, listTheory.OPT_MMAP_def]", "reward": 5}]], "\u2200(M :\u03b1 + \u03b2) (M' :\u03b1 + \u03b2) (f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). M = M' \u2227 (\u2200(x :\u03b1). M' = (INL x :\u03b1 + \u03b2) \u21d2 f x = (f' :\u03b1 -> \u03b3) x) \u2227 (\u2200(y :\u03b2). M' = (INR y :\u03b1 + \u03b2) \u21d2 f1 y = (f1' :\u03b2 -> \u03b3) y) \u21d2 (sum_CASE M f f1 :\u03b3) = (sum_CASE M' f' f1' :\u03b3)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VM' @ C$bool$ ! | Vf @ C$bool$ ! | Vf1 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$min$ = VM' @ C$sum$ INL Vx @ @ C$min$ = @ Vf Vx @ Vf' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = VM' @ C$sum$ INR Vy @ @ C$min$ = @ Vf1 Vy @ Vf1' Vy @ @ C$min$ = @ @ @ C$sum$ sum_CASE VM Vf Vf1 @ @ @ C$sum$ sum_CASE VM' Vf' Vf1'"}, "plain": {"assumptions": [], "goal": "\u2200(M :\u03b1 + \u03b2) (M' :\u03b1 + \u03b2) (f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). M = M' \u2227 (\u2200(x :\u03b1). M' = (INL x :\u03b1 + \u03b2) \u21d2 f x = (f' :\u03b1 -> \u03b3) x) \u2227 (\u2200(y :\u03b2). M' = (INR y :\u03b1 + \u03b2) \u21d2 f1 y = (f1' :\u03b2 -> \u03b3) y) \u21d2 (sum_CASE M f f1 :\u03b3) = (sum_CASE M' f' f1' :\u03b3)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vf @ C$bool$ ! | Vf1 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx @ Vf' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vy @ @ C$min$ = @ Vf1 Vy @ Vf1' Vy @ @ C$min$ = @ @ @ C$sum$ sum_CASE @ C$sum$ INL Vx Vf Vf1 @ @ @ C$sum$ sum_CASE @ C$sum$ INL Vx Vf' Vf1' @ C$bool$ ! | Vy @ C$bool$ ! | Vf @ C$bool$ ! | Vf1 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Vx @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ Vf1 Vy @ Vf1' Vy @ @ C$min$ = @ @ @ C$sum$ sum_CASE @ C$sum$ INR Vy Vf Vf1 @ @ @ C$sum$ sum_CASE @ C$sum$ INR Vy Vf' Vf1' @ C$bool$ ! | Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vf @ C$bool$ ! | Vf1 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Vx @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx @ Vf' Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INL Vx @ C$sum$ INR Vy @ @ C$min$ = @ Vf1 Vy @ Vf1' Vy @ @ C$min$ = @ @ @ C$sum$ sum_CASE @ C$sum$ INL Vx Vf Vf1 @ @ @ C$sum$ sum_CASE @ C$sum$ INL Vx Vf' Vf1' @ C$bool$ ! | Vf @ C$bool$ ! | Vf1 @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$min$ = @ C$sum$ INR Vy @ C$sum$ INL Vx @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ Vf1 Vy @ Vf1' Vy @ @ C$min$ = @ @ @ C$sum$ sum_CASE @ C$sum$ INR Vy Vf Vf1 @ @ @ C$sum$ sum_CASE @ C$sum$ INR Vy Vf' Vf1'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (\u2200(f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). f x = (f' :\u03b1 -> \u03b3) x \u2227 (\u2200(y :\u03b2). (INL x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u21d2 f1 y = (f1' :\u03b2 -> \u03b3) y) \u21d2 (sum_CASE (INL x :\u03b1 + \u03b2) f f1 :\u03b3) = (sum_CASE (INL x :\u03b1 + \u03b2) f' f1' :\u03b3)) \u2227 \u2200(y :\u03b2) (f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). (INL x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u2227 (\u2200(x :\u03b1). (INR y :\u03b1 + \u03b2) = (INL x :\u03b1 + \u03b2) \u21d2 f x = f' x) \u2227 f1 y = f1' y \u21d2 (sum_CASE (INR y :\u03b1 + \u03b2) f f1 :\u03b3) = (sum_CASE (INR y :\u03b1 + \u03b2) f' f1' :\u03b3)) \u2227 \u2200(y :\u03b2). (\u2200(x :\u03b1) (f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). (INR y :\u03b1 + \u03b2) = (INL x :\u03b1 + \u03b2) \u2227 f x = f' x \u2227 (\u2200(y :\u03b2). (INL x :\u03b1 + \u03b2) = (INR y :\u03b1 + \u03b2) \u21d2 f1 y = f1' y) \u21d2 (sum_CASE (INL x :\u03b1 + \u03b2) f f1 :\u03b3) = (sum_CASE (INL x :\u03b1 + \u03b2) f' f1' :\u03b3)) \u2227 \u2200(f :\u03b1 -> \u03b3) (f1 :\u03b2 -> \u03b3). (\u2200(x :\u03b1). (INR y :\u03b1 + \u03b2) = (INL x :\u03b1 + \u03b2) \u21d2 f x = f' x) \u2227 f1 y = f1' y \u21d2 (sum_CASE (INR y :\u03b1 + \u03b2) f f1 :\u03b3) = (sum_CASE (INR y :\u03b1 + \u03b2) f' f1' :\u03b3)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.EQ_IMP_THM, sumTheory.FORALL_SUM, sumTheory.INR_INL_11, sumTheory.INL_11, boolTheory.RIGHT_AND_OVER_OR]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[sumTheory.INR_11, boolTheory.RES_FORALL_DEF, boolTheory.itself_case_thm, sumTheory.sum_case_def, boolTheory.LET_RAND]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u2227 (\u2200(y :\u03b1). y \u2208 s \u21d2 x = y) \u21d4 s = {x}": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vs @ @ C$min$ = Vx Vy @ @ C$min$ = Vs @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u2227 (\u2200(y :\u03b1). y \u2208 s \u21d2 x = y) \u21d4 s = {x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ ==> @ @ C$bool$ IN Vy Vs @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' Vs @ @ C$min$ = Vx' Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(y :\u03b1). (x :\u03b1) \u2208 (s :\u03b1 -> bool) \u2227 (y \u2208 s \u21d2 x = y)) \u21d4 \u2200(x' :\u03b1). x' \u2208 s \u21d4 x' = x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DISJOINT, pred_setTheory.EXTENSION, pred_setTheory.IN_SING, boolTheory.RIGHT_AND_FORALL_THM, boolTheory.COND_RATOR]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.POW_DEF, pred_setTheory.DIFF_COMM, pred_setTheory.MIN_SET_THM, boolTheory.EQ_IMP_THM, pred_setTheory.INFINITE_PAIR_UNIV]", "reward": 5}]], "\u2200(n :num). countable (count n)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$pred_set$ countable @ C$pred_set$ count Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). countable (count n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ? | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$pred_set$ count Vn @ C$bool$ ? | Vn @ @ C$min$ = @ Vf Vn Vx"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). \u2203(f :num -> num). \u2200(x :num). x \u2208 count n \u21d2 \u2203(n :num). f n = x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.SELECT_THM, pred_setTheory.COUNT_MONO, pred_setTheory.COUNTABLE_ALT, pred_setTheory.BIGUNION_SING, boolTheory.COND_RATOR]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.ITSET_EMPTY, pred_setTheory.SUM_SET_SING, pred_setTheory.count_def, pred_setTheory.schroeder_close_def, boolTheory.BOTH_FORALL_OR_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ INSERT Vx Vs @ @ C$pred_set$ INSERT @ Vf Vx @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1) (s :\u03b1 -> bool). IMAGE f (x INSERT s) = f x INSERT IMAGE f s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vx' @ @ C$pair$ , @ Vf Vx' @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' @ Vf Vx @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ Vf Vx @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "{(f :\u03b1 -> \u03b2) x' | x' \u2208 {y | y = (x :\u03b1) \u2228 y \u2208 (s :\u03b1 -> bool)}} (x' :\u03b2) \u21d4 x' = f x \u2228 x' \u2208 {f x | x \u2208 s}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INTER_DEF, pred_setTheory.INSERT_applied, pred_setTheory.IMAGE_DEF, boolTheory.FUN_EQ_THM, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = Vx' @ Vf Vx'' @ @ C$bool$ \\/ @ @ C$min$ = Vx'' Vx @ Vs Vx'' @ @ C$bool$ \\/ @ @ C$min$ = Vx' @ Vf Vx @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx' @ Vf Vx @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(x'' :\u03b1). (x' :\u03b2) = (f :\u03b1 -> \u03b2) x'' \u2227 (x'' = (x :\u03b1) \u2228 (s :\u03b1 -> bool) x'')) \u21d4 x' = f x \u2228 \u2203(x :\u03b1). x' = f x \u2227 s x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPECIFICATION, boolTheory.LET_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPECIFICATION_applied]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.SING_DELETE, pred_setTheory.REST_DEF, pred_setTheory.IMAGE_applied, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "($= :\u03b1 -> \u03b1 -> bool)\u1d40 = ($= :\u03b1 -> \u03b1 -> bool)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ inv C$min$ = C$min$ ="}, "plain": {"assumptions": [], "goal": "($= :\u03b1 -> \u03b1 -> bool)\u1d40 = ($= :\u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.INDUCTIVE_INVARIANT_ON_DEF, relationTheory.RSUBSET, relationTheory.inv_DEF, relationTheory.transitive_inv_image, relationTheory.EqIsBothRSUBSET]", "reward": 5}]], "COMPL (\u2205 :\u03b1 -> bool) = \ud835\udd4c(:\u03b1)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ COMPL C$pred_set$ EMPTY C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "COMPL (\u2205 :\u03b1 -> bool) = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ COMPL | Vx C$bool$ F @ @ C$bool$ IN Vx C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x \u2208 COMPL (\u03bb(x :\u03b1). F) \u21d4 x \u2208 \ud835\udd4c(:\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.IMAGE_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_INSERT, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1) (x :\u03b1)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.IN_COMPL, pred_setTheory.GSPEC_ETA, pred_setTheory.SCHROEDER_CLOSE, pred_setTheory.UNIV_SUBSET]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_applied, pred_setTheory.COUNT_SUC, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.FINITE_BIJ, pred_setTheory.BIGINTER_UNION]", "reward": 5}]], "\u2200(n :num) (f :num -> \u03b1). NULL (GENLIST f n) \u21d4 n = (0 :num)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ NULL @ @ C$list$ GENLIST Vf Vn @ @ C$min$ = Vn C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (f :num -> \u03b1). NULL (GENLIST f n) \u21d4 n = (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_GENLIST, listTheory.EL_LENGTH_SNOC, listTheory.LIST_REL_SPLIT2, boolTheory.DISJ_EQ_IMP, listTheory.NULL_LENGTH]", "reward": 5}]], "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$relation$ TC VR Vx Vz @ @ C$bool$ \\/ @ @ VR Vx Vz @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ @ C$relation$ TC VR Vy Vz"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R x y \u2227 R\u207a y z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_OR_EXISTS_THM, relationTheory.RTC_SINGLE, boolTheory.LEFT_EXISTS_AND_THM, relationTheory.EXTEND_RTC_TC_EQN, relationTheory.RTC_CASES_TC]", "reward": 5}]], "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R\u207a x y \u2227 R y z": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$relation$ TC VR Vx Vz @ @ C$bool$ \\/ @ @ VR Vx Vz @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ @ C$relation$ TC VR Vx Vy @ @ VR Vy Vz"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (z :\u03b1) \u21d4 R x z \u2228 \u2203(y :\u03b1). R\u207a x y \u2227 R y z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ @ C$relation$ RTC VR Vy Vz @ @ C$bool$ \\/ @ @ VR Vx Vz @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ C$bool$ ? | Vy' @ @ C$bool$ /\\ @ @ VR Vx Vy' @ @ @ C$relation$ RTC VR Vy' Vy @ @ VR Vy Vz"}, "plain": {"assumptions": [], "goal": "(\u2203(y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) y \u2227 R\ua673 y (z :\u03b1)) \u21d4 R x z \u2228 \u2203(y :\u03b1). (\u2203(y' :\u03b1). R x y' \u2227 R\ua673 y' y) \u2227 R y z"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.EXTEND_RTC_TC_EQN, boolTheory.LEFT_AND_FORALL_THM, boolTheory.LEFT_EXISTS_AND_THM, relationTheory.RTC_RULES_RIGHT1, boolTheory.LET_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RTC_CASES2, relationTheory.symmetric_def, boolTheory.SELECT_ELIM_THM, relationTheory.reflexive_TC, relationTheory.TC_TRANSITIVE]", "reward": 5}]], "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (s3 :\u03b1 -> bool). s1 \u2286 s2 DIFF s3 \u21d4 s1 \u2286 s2 \u2227 DISJOINT s1 s3": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ C$bool$ ! | Vs3 @ @ C$min$ = @ @ C$pred_set$ SUBSET Vs1 @ @ C$pred_set$ DIFF Vs2 Vs3 @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs1 Vs2 @ @ C$pred_set$ DISJOINT Vs1 Vs3"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool) (s3 :\u03b1 -> bool). s1 \u2286 s2 DIFF s3 \u21d4 s1 \u2286 s2 \u2227 DISJOINT s1 s3"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ IN Vx @ @ C$pred_set$ DIFF Vs2 Vs3 @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ IN Vx Vs2 @ @ C$pred_set$ DISJOINT Vs1 Vs3"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s1 :\u03b1 -> bool) \u21d2 x \u2208 (s2 :\u03b1 -> bool) DIFF (s3 :\u03b1 -> bool)) \u21d4 (\u2200(x :\u03b1). x \u2208 s1 \u21d2 x \u2208 s2) \u2227 DISJOINT s1 s3"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INSERT_SING_UNION, pred_setTheory.PSUBSET_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.IMAGE_applied, pred_setTheory.SUBSET_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs2 @ C$bool$ ~ @ @ C$bool$ IN Vx Vs3 @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ IN Vx Vs2 @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx Vs1 @ C$bool$ ~ @ @ C$bool$ IN Vx Vs3"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s1 :\u03b1 -> bool) \u21d2 x \u2208 (s2 :\u03b1 -> bool) \u2227 x \u2209 (s3 :\u03b1 -> bool)) \u21d4 (\u2200(x :\u03b1). x \u2208 s1 \u21d2 x \u2208 s2) \u2227 \u2200(x :\u03b1). x \u2209 s1 \u2228 x \u2209 s3"}}], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_DISJOINT, pred_setTheory.IN_DIFF, pred_setTheory.GSPEC_ETA, pred_setTheory.FUNSET_applied, pred_setTheory.CARD_INSERT]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.COMPONENT, pred_setTheory.IN_IMAGE, pred_setTheory.IN_APP, pred_setTheory.IN_APP, boolTheory.LET_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool). s \u2286 PREIMAGE f (IMAGE f s)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$pred_set$ SUBSET Vs @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ IMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool). s \u2286 PREIMAGE f (IMAGE f s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$pred_set$ SUBSET Vs | Vx @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , @ Vf Vx @ Vs Vx @ Vf Vx"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2286 (\u03bb(x :\u03b1). {(f :\u03b1 -> \u03b2) x | s x} (f x))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.EQUAL_SING, pred_setTheory.GSPEC_ETA, pred_setTheory.IMAGE_DEF, pred_setTheory.PREIMAGE_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx @ Vf Vx' @ Vs Vx'"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 \u2203(x' :\u03b1). (f :\u03b1 -> \u03b2) x = f x' \u2227 s x'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.BIGUNION_applied, pred_setTheory.UNION_applied, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_EXPAND, pred_setTheory.COUNTABLE_NUM, boolTheory.EQ_SYM_EQ, pred_setTheory.SUBSET_FINITE_I, boolTheory.EXISTS_UNIQUE_REFL]", "reward": 5}]], "(\u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT (BIGUNION s) t \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT s' t) \u2227 \u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT t (BIGUNION s) \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT t s'": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT @ C$pred_set$ BIGUNION Vs Vt @ C$bool$ ! | Vs' @ @ C$min$ ==> @ @ C$bool$ IN Vs' Vs @ @ C$pred_set$ DISJOINT Vs' Vt @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vt @ C$pred_set$ BIGUNION Vs @ C$bool$ ! | Vs' @ @ C$min$ ==> @ @ C$bool$ IN Vs' Vs @ @ C$pred_set$ DISJOINT Vt Vs'"}, "plain": {"assumptions": [], "goal": "(\u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT (BIGUNION s) t \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT s' t) \u2227 \u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). DISJOINT t (BIGUNION s) \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 DISJOINT t s'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vs' @ @ C$min$ ==> @ @ C$bool$ IN Vs' Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs' @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$pred_set$ BIGUNION Vs @ C$bool$ ! | Vs' @ @ C$min$ ==> @ @ C$bool$ IN Vs' Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vs'"}, "plain": {"assumptions": [], "goal": "(\u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 BIGUNION s \u21d2 x \u2209 t) \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 \u2200(x :\u03b1). x \u2208 s' \u21d2 x \u2209 t) \u2227 \u2200(s :(\u03b1 -> bool) -> bool) (t :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 t \u21d2 x \u2209 BIGUNION s) \u21d4 \u2200(s' :\u03b1 -> bool). s' \u2208 s \u21d2 \u2200(x :\u03b1). x \u2208 t \u21d2 x \u2209 s'"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.CARD_EQ_0, pred_setTheory.BIJ_DELETE, pred_setTheory.DISJOINT_ALT, boolTheory.DISJ_EQ_IMP, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_DEF, pred_setTheory.HAS_SIZE_SUC, pred_setTheory.IN_BIGUNION, pred_setTheory.INJ_DEF, pred_setTheory.BIJ_INSERT_IMP]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 INJ f (s DELETE e) (t DELETE f e)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve Vs @ @ @ C$pred_set$ INJ Vf @ @ C$pred_set$ DELETE Vs Ve @ @ C$pred_set$ DELETE Vt @ Vf Ve"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). INJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 INJ f (s DELETE e) (t DELETE f e)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_IFF, pred_setTheory.IN_DELETE, boolTheory.EXISTS_UNIQUE_THM, pred_setTheory.DIFF_DEF, pred_setTheory.NOT_EMPTY_SING]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). f \u2208 FUNSET s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). f \u2208 FUNSET s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET Vs C$pred_set$ EMPTY @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "(f :\u03b1 -> \u03b2) \u2208 (((s :\u03b1 -> bool) \u2192 (\u2205 :\u03b2 -> bool)) :(\u03b1 -> \u03b2) -> bool) \u21d4 \u2200(x :\u03b1). s x \u21d4 \u2205 x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.PSUBSET_DEF, boolTheory.FUN_EQ_THM, pred_setTheory.DELETE_SUBSET, pred_setTheory.CHOICE_INSERT_REST, pred_setTheory.INSERT_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.FUNSET_applied, pred_setTheory.EMPTY_DEF, pred_setTheory.IMAGE_DEF, pred_setTheory.FUNSET_applied]", "reward": 5}]], "\u2200(l :\u03b1 list) (x :\u03b1). BUTLASTN (LENGTH l) (x::l) = [x]": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$rich_list$ BUTLASTN @ C$list$ LENGTH Vl @ @ C$list$ CONS Vx Vl @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (x :\u03b1). BUTLASTN (LENGTH l) (x::l) = [x]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$rich_list$ BUTLASTN @ C$list$ LENGTH Vl Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "BUTLASTN (LENGTH (l :\u03b1 list)) l = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.IS_SUFFIX_IS_SUBLIST, listTheory.DROP_TAKE, rich_listTheory.BUTLASTN_CONS, listTheory.LENGTH_LT_SHORTLEX, listTheory.every_zip_fst]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN_def, listTheory.SUM_ACC_DEF, rich_listTheory.COUNT_LIST_AUX_def, listTheory.LLEX_EL_THM, listTheory.list_TY_DEF]", "reward": 5}]], "\u2200(n :num) (l2 :\u03b1 list). n \u2264 LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). LASTN n (l1 ++ l2) = LASTN n l2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl2 @ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$rich_list$ LASTN Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ LASTN Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l2 :\u03b1 list). n \u2264 LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). LASTN n (l1 ++ l2) = LASTN n l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl2"], "goal": "@ @ C$min$ = @ @ C$rich_list$ LASTN Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ LASTN Vn Vl2"}, "plain": {"assumptions": ["(n :num) \u2264 LENGTH (l2 :\u03b1 list)"], "goal": "LASTN (n :num) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = LASTN n l2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY2_LUPDATE_same, arithmeticTheory.EXP_BASE_LT_MONO, arithmeticTheory.FUNPOW_ADD, listTheory.LIST_REL_SPLIT2, listTheory.LENGTH_TAKE_EQ]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.TL_T_def, listTheory.TAKE_APPEND1, listTheory.MEM_REVERSE, listTheory.GENLIST_ID, rich_listTheory.LASTN_def]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SEG (1 :num) n l = [EL n l]": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ @ C$rich_list$ SEG @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 SEG (1 :num) n l = [EL n l]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl"], "goal": "@ @ C$min$ = @ @ @ C$rich_list$ SEG @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vn Vl @ @ C$list$ CONS @ @ C$list$ EL Vn Vl C$list$ NIL"}, "plain": {"assumptions": ["(n :num) < LENGTH (l :\u03b1 list)"], "goal": "SEG (1 :num) (n :num) (l :\u03b1 list) = [EL n l]"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN, rich_listTheory.NOT_NIL_SNOC, listTheory.nub_def, arithmeticTheory.SUB_LEFT_GREATER, arithmeticTheory.MOD_LESS]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.SCANL, rich_listTheory.SEG_TAKE_DROP, listTheory.splitAtPki_MAP, listTheory.TAKE1_DROP, listTheory.isPREFIX_NILR]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (x :\u03b1) (l2 :\u03b1 list). l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vx @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ SNOC Vx Vl2 @ @ C$list$ SNOC Vx @ @ C$list$ APPEND Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (x :\u03b1) (l2 :\u03b1 list). l1 ++ SNOC x l2 = SNOC x (l1 ++ l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SNOC_APPEND, listTheory.FRONT_DEF, listTheory.LENGTH_TAKE, listTheory.TAKE_0, listTheory.APPEND_ASSOC]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 x INSERT s DELETE x = s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ DELETE Vs Vx Vs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool). x \u2208 s \u21d2 x INSERT s DELETE x = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx Vs"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ DELETE Vs Vx @ @ C$bool$ IN Vx' Vs"}, "plain": {"assumptions": ["(x :\u03b1) \u2208 (s :\u03b1 -> bool)"], "goal": "(x' :\u03b1) \u2208 (x :\u03b1) INSERT (s :\u03b1 -> bool) DELETE x \u21d4 x' \u2208 s"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LCOMM_THM, boolTheory.FALSITY, boolTheory.ONE_ONE_THM, pred_setTheory.EXTENSION, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_INSERT, pred_setTheory.INSERT_applied, pred_setTheory.IN_INSERT, pred_setTheory.DIFF_applied, pred_setTheory.IN_DELETE]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2282 u \u21d2 s \u2282 u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ PSUBSET Vt Vu @ @ C$pred_set$ PSUBSET Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (u :\u03b1 -> bool). s \u2286 t \u2227 t \u2282 u \u21d2 s \u2282 u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ Vt Vy", "@ Vu Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ Vu Vx", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt Vx"], "goal": "@ C$bool$ ? | Vy @ @ C$bool$ /\\ @ Vu Vy @ C$bool$ ~ @ Vs Vy"}, "plain": {"assumptions": ["\u00ac(t :\u03b1 -> bool) (y :\u03b1)", "(u :\u03b1 -> bool) (y :\u03b1)", "\u2200(x :\u03b1). (t :\u03b1 -> bool) x \u21d2 (u :\u03b1 -> bool) x", "\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b1 -> bool) x"], "goal": "\u2203(y :\u03b1). (u :\u03b1 -> bool) y \u2227 \u00ac(s :\u03b1 -> bool) y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUM_IMAGE_SUBSET_LE, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_APP, pred_setTheory.DIFF_SAME_UNION, pred_setTheory.PSUBSET_MEMBER]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.INTER_EMPTY, pred_setTheory.BIJ_FINITE, pred_setTheory.SUBSET_BIGUNION_I, pred_setTheory.DIFF_INTER_COMPL]", "reward": 5}]], "((\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b2 -> bool) \u21d4 R = (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)) \u2227 R \u2286\u1d63 (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$relation$ RSUBSET C$relation$ RUNIV VR @ @ C$min$ = VR C$relation$ RUNIV @ @ C$relation$ RSUBSET VR C$relation$ RUNIV"}, "plain": {"assumptions": [], "goal": "((\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b2 -> bool) \u21d4 R = (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)) \u2227 R \u2286\u1d63 (\ud835\udd4c\u1d63 :\u03b1 -> \u03b2 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$relation$ RUNIV Vx Vy @ @ VR Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ @ VR Vx Vx' @ @ C$relation$ RUNIV Vx Vx' @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$relation$ RUNIV Vx Vy"}, "plain": {"assumptions": [], "goal": "((\u2200(x :\u03b1) (y :\u03b2). \ud835\udd4c\u1d63 x y \u21d2 (R :\u03b1 -> \u03b2 -> bool) x y) \u21d4 \u2200(x :\u03b1) (x' :\u03b2). R x x' \u21d4 \ud835\udd4c\u1d63 x x') \u2227 \u2200(x :\u03b1) (y :\u03b2). R x y \u21d2 \ud835\udd4c\u1d63 x y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, relationTheory.RC_DEF, relationTheory.trichotomous, relationTheory.RSUBSET, relationTheory.WF_RECURSION_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.DATATYPE_TAG_DEF, relationTheory.RUNIV, boolTheory.NOT_IMP, relationTheory.approx_def, boolTheory.literal_case_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u2229 t) \u2286 IMAGE f s \u2229 IMAGE f t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ INTER Vs Vt @ @ C$pred_set$ INTER @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b1 -> bool). IMAGE f (s \u2229 t) \u2286 IMAGE f s \u2229 IMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf @ @ C$pred_set$ INTER Vs Vt"], "goal": "@ @ C$bool$ IN Vx @ @ C$pred_set$ INTER @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE Vf Vt"}, "plain": {"assumptions": ["(x :\u03b2) \u2208 IMAGE (f :\u03b1 -> \u03b2) ((s :\u03b1 -> bool) \u2229 (t :\u03b1 -> bool))"], "goal": "(x :\u03b2) \u2208 IMAGE (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) \u2229 IMAGE f (t :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_SUBSET, pred_setTheory.SUBSET_DEF, pred_setTheory.PAIR_IN_GSPEC_same, pred_setTheory.DIFF_DEF, pred_setTheory.INTER_applied]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx' Vt", "@ @ C$bool$ IN Vx' Vs", "@ @ C$min$ = Vx @ Vf Vx'"], "goal": "@ @ C$bool$ /\\ @ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx' @ Vf Vx'' @ @ C$bool$ IN Vx'' Vs @ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = @ Vf Vx' @ Vf Vx'' @ @ C$bool$ IN Vx'' Vt"}, "plain": {"assumptions": ["(x' :\u03b1) \u2208 (t :\u03b1 -> bool)", "(x' :\u03b1) \u2208 (s :\u03b1 -> bool)", "(x :\u03b2) = (f :\u03b1 -> \u03b2) (x' :\u03b1)"], "goal": "(\u2203(x'' :\u03b1). (f :\u03b1 -> \u03b2) (x' :\u03b1) = f x'' \u2227 x'' \u2208 (s :\u03b1 -> bool)) \u2227 \u2203(x'' :\u03b1). f x' = f x'' \u2227 x'' \u2208 (t :\u03b1 -> bool)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IMAGE_DEF, pred_setTheory.IN_IMAGE, pred_setTheory.IN_INTER, pred_setTheory.IMAGE_DEF, pred_setTheory.DIFF_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.INTER_UNIV, pred_setTheory.IN_INSERT, pred_setTheory.NOT_IN_EMPTY, boolTheory.EQ_EXT]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). WF R \u21d4 \u2200(x :\u03b1). WFP R x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ WF VR @ C$bool$ ! | Vx @ @ C$relation$ WFP VR Vx"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). WF R \u21d4 \u2200(x :\u03b1). WFP R x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$relation$ WFP VR Vx @ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vy Vx @ VP Vy @ VP Vx @ C$bool$ ! | Vx @ VP Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). WFP (R :\u03b1 -> \u03b1 -> bool) x) \u21d4 \u2200(P :\u03b1 -> bool). (\u2200(x :\u03b1). (\u2200(y :\u03b1). R y x \u21d2 P y) \u21d2 P x) \u21d2 \u2200(x :\u03b1). P x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, relationTheory.WF_EQ_INDUCTION_THM, relationTheory.inv_image_def, relationTheory.RTC_EQC, relationTheory.TC_SUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.IN_DEF, relationTheory.WFP_DEF, relationTheory.WFP_DEF, relationTheory.WF_SUBSET, relationTheory.symmetric_TC]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u21d2 (s DELETE x = (\u2205 :\u03b1 -> bool) \u21d4 s = {x})": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ @ C$min$ = @ @ C$pred_set$ DELETE Vs Vx C$pred_set$ EMPTY @ @ C$min$ = Vs @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (x :\u03b1). x \u2208 s \u21d2 (s DELETE x = (\u2205 :\u03b1 -> bool) \u21d4 s = {x})"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx Vs"], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ = @ @ @ C$pred_set$ DELETE Vs Vx Vx' @ C$pred_set$ EMPTY Vx' @ C$bool$ ! | Vx' @ @ C$min$ = @ Vs Vx' @ @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY Vx'"}, "plain": {"assumptions": ["(x :\u03b1) \u2208 (s :\u03b1 -> bool)"], "goal": "(\u2200(x' :\u03b1). ((s :\u03b1 -> bool) DELETE (x :\u03b1)) x' \u21d4 \u2205 x') \u21d4 \u2200(x' :\u03b1). s x' \u21d4 {x} x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DELETE, pred_setTheory.IN_DISJOINT, pred_setTheory.SUBSET_UNIV, boolTheory.FUN_EQ_THM, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ Vs Vx"], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ /\\ @ Vs Vx' @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ C$pred_set$ EMPTY Vx' @ C$bool$ ! | Vx' @ @ C$min$ = @ Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ C$pred_set$ EMPTY Vx'"}, "plain": {"assumptions": ["(s :\u03b1 -> bool) (x :\u03b1)"], "goal": "(\u2200(x' :\u03b1). (s :\u03b1 -> bool) x' \u2227 x' \u2260 (x :\u03b1) \u21d4 \u2205 x') \u21d4 \u2200(x' :\u03b1). s x' \u21d4 x' = x \u2228 \u2205 x'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.DELETE_applied, pred_setTheory.INSERT_applied, pred_setTheory.EXTENSION, pred_setTheory.INTER_applied]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EMPTY_applied, pred_setTheory.SING_DELETE, pred_setTheory.EMPTY_UNION, pred_setTheory.EXTENSION, pred_setTheory.K_SUBSET]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u207a": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$relation$ transitive @ C$relation$ TC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). transitive R\u207a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ TC VR Vx Vy @ @ @ C$relation$ TC VR Vy Vz @ @ @ C$relation$ TC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R\u207a x y \u2227 R\u207a y z \u21d2 R\u207a x z"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.BOTH_EXISTS_AND_THM, relationTheory.transitive_def, boolTheory.LEFT_EXISTS_AND_THM, relationTheory.total_def, boolTheory.literal_case_RAND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | VP @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ~ @ @ VP Vy Vz @ @ VP Vx Vz @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ? | VP @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ~ @ @ VP Vy Vz @ @ VP Vx Vz @ C$bool$ ~ @ @ VP Vy Vz @ C$bool$ ! | VP @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ VR Vx Vy @ C$bool$ ~ @ @ VP Vx Vy @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ C$bool$ ? | Vz @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ C$bool$ ~ @ @ VP Vx Vz @ @ VP Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). ((\u2203(P :\u03b1 -> \u03b1 -> bool). ((\u2200(x :\u03b1) (y :\u03b1). \u00acR x y \u2228 P x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (\u00acP x y \u2228 \u00acP y z) \u2228 P x z) \u2227 \u00acP x y) \u2228 \u2203(P :\u03b1 -> \u03b1 -> bool). ((\u2200(x :\u03b1) (y :\u03b1). \u00acR x y \u2228 P x y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (\u00acP x y \u2228 \u00acP y z) \u2228 P x z) \u2227 \u00acP y z) \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). ((\u2203(x :\u03b1) (y :\u03b1). R x y \u2227 \u00acP x y) \u2228 \u2203(x :\u03b1) (y :\u03b1) (z :\u03b1). (P x y \u2227 P y z) \u2227 \u00acP x z) \u2228 P x z"}}], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.FUN_EQ_THM, boolTheory.AND1_THM, boolTheory.IMP_DISJ_THM, relationTheory.TC_DEF, boolTheory.ONE_ONE_THM]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.IMP_CONG, boolTheory.NOT_CLAUSES, boolTheory.IMP_CONG, boolTheory.OR_CLAUSES, relationTheory.TC_DEF]", "reward": 5}]], "\u2200(n :num) (m :num) (l :\u03b1 list). DROP n (DROP m l) = DROP (n + m) l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num) (l :\u03b1 list). DROP n (DROP m l) = DROP (n + m) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm C$list$ NIL @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num). DROP n (DROP m ([] :\u03b1 list)) = DROP (n + m) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num) (m :num). DROP n (DROP m (l :\u03b1 list)) = DROP (n + m) l"], "goal": "\u2200(h :\u03b1) (n :num) (m :num). DROP n (DROP m (h::(l :\u03b1 list))) = DROP (n + m) (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num) (m :num). DROP n (DROP m (l :\u03b1 list)) = DROP (n + m) l"], "goal": "\u2200(h :\u03b1) (n :num) (m :num). DROP n (DROP m (h::(l :\u03b1 list))) = DROP (n + m) (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.APPEND_eq_NIL, arithmeticTheory.MIN_MAX_LE, listTheory.LLEX_THM, arithmeticTheory.SUB_LEFT_LESS_EQ, listTheory.UNZIP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$bool$ /\\ @ @ C$min$ = Vn C$num$ 0 C$bool$ T", "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ DROP Vm Vl @ @ C$list$ DROP @ @ C$arithmetic$ + Vn Vm Vl"], "goal": "@ @ C$min$ = @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl"}, "plain": {"assumptions": ["\u00ac((n :num) = (0 :num) \u2227 T)", "\u2200(n :num) (m :num). DROP n (DROP m (l :\u03b1 list)) = DROP (n + m) l"], "goal": "(if (n :num) = (0 :num) then (h :\u03b1)::(l :\u03b1 list) else DROP (n \u2212 (1 :num)) l) = DROP (n \u2212 (1 :num)) l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EVERY_NOT_EXISTS, listTheory.EL_DROP, listTheory.isPREFIX_THM, arithmeticTheory.LT_MULT_CANCEL_RBARE, listTheory.DROP_def]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_SNOC, arithmeticTheory.GREATER_DEF, listTheory.MAP2_NIL, arithmeticTheory.num_case_cong, arithmeticTheory.MAX_DEF]", "reward": 5}]], "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). X \u2286 BIGINTER P \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 X \u2286 Y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VX @ C$bool$ ! | VP @ @ C$min$ = @ @ C$pred_set$ SUBSET VX @ C$pred_set$ BIGINTER VP @ C$bool$ ! | VY @ @ C$min$ ==> @ @ C$bool$ IN VY VP @ @ C$pred_set$ SUBSET VX VY"}, "plain": {"assumptions": [], "goal": "\u2200(X :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). X \u2286 BIGINTER P \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2208 P \u21d2 X \u2286 Y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx VX @ @ C$bool$ IN Vx @ C$pred_set$ BIGINTER VP @ C$bool$ ! | VY @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN VY VP @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vx VX @ @ C$bool$ IN Vx VY"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2209 (X :\u03b1 -> bool) \u2228 x \u2208 BIGINTER (P :(\u03b1 -> bool) -> bool)) \u21d4 \u2200(Y :\u03b1 -> bool). Y \u2209 P \u2228 \u2200(x :\u03b1). x \u2209 X \u2228 x \u2208 Y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.COUNT_applied, boolTheory.IMP_DISJ_THM, pred_setTheory.SUBSET_DEF, boolTheory.AND1_THM, pred_setTheory.DFUNSET_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_applied, pred_setTheory.REST_SING, pred_setTheory.FUNSET_EMPTY, pred_setTheory.IN_BIGINTER, pred_setTheory.IN_ABS]", "reward": 5}]], "REVERSE (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 l = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ REVERSE Vl C$list$ NIL @ @ C$min$ = Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "REVERSE (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.MAP_TL, listTheory.LENGTH_REVERSE, listTheory.EVERY_CONJ, listTheory.EXISTS_APPEND, listTheory.LENGTH_NIL_SYM]", "reward": 5}]], "(x :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 (0 :num) < LENGTH x": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vx C$list$ NIL @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vx"}, "plain": {"assumptions": [], "goal": "(x :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 (0 :num) < LENGTH x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH C$list$ NIL @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vx' @ C$list$ LENGTH C$list$ NIL @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ EL Vx' Vx @ @ C$list$ EL Vx' C$list$ NIL @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vx"}, "plain": {"assumptions": [], "goal": "LENGTH (x :\u03b1 list) = LENGTH ([] :\u03b1 list) \u21d2 (\u2203(x' :num). x' < LENGTH ([] :\u03b1 list) \u2227 EL x' x \u2260 EL x' ([] :\u03b1 list)) \u21d4 (0 :num) < LENGTH x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SET_TO_LIST_IN_MEM, listTheory.REVERSE_REV, listTheory.DROP_GENLIST, listTheory.LIST_EQ_REWRITE, listTheory.LEN_LENGTH_LEM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LENGTH, rich_listTheory.ALL_DISTINCT_DROP, listTheory.EXISTS_DEF, listTheory.EVERY2_EVERY, listTheory.SET_TO_LIST_CARD]", "reward": 5}]], "\u2200(P :\u03b1 -> bool). INFINITE P \u21d2 \u2203(x :\u03b1). x \u2208 P": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ ==> @ C$bool$ ~ @ C$pred_set$ FINITE VP @ C$bool$ ? | Vx @ @ C$bool$ IN Vx VP"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool). INFINITE P \u21d2 \u2203(x :\u03b1). x \u2208 P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ C$pred_set$ FINITE VP"], "goal": "@ C$bool$ ? | Vx @ @ C$bool$ IN Vx VP"}, "plain": {"assumptions": ["INFINITE (P :\u03b1 -> bool)"], "goal": "\u2203(x :\u03b1). x \u2208 (P :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_ALT, pred_setTheory.COUNT_SUC, pred_setTheory.SUBSET_OF_INSERT, pred_setTheory.IN_IMAGE, pred_setTheory.DELETE_EQ_SING]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.CHOICE_DEF, pred_setTheory.FINITE_INSERT, pred_setTheory.INTER_COMM, pred_setTheory.FINITE_EMPTY, pred_setTheory.UNION_OVER_INTER]", "reward": 5}]], "\u2200(P :\u03b1 + \u03b2 -> bool). (\u2203(s :\u03b1 + \u03b2). P s) \u21d4 (\u2203(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). P (INR y :\u03b1 + \u03b2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ C$bool$ ? | Vs @ VP Vs @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ VP @ C$sum$ INL Vx @ C$bool$ ? | Vy @ VP @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 + \u03b2 -> bool). (\u2203(s :\u03b1 + \u03b2). P s) \u21d4 (\u2203(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). P (INR y :\u03b1 + \u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ? | Vs @ VP Vs @ @ C$bool$ \\/ @ C$bool$ ? | Vx @ VP @ C$sum$ INL Vx @ C$bool$ ? | Vy @ VP @ C$sum$ INR Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ VP @ C$sum$ INL Vx @ C$bool$ ! | Vy @ C$bool$ ~ @ VP @ C$sum$ INR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 + \u03b2 -> bool). (\u2203(s :\u03b1 + \u03b2). P s) \u2227 ((\u2203(x :\u03b1). P (INL x :\u03b1 + \u03b2)) \u2228 \u2203(y :\u03b2). P (INR y :\u03b1 + \u03b2)) \u2228 (\u2200(x :\u03b1). \u00acP (INL x :\u03b1 + \u03b2)) \u2227 \u2200(y :\u03b2). \u00acP (INR y :\u03b1 + \u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.EQ_SYM_EQ, sumTheory.FORALL_SUM, boolTheory.LET_CONG, boolTheory.ABS_REP_THM, boolTheory.EQ_EXPAND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_IMP, boolTheory.COND_ABS, sumTheory.sum_INDUCT, boolTheory.LET_CONG, boolTheory.literal_case_CONG]", "reward": 5}]], "GENLIST (f :num -> \u03b1) (0 :num) = ([] :\u03b1 list) \u2227 GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ GENLIST Vf C$num$ 0 C$list$ NIL @ @ C$min$ = @ @ C$list$ GENLIST Vf @ C$arithmetic$ NUMERAL Vn @ @ @ C$list$ GENLIST_AUX Vf @ C$arithmetic$ NUMERAL Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "GENLIST (f :num -> \u03b1) (0 :num) = ([] :\u03b1 list) \u2227 GENLIST f (NUMERAL (n :num)) = GENLIST_AUX f (NUMERAL n) ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.GENLIST, arithmeticTheory.NRC_RTC, listTheory.MAP, listTheory.GENLIST_GENLIST_AUX, listTheory.NULL_EQ]", "reward": 5}]], "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 LENGTH x = LENGTH y \u21d4 x = y": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list) (y :\u03b1 list). x \u227c y \u2227 LENGTH x = LENGTH y \u21d4 x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 list). x \u227c ([] :\u03b1 list) \u2227 LENGTH x = LENGTH ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u2227 LENGTH x = LENGTH (h::y) \u21d4 x = h::y"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `y`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "\u2200(h :\u03b1) (x :\u03b1 list). x \u227c h::(y :\u03b1 list) \u2227 LENGTH x = LENGTH (h::y) \u21d4 x = h::y"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SUM_ACC_DEF, listTheory.FRONT_DEF, listTheory.nub_def, listTheory.SET_TO_LIST_SING, listTheory.EVERY2_REVERSE]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH C$list$ NIL @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "([] :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH ([] :\u03b1 list) = LENGTH (h::y) \u21d4 ([] :\u03b1 list) = h::y"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH x = LENGTH (h::y) \u21d4 x = h::y", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH (h'::x) = LENGTH (h::y) \u21d4 h'::x = h::y"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vx @ C$list$ LENGTH @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ @ C$list$ CONS Vh' Vx @ @ C$list$ CONS Vh Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH x = LENGTH (h::y) \u21d4 x = h::y", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "\u2200(h' :\u03b1). h'::(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH (h'::x) = LENGTH (h::y) \u21d4 h'::x = h::y"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.LIST_REL_EVERY_ZIP, listTheory.adjacent_EL, listTheory.HD_GENLIST, listTheory.SUM_ACC_DEF]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vh Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$num$ SUC @ C$list$ LENGTH Vy @ @ C$min$ = Vx @ @ C$list$ CONS Vh Vy", "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$min$ = Vx Vy"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$min$ = Vh' Vh @ @ C$list$ isPREFIX Vx Vy @ @ C$min$ = @ C$list$ LENGTH Vx @ C$list$ LENGTH Vy @ @ C$bool$ /\\ @ @ C$min$ = Vh' Vh @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (h :\u03b1)::(y :\u03b1 list) \u2227 LENGTH x = SUC (LENGTH y) \u21d4 x = h::y", "\u2200(x :\u03b1 list). x \u227c (y :\u03b1 list) \u2227 LENGTH x = LENGTH y \u21d4 x = y"], "goal": "((h' :\u03b1) = (h :\u03b1) \u2227 (x :\u03b1 list) \u227c (y :\u03b1 list)) \u2227 LENGTH x = LENGTH y \u21d4 h' = h \u2227 x = y"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.SUM_ACC_SUM_LEM, listTheory.FILTER_EQ_CONS, listTheory.SINGL_LIST_APPLY_R, listTheory.TAKE_def, listTheory.SINGL_APPLY_MAP]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.EL_LENGTH_dropWhile_REVERSE, listTheory.LENGTH_FRONT_CONS, listTheory.APPEND_eq_NIL, listTheory.SWAP_REVERSE_SYM, listTheory.MEM]", "reward": 5}]], "($= :\u03b2 -> \u03b2 -> bool) \u2218\u1d63 (R :\u03b1 -> \u03b2 -> bool) = R": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$relation$ O C$min$ = VR VR"}, "plain": {"assumptions": [], "goal": "($= :\u03b2 -> \u03b2 -> bool) \u2218\u1d63 (R :\u03b1 -> \u03b2 -> bool) = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.INDUCTIVE_INVARIANT_ON_DEF, relationTheory.EqIsBothRSUBSET, relationTheory.inv_DEF, relationTheory.RSUBSET, relationTheory.O_DEF]", "reward": 5}]], "(\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b1 -> bool) \u2227 (R \u2286\u1d63 (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u21d4 R = (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool))": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET C$relation$ EMPTY_REL VR @ @ C$min$ = @ @ C$relation$ RSUBSET VR C$relation$ EMPTY_REL @ @ C$min$ = VR C$relation$ EMPTY_REL"}, "plain": {"assumptions": [], "goal": "(\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u2286\u1d63 (R :\u03b1 -> \u03b1 -> bool) \u2227 (R \u2286\u1d63 (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool) \u21d4 R = (\u2205\u1d63 :\u03b1 -> \u03b1 -> bool))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$relation$ EMPTY_REL Vx Vy @ @ VR Vx Vy @ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$relation$ EMPTY_REL Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ @ VR Vx Vx' @ @ C$relation$ EMPTY_REL Vx Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). \u2205\u1d63 x y \u21d2 (R :\u03b1 -> \u03b1 -> bool) x y) \u2227 ((\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 \u2205\u1d63 x y) \u21d4 \u2200(x :\u03b1) (x' :\u03b1). R x x' \u21d4 \u2205\u1d63 x x')"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.FORALL_THM, relationTheory.INVOL, boolTheory.FUN_EQ_THM, relationTheory.RSUBSET, boolTheory.EXISTS_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.inv_image_thm, relationTheory.EMPTY_REL_DEF, relationTheory.EMPTY_REL_DEF, relationTheory.inv_image_thm, relationTheory.WF_SUBSET]", "reward": 5}]], "Order (R :\u03b1 -> \u03b1 -> bool) \u21d4 WeakOrder (RC R)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ Order VR @ C$relation$ WeakOrder @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "Order (R :\u03b1 -> \u03b1 -> bool) \u21d4 WeakOrder (RC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$relation$ antisymmetric VR @ C$relation$ transitive VR @ @ C$bool$ /\\ @ C$relation$ reflexive @ C$relation$ RC VR @ @ C$bool$ /\\ @ C$relation$ antisymmetric @ C$relation$ RC VR @ C$relation$ transitive @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "antisymmetric (R :\u03b1 -> \u03b1 -> bool) \u2227 transitive R \u21d4 (reflexive (RC R) :bool) \u2227 antisymmetric (RC R) \u2227 transitive (RC R)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.WF_DEF, relationTheory.INVOL, relationTheory.RUNION, relationTheory.WeakOrder, relationTheory.Order]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$relation$ antisymmetric VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ @ C$bool$ /\\ @ C$relation$ reflexive @ C$relation$ RC VR @ @ C$bool$ /\\ @ C$relation$ antisymmetric @ C$relation$ RC VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ RC VR Vx Vy @ @ @ C$relation$ RC VR Vy Vz @ @ @ C$relation$ RC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "antisymmetric (R :\u03b1 -> \u03b1 -> bool) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z) \u21d4 (reflexive (RC R) :bool) \u2227 antisymmetric (RC R) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). RC R x y \u2227 RC R y z \u21d2 RC R x z"}}], "parent": 1, "goal": 0, "by_tactic": "rw[relationTheory.Order, relationTheory.irreflexive_def, relationTheory.transitive_def, relationTheory.RTC_CASES2, relationTheory.WeakOrder]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vx @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ VR Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ VR Vy Vx @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ VR Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vz @ @ VR Vy Vz @ @ C$bool$ \\/ @ @ C$min$ = Vx Vz @ @ VR Vx Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y x \u21d2 x = y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z) \u21d4 (\u2200(x :\u03b1) (y :\u03b1). (x = y \u2228 R x y) \u2227 (y = x \u2228 R y x) \u21d2 x = y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (x = y \u2228 R x y) \u2227 (y = z \u2228 R y z) \u21d2 x = z \u2228 R x z"}}], "parent": 2, "goal": 0, "by_tactic": "rw[relationTheory.RC_DEF, relationTheory.reflexive_def, relationTheory.EqIsBothRSUBSET, relationTheory.antisymmetric_def, relationTheory.EXTEND_RTC_TC]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[relationTheory.STRORD, relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.symmetric_def, relationTheory.IDEM, relationTheory.inv_RC]", "reward": 5}]], "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGUNION (s1 \u222a s2) = BIGUNION s1 \u222a BIGUNION s2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ @ C$min$ = @ C$pred_set$ BIGUNION @ @ C$pred_set$ UNION Vs1 Vs2 @ @ C$pred_set$ UNION @ C$pred_set$ BIGUNION Vs1 @ C$pred_set$ BIGUNION Vs2"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :(\u03b1 -> bool) -> bool) (s2 :(\u03b1 -> bool) -> bool). BIGUNION (s1 \u222a s2) = BIGUNION s1 \u222a BIGUNION s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs @ @ C$pred_set$ UNION Vs1 Vs2 @ @ C$bool$ IN Vx Vs @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs Vs1 @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs Vs2 @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "{x | \u2203(s :\u03b1 -> bool). s \u2208 (s1 :(\u03b1 -> bool) -> bool) \u222a (s2 :(\u03b1 -> bool) -> bool) \u2227 x \u2208 s} = {x | \u2203(s :\u03b1 -> bool). s \u2208 s1 \u2227 x \u2208 s} \u222a {x | \u2203(s :\u03b1 -> bool). s \u2208 s2 \u2227 x \u2208 s}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IMAGE_DEF, pred_setTheory.INSERT_INSERT, pred_setTheory.IMAGE_DEF, pred_setTheory.BIGUNION, pred_setTheory.DIFF_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ Vs1 Vs @ Vs2 Vs @ Vs Vx | Vx @ @ C$bool$ \\/ @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ Vs1 Vs @ Vs Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ Vs2 Vs @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). \u2203(s :\u03b1 -> bool). ((s1 :(\u03b1 -> bool) -> bool) s \u2228 (s2 :(\u03b1 -> bool) -> bool) s) \u2227 s x) = (\u03bb(x :\u03b1). (\u2203(s :\u03b1 -> bool). s1 s \u2227 s x) \u2228 \u2203(s :\u03b1 -> bool). s2 s \u2227 s x)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.IMAGE_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.DIFF_applied, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.CARD_UNION_EQN, pred_setTheory.IN_REST, pred_setTheory.SUBSET_applied, pred_setTheory.FINITE_HAS_SIZE]", "reward": 5}]], "\u2200(s :num -> bool). countable s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$pred_set$ countable Vs"}, "plain": {"assumptions": [], "goal": "\u2200(s :num -> bool). countable s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vn @ @ C$min$ = @ Vf Vn Vx"}, "plain": {"assumptions": [], "goal": "\u2203(f :num -> num). \u2200(x :num). x \u2208 (s :num -> bool) \u21d2 \u2203(n :num). f n = x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.equiv_on_def, pred_setTheory.FINITE_DELETE, pred_setTheory.COUNTABLE_ALT, pred_setTheory.EMPTY_DEF, pred_setTheory.EQUAL_SING]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.itself_case_thm, pred_setTheory.BIGUNION_SING, pred_setTheory.COUNTABLE_COUNT, pred_setTheory.FINITE_COUNT, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). s \u2286 t \u21d2 PREIMAGE f s \u2286 PREIMAGE f t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs Vt @ @ C$pred_set$ SUBSET @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$pred_set$ PREIMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). s \u2286 t \u21d2 PREIMAGE f s \u2286 PREIMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.UNWIND_FORALL_THM1, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_PREIMAGE, pred_setTheory.IN_IMAGE, pred_setTheory.SUBSET_K]", "reward": 5}]], "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = SOME (s' :\u03b1) \u21d2 \u00acG s'": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = @ @ @ C$while$ OWHILE VG Vf Vs @ C$option$ SOME Vs' @ C$bool$ ~ @ VG Vs'"}, "plain": {"assumptions": [], "goal": "OWHILE (G :\u03b1 -> bool) (f :\u03b1 -> \u03b1) (s :\u03b1) = SOME (s' :\u03b1) \u21d2 \u00acG s'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.BOTH_FORALL_OR_THM, whileTheory.LEAST_EXISTS, whileTheory.OWHILE_def, boolTheory.F_IMP, boolTheory.EQ_SYM_EQ]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b3 -> bool) (u :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b3). BIJ f s t) \u2227 (\u2203(g :\u03b3 -> \u03b2). BIJ g t u) \u21d2 \u2203(h :\u03b1 -> \u03b2). BIJ h s u": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ? | Vf @ @ @ C$pred_set$ BIJ Vf Vs Vt @ C$bool$ ? | Vg @ @ @ C$pred_set$ BIJ Vg Vt Vu @ C$bool$ ? | Vh @ @ @ C$pred_set$ BIJ Vh Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b3 -> bool) (u :\u03b2 -> bool). (\u2203(f :\u03b1 -> \u03b3). BIJ f s t) \u2227 (\u2203(g :\u03b3 -> \u03b2). BIJ g t u) \u21d2 \u2203(h :\u03b1 -> \u03b2). BIJ h s u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[boolTheory.LET_THM, pred_setTheory.SUBSET_K, pred_setTheory.BIJ_COMPOSE, pred_setTheory.IMAGE_INSERT, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(n :num). n \u2260 (0 :num) \u21d2 COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n \u2212 (1 :num)))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). n \u2260 (0 :num) \u21d2 COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n \u2212 (1 :num)))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$num$ 0 C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST C$num$ 0 @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - C$num$ 0 @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "(0 :num) \u2260 (0 :num) \u21d2 COUNT_LIST (0 :num) = (0 :num)::MAP SUC (COUNT_LIST ((0 :num) \u2212 (1 :num)))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num) \u21d2 COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n \u2212 (1 :num)))"], "goal": "SUC (n :num) \u2260 (0 :num) \u21d2 COUNT_LIST (SUC n) = (0 :num)::MAP SUC (COUNT_LIST (SUC n \u2212 (1 :num)))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn @ @ C$list$ CONS C$num$ 0 @ @ C$list$ MAP C$num$ SUC @ C$rich_list$ COUNT_LIST @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num) \u21d2 COUNT_LIST n = (0 :num)::MAP SUC (COUNT_LIST (n \u2212 (1 :num)))"], "goal": "SUC (n :num) \u2260 (0 :num) \u21d2 COUNT_LIST (SUC n) = (0 :num)::MAP SUC (COUNT_LIST (SUC n \u2212 (1 :num)))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.FILTER_EQ, listTheory.LENGTH_EQ_SUM, rich_listTheory.COUNT_LIST_COUNT, listTheory.EXISTS_MEM, rich_listTheory.LASTN_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.ZIP_EQ_NIL, listTheory.APPEND_11, rich_listTheory.COUNT_LIST_def, rich_listTheory.SPLITP_APPEND, rich_listTheory.APPEND_SNOC1]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). rcdiamond R \u21d4 diamond (RC R)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ rcdiamond VR @ C$relation$ diamond @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). rcdiamond R \u21d4 diamond (RC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ rcdiamond VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ RC VR Vx Vy @ @ @ C$relation$ RC VR Vx Vz @ C$bool$ ? | Vu @ @ C$bool$ /\\ @ @ @ C$relation$ RC VR Vy Vu @ @ @ C$relation$ RC VR Vz Vu"}, "plain": {"assumptions": [], "goal": "rcdiamond (R :\u03b1 -> \u03b1 -> bool) \u21d4 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). RC R x y \u2227 RC R x z \u21d2 \u2203(u :\u03b1). RC R y u \u2227 RC R z u"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.diamond_def, relationTheory.nf_def, boolTheory.OR_CLAUSES, relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.TC_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, relationTheory.WFREC_COROLLARY, relationTheory.RTC_CASES1, relationTheory.rcdiamond_def, relationTheory.EXTEND_RTC_TC_EQN]", "reward": 5}]], "transitive ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ transitive C$pred_set$ PSUBSET"}, "plain": {"assumptions": [], "goal": "transitive ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$pred_set$ PSUBSET Vy Vz", "@ @ C$pred_set$ PSUBSET Vx Vy"], "goal": "@ @ C$pred_set$ PSUBSET Vx Vz"}, "plain": {"assumptions": ["(y :\u03b1 -> bool) \u2282 (z :\u03b1 -> bool)", "(x :\u03b1 -> bool) \u2282 (y :\u03b1 -> bool)"], "goal": "(x :\u03b1 -> bool) \u2282 (z :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.irreflexive_def, relationTheory.EQC_DEF, pred_setTheory.GSPECIFICATION, relationTheory.transitive_def, relationTheory.inv_EQC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vy Vz", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vy @ @ C$bool$ IN Vx Vz", "@ C$bool$ ~ @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$bool$ IN Vx' Vx @ @ C$bool$ IN Vx' Vy"], "goal": "@ C$bool$ ~ @ @ C$min$ = Vx Vz"}, "plain": {"assumptions": ["(y :\u03b1 -> bool) \u2260 (z :\u03b1 -> bool)", "\u2200(x :\u03b1). x \u2208 (y :\u03b1 -> bool) \u21d2 x \u2208 (z :\u03b1 -> bool)", "(x :\u03b1 -> bool) \u2260 (y :\u03b1 -> bool)", "\u2200(x' :\u03b1). x' \u2208 (x :\u03b1 -> bool) \u21d2 x' \u2208 (y :\u03b1 -> bool)"], "goal": "(x :\u03b1 -> bool) \u2260 (z :\u03b1 -> bool)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[relationTheory.TC_implies_one_step, pred_setTheory.PSUBSET_DEF, relationTheory.RRESTRICT_DEF, relationTheory.RC_DEF, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[relationTheory.inv_image_thm, relationTheory.WeakOrder_EQ, pred_setTheory.SUBSET_DEF, pred_setTheory.SET_EQ_SUBSET, relationTheory.TC_IDEM]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (e :\u03b1). FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND Vl1 @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND Vl1 @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (e :\u03b1). FRONT (l1 ++ e::l2) = l1 ++ FRONT (e::l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND C$list$ NIL @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list) (e :\u03b1). FRONT (([] :\u03b1 list) \u29fa e::l2) = ([] :\u03b1 list) \u29fa FRONT (e::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND Vl1 @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND Vl1 @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (e :\u03b1). FRONT ((l1 :\u03b1 list) \u29fa e::l2) = l1 \u29fa FRONT (e::l2)"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (e :\u03b1). FRONT (h::(l1 :\u03b1 list) \u29fa e::l2) = h::l1 \u29fa FRONT (e::l2)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND Vl1 @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND Vl1 @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Ve @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve Vl2 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ C$list$ FRONT @ @ C$list$ CONS Ve Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (e :\u03b1). FRONT ((l1 :\u03b1 list) \u29fa e::l2) = l1 \u29fa FRONT (e::l2)"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (e :\u03b1). FRONT (h::(l1 :\u03b1 list) \u29fa e::l2) = h::l1 \u29fa FRONT (e::l2)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_SNOC, boolTheory.EQ_EXPAND, listTheory.TAKE_0, listTheory.FILTER_COND_REWRITE, listTheory.CONS_11]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.ZIP_EQ_NIL, listTheory.FRONT_DEF, listTheory.oEL_def, listTheory.EL_APPEND_EQN, listTheory.GENLIST_AUX]", "reward": 5}]], "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2200(x :\u03b1) (y :\u03b2). LINV_OPT f s y = SOME x \u21d4 y = f x \u2227 x \u2208 s \u2227 y \u2208 t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$min$ = @ @ @ C$pred_set$ LINV_OPT Vf Vs Vy @ C$option$ SOME Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vt"}, "plain": {"assumptions": [], "goal": "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2200(x :\u03b1) (y :\u03b2). LINV_OPT f s y = SOME x \u21d4 y = f x \u2227 x \u2208 s \u2227 y \u2208 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ @ C$pred_set$ INJ Vf Vs Vt @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ Vs Vx @ @ C$min$ = @ C$min$ @ | Vx @ @ C$bool$ /\\ @ Vs Vx @ @ C$min$ = @ Vf Vx Vy Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ /\\ @ Vs Vx @ Vt Vy"}, "plain": {"assumptions": [], "goal": "INJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d2 \u2200(x :\u03b1) (y :\u03b2). (\u2203(x :\u03b1). y = f x \u2227 s x) \u2227 (@(x :\u03b1). s x \u2227 f x = y) = x \u21d4 y = f x \u2227 s x \u2227 t y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA, pred_setTheory.LINV_OPT_def, pred_setTheory.IN_IMAGE, pred_setTheory.IN_SING]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx @ Vs Vy @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ /\\ @ Vs Vx @ Vt Vy @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vy @ Vf Vx @ Vs Vx @ @ C$min$ = Vx @ C$min$ @ | Vx @ @ C$bool$ /\\ @ Vs Vx @ @ C$min$ = Vy @ Vf Vx"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b1). (s :\u03b1 -> bool) x \u2227 s y \u21d2 (f :\u03b1 -> \u03b2) x = f y \u21d2 x = y", "\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b2 -> bool) ((f :\u03b1 -> \u03b2) x)"], "goal": "(y :\u03b2) = (f :\u03b1 -> \u03b2) (x :\u03b1) \u2227 (s :\u03b1 -> bool) x \u2227 (t :\u03b2 -> bool) y \u21d4 (\u2203(x :\u03b1). y = f x \u2227 s x) \u2227 x = @(x :\u03b1). s x \u2227 y = f x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, boolTheory.EQ_SYM_EQ, pred_setTheory.GSPEC_ETA, pred_setTheory.INJ_DEF, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.INTER_EMPTY, pred_setTheory.SING_DELETE, pred_setTheory.GSPEC_ETA, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f s = s \u2218 f": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$combin$ o Vs Vf"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f s = s \u2218 f"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vx @ Vs @ Vf Vx @ @ C$combin$ o Vs Vf"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). (s :\u03b2 -> bool) ((f :\u03b1 -> \u03b2) x)) = s \u2218 f"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.PREIMAGE_def, pred_setTheory.SCHROEDER_CLOSE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, pred_setTheory.FINITE_COUNT, pred_setTheory.INSERT_applied, pred_setTheory.LINV_OPT_def, pred_setTheory.IN_REST]", "reward": 5}]], "(tri (n :num) = (0 :num) \u21d4 n = (0 :num)) \u2227 ((0 :num) = tri n \u21d4 n = (0 :num))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri Vn C$num$ 0 @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri Vn @ @ C$min$ = Vn C$num$ 0"}, "plain": {"assumptions": [], "goal": "(tri (n :num) = (0 :num) \u21d4 n = (0 :num)) \u2227 ((0 :num) = tri n \u21d4 n = (0 :num))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri C$num$ 0 C$num$ 0 @ @ C$min$ = C$num$ 0 C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri C$num$ 0 @ @ C$min$ = C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "(tri (0 :num) = (0 :num) \u21d4 (0 :num) = (0 :num)) \u2227 ((0 :num) = tri (0 :num) \u21d4 (0 :num) = (0 :num))"}}, {"polished": {"assumptions": ["@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri Vn C$num$ 0 @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri Vn @ @ C$min$ = Vn C$num$ 0"], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0"}, "plain": {"assumptions": ["(tri (n :num) = (0 :num) \u21d4 n = (0 :num)) \u2227 ((0 :num) = tri n \u21d4 n = (0 :num))"], "goal": "(tri (SUC (n :num)) = (0 :num) \u21d4 SUC n = (0 :num)) \u2227 ((0 :num) = tri (SUC n) \u21d4 SUC n = (0 :num))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri Vn C$num$ 0 @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri Vn @ @ C$min$ = Vn C$num$ 0"], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$numpair$ tri @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0 @ @ C$min$ = @ @ C$min$ = C$num$ 0 @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$min$ = @ C$num$ SUC Vn C$num$ 0"}, "plain": {"assumptions": ["(tri (n :num) = (0 :num) \u21d4 n = (0 :num)) \u2227 ((0 :num) = tri n \u21d4 n = (0 :num))"], "goal": "(tri (SUC (n :num)) = (0 :num) \u21d4 SUC n = (0 :num)) \u2227 ((0 :num) = tri (SUC n) \u21d4 SUC n = (0 :num))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, boolTheory.itself_TY_DEF, boolTheory.ITSELF_UNIQUE, numpairTheory.tri_def, numpairTheory.tri_formula]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[numpairTheory.twotri_formula, boolTheory.OR_CLAUSES, boolTheory.ONE_ONE_DEF, boolTheory.MONO_AND, numpairTheory.tri_def]", "reward": 5}]], "\u2200(m :num) (n :num). m \u2264 n \u21d2 count m \u2286 count n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm Vn @ @ C$pred_set$ SUBSET @ C$pred_set$ count Vm @ C$pred_set$ count Vn"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m \u2264 n \u21d2 count m \u2286 count n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.count_def, pred_setTheory.IN_DISJOINT, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.SUBSET_applied, boolTheory.LEFT_EXISTS_IMP_THM]", "reward": 5}]], "\u2200(A :\u03b1 -> bool) (B :\u03b1 -> bool) (x :\u03b1). A \u222a B DELETE x = A DELETE x \u222a (B DELETE x)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VA @ C$bool$ ! | VB @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DELETE @ @ C$pred_set$ UNION VA VB Vx @ @ C$pred_set$ UNION @ @ C$pred_set$ DELETE VA Vx @ @ C$pred_set$ DELETE VB Vx"}, "plain": {"assumptions": [], "goal": "\u2200(A :\u03b1 -> bool) (B :\u03b1 -> bool) (x :\u03b1). A \u222a B DELETE x = A DELETE x \u222a (B DELETE x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' VA @ @ C$bool$ IN Vx' VB @ C$bool$ ~ @ @ C$min$ = Vx Vx' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' VA @ C$bool$ ~ @ @ C$min$ = Vx Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' VB @ C$bool$ ~ @ @ C$min$ = Vx Vx'"}, "plain": {"assumptions": [], "goal": "((x' :\u03b1) \u2208 (A :\u03b1 -> bool) \u2228 x' \u2208 (B :\u03b1 -> bool)) \u2227 (x :\u03b1) \u2260 x' \u21d4 x' \u2208 A \u2227 x \u2260 x' \u2228 x' \u2208 B \u2227 x \u2260 x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, pred_setTheory.IN_DELETE, boolTheory.IMP_ANTISYM_AX]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.PSUBSET_MEMBER, pred_setTheory.INJ_COMPOSE, pred_setTheory.IN_ABS, pred_setTheory.IN_INTER, pred_setTheory.POW_applied]", "reward": 5}]], "(\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u222a s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u222a (\u2205 :\u03b1 -> bool) = s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ UNION C$pred_set$ EMPTY Vs Vs @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ UNION Vs C$pred_set$ EMPTY Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 -> bool). (\u2205 :\u03b1 -> bool) \u222a s = s) \u2227 \u2200(s :\u03b1 -> bool). s \u222a (\u2205 :\u03b1 -> bool) = s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.EMPTY_DEF, pred_setTheory.EXTENSION, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.IN_UNION]", "reward": 5}]], "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a (t DIFF s) = s \u222a t) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t DIFF s \u222a s = t \u222a s": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ UNION Vs @ @ C$pred_set$ DIFF Vt Vs @ @ C$pred_set$ UNION Vs Vt @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ UNION @ @ C$pred_set$ DIFF Vt Vs Vs @ @ C$pred_set$ UNION Vt Vs"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u222a (t DIFF s) = s \u222a t) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). t DIFF s \u222a s = t \u222a s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ \\/ @ Vs Vx @ @ @ C$pred_set$ DIFF Vt Vs Vx @ @ C$bool$ \\/ @ Vs Vx @ Vt Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ \\/ @ @ @ C$pred_set$ DIFF Vt Vs Vx @ Vs Vx @ @ C$bool$ \\/ @ Vt Vx @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). s x \u2228 (t DIFF s) x \u21d4 s x \u2228 t x) \u2227 \u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (t DIFF s) x \u2228 s x \u21d4 t x \u2228 s x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.UNION_applied, pred_setTheory.EXTENSION, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_DIFF, boolTheory.NOT_IMP, pred_setTheory.UNIV_applied, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set (l1 ++ l2) = set l1 \u222a set l2": [9, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$pred_set$ UNION @ C$list$ LIST_TO_SET Vl1 @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). set (l1 ++ l2) = set l1 \u222a set l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$pred_set$ UNION @ C$list$ LIST_TO_SET Vl1 @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "set ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = set l1 \u222a set l2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MAP2, listTheory.MAP_EQ_SING, pred_setTheory.IN_IMAGE, listTheory.FLAT_APPEND, pred_setTheory.INJ_IMAGE_BIJ]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b1) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM x l1 \u2228 MEM x l2"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, listTheory.FILTER_ALL_DISTINCT, pred_setTheory.REST_DEF, pred_setTheory.SUBSET_DEF, listTheory.ALL_DISTINCT_EL_IMP]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "simp[pred_setTheory.RTC_PSUBSET, listTheory.EXISTS_NOT_EVERY, listTheory.EVERY_NOT_EXISTS, pred_setTheory.EMPTY_NOT_UNIV, listTheory.MEM_APPEND]", "reward": 5}]], "\ud835\udd4c(:\u03b1 -> bool) = POW \ud835\udd4c(:\u03b1)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = C$pred_set$ UNIV @ C$pred_set$ POW C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1 -> bool) = POW \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_DEF, pred_setTheory.POW_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.DIFF_applied, pred_setTheory.SUBSET_UNIV]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 f x = f y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$min$ = @ Vf Vx @ Vf Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vx Vy @ @ C$min$ = @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (f :\u03b1 -> \u03b2) x = f y) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 f x = f y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.itself_induction, boolTheory.EQ_SYM_EQ, boolTheory.FUN_EQ_THM, relationTheory.RTC_ALT_RIGHT_DEF, boolTheory.UNWIND_FORALL_THM2]", "reward": 5}]], "EL (NUMERAL (BIT1 (n :num))) ((l :\u03b1)::(ls :\u03b1 list)) = EL (PRE (NUMERAL (BIT1 n))) ls \u2227 EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ EL @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 Vn @ @ C$list$ CONS Vl Vls @ @ C$list$ EL @ C$prim_rec$ PRE @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 Vn Vls @ @ C$min$ = @ @ C$list$ EL @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 Vn @ @ C$list$ CONS Vl Vls @ @ C$list$ EL @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 Vn Vls"}, "plain": {"assumptions": [], "goal": "EL (NUMERAL (BIT1 (n :num))) ((l :\u03b1)::(ls :\u03b1 list)) = EL (PRE (NUMERAL (BIT1 n))) ls \u2227 EL (NUMERAL (BIT2 n)) (l::ls) = EL (NUMERAL (BIT1 n)) ls"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ EL @ C$prim_rec$ PRE @ C$arithmetic$ BIT1 Vn @ C$list$ TL @ @ C$list$ CONS Vl Vls @ @ C$list$ EL @ C$prim_rec$ PRE @ C$arithmetic$ BIT1 Vn Vls @ @ C$min$ = @ @ C$list$ EL @ C$prim_rec$ PRE @ C$arithmetic$ BIT1 Vn @ C$list$ TL @ C$list$ TL @ @ C$list$ CONS Vl Vls @ @ C$list$ EL @ C$prim_rec$ PRE @ C$arithmetic$ BIT1 Vn @ C$list$ TL Vls"}, "plain": {"assumptions": [], "goal": "EL (PRE (BIT1 (n :num))) (TL ((l :\u03b1)::(ls :\u03b1 list))) = EL (PRE (BIT1 n)) ls \u2227 EL (PRE (BIT1 n)) (TL (TL (l::ls))) = EL (PRE (BIT1 n)) (TL ls)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[arithmeticTheory.BIT2, listTheory.EL_simp, arithmeticTheory.NUMERAL_DEF, arithmeticTheory.MULT_CLAUSES, listTheory.FLAT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.EL, arithmeticTheory.LESS_MOD, listTheory.TL_DEF, arithmeticTheory.ODD_DOUBLE, arithmeticTheory.MULT_SUC]", "reward": 5}]], "FLAT ([] :\u03b1 list list) = ([] :\u03b1 list) \u2227 FLAT (([] :\u03b2 list)::(t :\u03b2 list list)) = FLAT t \u2227 FLAT (((h :\u03b3)::(t1 :\u03b3 list))::(t2 :\u03b3 list list)) = h::FLAT (t1::t2)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ FLAT C$list$ NIL C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ CONS C$list$ NIL Vt @ C$list$ FLAT Vt @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ CONS @ @ C$list$ CONS Vh Vt1 Vt2 @ @ C$list$ CONS Vh @ C$list$ FLAT @ @ C$list$ CONS Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "FLAT ([] :\u03b1 list list) = ([] :\u03b1 list) \u2227 FLAT (([] :\u03b2 list)::(t :\u03b2 list list)) = FLAT t \u2227 FLAT (((h :\u03b3)::(t1 :\u03b3 list))::(t2 :\u03b3 list list)) = h::FLAT (t1::t2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.APPEND, listTheory.FLAT, boolTheory.DATATYPE_TAG_THM, listTheory.LENGTH_APPEND, boolTheory.DISJ_COMM]", "reward": 5}]], "(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$min$ = Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX C$list$ NIL C$list$ NIL @ @ C$min$ = C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$min$ = Vx C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx C$list$ NIL @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 h::x = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ isPREFIX Vx C$list$ NIL @ @ C$min$ = Vx C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx C$list$ NIL @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 x = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c ([] :\u03b1 list) \u21d4 h::x = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.SET_TO_LIST_THM, listTheory.LIST_TO_SET_REVERSE, listTheory.isPREFIX_THM, listTheory.FILTER_EQ_ID, listTheory.NOT_EQ_LIST]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.MAP_EQ_SING, listTheory.DROP_def, listTheory.isPREFIX_THM, listTheory.UNZIP, listTheory.UNZIP]", "reward": 5}]], "(s :\u03b1 -> bool) \u2286 (t :\u03b1 -> bool) \u21d2 s \u222a (t DIFF s) = t \u2227 t DIFF s \u222a s = t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs Vt @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ UNION Vs @ @ C$pred_set$ DIFF Vt Vs Vt @ @ C$min$ = @ @ C$pred_set$ UNION @ @ C$pred_set$ DIFF Vt Vs Vs Vt"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) \u2286 (t :\u03b1 -> bool) \u21d2 s \u222a (t DIFF s) = t \u2227 t DIFF s \u222a s = t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ \\/ @ Vs Vx @ @ C$bool$ /\\ @ Vt Vx @ C$bool$ ~ @ Vs Vx @ Vt Vx @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ Vt Vx @ C$bool$ ~ @ Vs Vx @ Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b1 -> bool) x) \u21d2 (\u2200(x :\u03b1). s x \u2228 t x \u2227 \u00acs x \u21d4 t x) \u2227 \u2200(x :\u03b1). t x \u2227 \u00acs x \u2228 s x \u21d4 t x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.DIFF_applied, pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.IN_APP, pred_setTheory.INTER_applied, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u00ac\u2203(x :\u03b1). x \u2208 s \u2227 x \u2208 t": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ DISJOINT Vs Vt @ C$bool$ ~ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). DISJOINT s t \u21d4 \u00ac\u2203(x :\u03b1). x \u2208 s \u2227 x \u2208 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ Vs Vx @ Vt Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$bool$ ~ @ Vs Vx @ C$bool$ ~ @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u2227 (t :\u03b1 -> bool) x \u21d4 \u2205 x) \u21d4 \u2200(x :\u03b1). \u00acs x \u2228 \u00act x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_DEF, pred_setTheory.IN_APP, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_ETA, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.EMPTY_DEF, pred_setTheory.UNION_EMPTY, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 R\ua673 (f x) (f y)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR @ Vf Vx @ Vf Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vx Vy @ @ @ C$relation$ RTC VR @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). R\ua673 x y \u21d2 R\ua673 (f x) (f y)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ @ C$relation$ TC VR Vx Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR @ Vf Vx @ Vf Vy"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ @ C$relation$ TC VR @ Vf Vx @ Vf Vy"}, "plain": {"assumptions": ["(R :\u03b1 -> \u03b1 -> bool)\u207a (x :\u03b1) (y :\u03b1)", "\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 R ((f :\u03b1 -> \u03b1) x) (f y)"], "goal": "(f :\u03b1 -> \u03b1) (x :\u03b1) = f (y :\u03b1) \u2228 (R :\u03b1 -> \u03b1 -> bool)\u207a (f x) (f y)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.itself_induction, boolTheory.EQ_SYM, relationTheory.irreflexive_def, relationTheory.RTC_CASES_TC, boolTheory.COND_CLAUSES]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.TC_lifts_monotonicities, boolTheory.REFL_CLAUSE, boolTheory.LEFT_AND_OVER_OR, boolTheory.RIGHT_OR_OVER_AND, relationTheory.RTC_TC_RC]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). INJ f (\u2205 :\u03b1 -> bool) s) \u2227 \u2200(s :\u03b1 -> bool). INJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ @ C$pred_set$ INJ Vf C$pred_set$ EMPTY Vs @ C$bool$ ! | Vs @ @ C$min$ = @ @ @ C$pred_set$ INJ Vf Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). INJ f (\u2205 :\u03b1 -> bool) s) \u2227 \u2200(s :\u03b1 -> bool). INJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN @ Vf Vx Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN Vy C$pred_set$ EMPTY @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx C$pred_set$ EMPTY @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). (\u2200(x :\u03b1). x \u2208 (\u2205 :\u03b1 -> bool) \u21d2 f x \u2208 s) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 (\u2205 :\u03b1 -> bool) \u2227 y \u2208 (\u2205 :\u03b1 -> bool) \u21d2 f x = f y \u21d2 x = y) \u2227 \u2200(s :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 (\u2205 :\u03b2 -> bool)) \u2227 (\u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 f x = f y \u21d2 x = y) \u21d4 \u2200(x :\u03b1). s x \u21d4 \u2205 x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.LEFT_OR_CONG, pred_setTheory.INJ_DEF, boolTheory.RES_ABSTRACT_DEF, pred_setTheory.INJ_DEF, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.EMPTY_DEF, pred_setTheory.SPECIFICATION, pred_setTheory.UNION_applied]", "reward": 5}]], "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2). MAP (f \u2218 g) = MAP f \u2218 MAP g": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ @ C$min$ = @ C$list$ MAP @ @ C$combin$ o Vf Vg @ @ C$combin$ o @ C$list$ MAP Vf @ C$list$ MAP Vg"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b2 -> \u03b3) (g :\u03b1 -> \u03b2). MAP (f \u2218 g) = MAP f \u2218 MAP g"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg Vx @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg Vx"}, "plain": {"assumptions": [], "goal": "MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) (x :\u03b1 list) = MAP f (MAP g x)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, listTheory.list_CASES, boolTheory.LEFT_FORALL_OR_THM, boolTheory.EQ_IMP_THM, boolTheory.EXISTS_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg C$list$ NIL @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) ([] :\u03b1 list) = MAP f (MAP g ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg Vx @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg Vx"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg @ @ C$list$ CONS Vh Vx @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vx"}, "plain": {"assumptions": ["MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) (x :\u03b1 list) = MAP f (MAP g x)"], "goal": "\u2200(h :\u03b1). MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) (h::(x :\u03b1 list)) = MAP f (MAP g (h::x))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg Vx @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg Vx"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP @ @ C$combin$ o Vf Vg @ @ C$list$ CONS Vh Vx @ @ C$list$ MAP Vf @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vx"}, "plain": {"assumptions": ["MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) (x :\u03b1 list) = MAP f (MAP g x)"], "goal": "\u2200(h :\u03b1). MAP ((f :\u03b2 -> \u03b3) \u2218 (g :\u03b1 -> \u03b2)) (h::(x :\u03b1 list)) = MAP f (MAP g (h::x))"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.FOLDL, listTheory.MAP, listTheory.LIST_TO_SET, boolTheory.EQ_SYM_EQ, boolTheory.EXISTS_DEF]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.MAP, listTheory.list_CASES, listTheory.LENGTH, listTheory.LENGTH, boolTheory.EQ_SYM]", "reward": 5}]], "\u2200(xs :\u03b1 list) (ys :\u03b2 list) (P :\u03b1 -> \u03b2 -> bool) (x :\u03b1). LIST_REL P xs ys \u2227 MEM x xs \u21d2 \u2203(y :\u03b2). MEM y ys \u2227 P x y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vxs @ C$bool$ ! | Vys @ C$bool$ ! | VP @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$list$ LIST_REL VP Vxs Vys @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vxs @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vys @ @ VP Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(xs :\u03b1 list) (ys :\u03b2 list) (P :\u03b1 -> \u03b2 -> bool) (x :\u03b1). LIST_REL P xs ys \u2227 MEM x xs \u21d2 \u2203(y :\u03b2). MEM y ys \u2227 P x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vxs", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vxs @ @ VP @ @ C$list$ EL Vn Vxs @ @ C$list$ EL Vn Vys", "@ @ C$min$ = @ C$list$ LENGTH Vxs @ C$list$ LENGTH Vys"], "goal": "@ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vys @ @ VP Vx Vy"}, "plain": {"assumptions": ["MEM (x :\u03b1) (xs :\u03b1 list)", "\u2200(n :num). n < LENGTH (xs :\u03b1 list) \u21d2 (P :\u03b1 -> \u03b2 -> bool) (EL n xs) (EL n (ys :\u03b2 list))", "LENGTH (xs :\u03b1 list) = LENGTH (ys :\u03b2 list)"], "goal": "\u2203(y :\u03b2). MEM y (ys :\u03b2 list) \u2227 (P :\u03b1 -> \u03b2 -> bool) (x :\u03b1) y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SNOC_11, listTheory.LIST_REL_EL_EQN, listTheory.FILTER_NEQ_ID, listTheory.LIST_REL_SPLIT1, listTheory.nub_set]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.EXISTS_LIST_EQ_MAP, listTheory.LENGTH_FRONT_CONS, boolTheory.EQ_SYM, listTheory.FRONT_DEF, listTheory.MEM_EL]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s \u222a t) = PREIMAGE f s \u222a PREIMAGE f t": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ UNION @ @ C$pred_set$ PREIMAGE Vf Vs @ @ C$pred_set$ PREIMAGE Vf Vt"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool) (t :\u03b2 -> bool). PREIMAGE f (s \u222a t) = PREIMAGE f s \u222a PREIMAGE f t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.UNION_applied, pred_setTheory.INTER_applied, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.UNION_DEF, pred_setTheory.PREIMAGE_def]", "reward": 5}]], "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R' :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R^= (x :\u03b1) (y :\u03b1) \u21d2 R'^= x y": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR' Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ EQC VR Vx Vy @ @ @ C$relation$ EQC VR' Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R' :\u03b1 -> \u03b1 -> bool) x y) \u21d2 R^= (x :\u03b1) (y :\u03b1) \u21d2 R'^= x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR' Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ RC @ C$relation$ TC @ C$relation$ SC VR Vx Vy @ @ @ C$relation$ RC @ C$relation$ TC @ C$relation$ SC VR' Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R' :\u03b1 -> \u03b1 -> bool) x y) \u21d2 RC (SC R)\u207a (x :\u03b1) (y :\u03b1) \u21d2 RC (SC R')\u207a x y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.RTC_def, relationTheory.EQC_R, relationTheory.transitive_RC, relationTheory.EQC_DEF, boolTheory.itself_TY_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VR' Vx Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ VR Vx Vy @ @ VR Vy Vx @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ C$bool$ ! | Vy' @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ VR' Vx' Vy' @ @ VR' Vy' Vx' @ @ VP Vx' Vy' @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (R' :\u03b1 -> \u03b1 -> bool) x y) \u21d2 (x :\u03b1) = (y :\u03b1) \u2228 (\u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u2228 R y x \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x y) \u21d2 x = y \u2228 \u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x' :\u03b1) (y' :\u03b1). R' x' y' \u2228 R' y' x' \u21d2 P x' y') \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x y"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, relationTheory.SC_DEF, relationTheory.TC_DEF, relationTheory.RC_DEF, relationTheory.RTC_CASES_TC]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.AND_IMP_INTRO, relationTheory.RC_DEF, boolTheory.NOT_AND, boolTheory.OR_IMP_THM, relationTheory.TC_CASES2_E]", "reward": 5}]], "LINV_OPT (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (y :\u03b2) = SOME (x :\u03b1) \u21d2 x \u2208 s \u2227 f x = y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = @ @ @ C$pred_set$ LINV_OPT Vf Vs Vy @ C$option$ SOME Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ Vf Vx Vy"}, "plain": {"assumptions": [], "goal": "LINV_OPT (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (y :\u03b2) = SOME (x :\u03b1) \u21d2 x \u2208 s \u2227 f x = y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ @ C$min$ = @ C$min$ @ | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ Vf Vx Vy Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ Vf Vx Vy"}, "plain": {"assumptions": [], "goal": "(y :\u03b2) \u2208 IMAGE (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) \u2227 (@(x :\u03b1). x \u2208 s \u2227 f x = y) = (x :\u03b1) \u21d2 x \u2208 s \u2227 f x = y"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.FUNSET, pred_setTheory.TC_PSUBSET, pred_setTheory.GSPEC_ETA, pred_setTheory.LINV_OPT_def, pred_setTheory.INTER_applied]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_applied, pred_setTheory.IMAGE_applied, pred_setTheory.REST_DEF, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). \u00acNULL l1 \u21d2 ELL (LENGTH l2) (l1 ++ l2) = LAST l1": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl1 @ @ C$min$ = @ @ C$rich_list$ ELL @ C$list$ LENGTH Vl2 @ @ C$list$ APPEND Vl1 Vl2 @ C$list$ LAST Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). \u00acNULL l1 \u21d2 ELL (LENGTH l2) (l1 ++ l2) = LAST l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL Vl1"], "goal": "@ @ C$min$ = @ @ C$rich_list$ ELL @ C$list$ LENGTH Vl2 @ @ C$list$ APPEND Vl1 Vl2 @ C$list$ LAST Vl1"}, "plain": {"assumptions": ["\u00acNULL (l1 :\u03b1 list)"], "goal": "ELL (LENGTH (l2 :\u03b1 list)) ((l1 :\u03b1 list) \u29fa l2) = LAST l1"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.MEM_EL, listTheory.UNZIP_ZIP, listTheory.EXISTS_CONG, boolTheory.ETA_THM, listTheory.INJ_MAP_EQ_IFF]", "reward": 0.1}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.list_CASES, rich_listTheory.ELL_APPEND1, rich_listTheory.ELL_LAST, rich_listTheory.TAKE_APPEND, rich_listTheory.SPLITL_def]", "reward": 5}]], "(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = Vx C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"}, "plain": {"assumptions": [], "goal": "(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = C$list$ NIL C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). ([] :\u03b1 list) = y::xs \u2227 xs \u227c ys"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = Vx C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 h::x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). h::x = y::xs \u2227 xs \u227c ys"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ isPREFIX Vx @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = Vx C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vy Vys @ @ C$bool$ \\/ @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Vy Vxs @ @ C$list$ isPREFIX Vxs Vys"}, "plain": {"assumptions": ["(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). x = y::xs \u2227 xs \u227c ys"], "goal": "\u2200(h :\u03b1). h::(x :\u03b1 list) \u227c (y :\u03b1)::(ys :\u03b1 list) \u21d4 h::x = ([] :\u03b1 list) \u2228 \u2203(xs :\u03b1 list). h::x = y::xs \u2227 xs \u227c ys"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.CONS_11, listTheory.isPREFIX, listTheory.CONS_11, listTheory.APPEND_LENGTH_EQ, listTheory.LIST_REL_cases]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.CONS_11, listTheory.isPREFIX_THM, listTheory.NOT_CONS_NIL, listTheory.isPREFIX, listTheory.ZIP_def]", "reward": 5}]], "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 POW s1 \u2286 POW s2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs1 @ C$bool$ ! | Vs2 @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs1 Vs2 @ @ C$pred_set$ SUBSET @ C$pred_set$ POW Vs1 @ C$pred_set$ POW Vs2"}, "plain": {"assumptions": [], "goal": "\u2200(s1 :\u03b1 -> bool) (s2 :\u03b1 -> bool). s1 \u2286 s2 \u21d2 POW s1 \u2286 POW s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.POW_DEF, pred_setTheory.POW_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.POW_applied, pred_setTheory.IN_POW]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND Vl1 Vl2 Vl3"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l3 :\u03b1 list). l1 ++ (l2 ++ l3) = l1 ++ l2 ++ l3"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND C$list$ NIL Vl2 Vl3"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list) (l3 :\u03b1 list). ([] :\u03b1 list) \u29fa (l2 \u29fa l3) = ([] :\u03b1 list) \u29fa l2 \u29fa l3"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND Vl1 Vl2 Vl3"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl3"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (l3 :\u03b1 list). (l1 :\u03b1 list) \u29fa (l2 \u29fa l3) = l1 \u29fa l2 \u29fa l3"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (l3 :\u03b1 list). h::(l1 :\u03b1 list) \u29fa (l2 \u29fa l3) = h::l1 \u29fa l2 \u29fa l3"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND Vl1 @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND Vl1 Vl2 Vl3"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl3 @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND Vl2 Vl3 @ @ C$list$ APPEND @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl3"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (l3 :\u03b1 list). (l1 :\u03b1 list) \u29fa (l2 \u29fa l3) = l1 \u29fa l2 \u29fa l3"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (l3 :\u03b1 list). h::(l1 :\u03b1 list) \u29fa (l2 \u29fa l3) = h::l1 \u29fa l2 \u29fa l3"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LENGTH, listTheory.SUM, listTheory.APPEND, boolTheory.LEFT_OR_EXISTS_THM, boolTheory.SELECT_REFL_2]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.list_case_eq, boolTheory.RES_FORALL_TRUE, listTheory.MAP, listTheory.LIST_TO_SET, listTheory.APPEND]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). R\ua673 \ua673 = R\ua673": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ RTC @ C$relation$ RTC VR @ C$relation$ RTC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). R\ua673 \ua673 = R\ua673"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ C$bool$ ! | VQ @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vx' @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | VQ @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vy @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VR Vx Vy @ VQ Vy @ C$bool$ ~ @ VQ Vx @ VQ Vx @ VQ Vy @ C$bool$ ~ @ VQ Vx @ VQ Vx @ C$bool$ ! | VQ @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vx' @ C$bool$ ? | Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VR Vx Vy @ VQ Vy @ C$bool$ ~ @ VQ Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (x' :\u03b1). (\u2200(Q :\u03b1 -> bool). (\u00acQ x' \u2228 \u2203(x :\u03b1) (y :\u03b1). ((\u2200(Q :\u03b1 -> bool). (\u00acQ y \u2228 \u2203(x :\u03b1) (y :\u03b1). (R x y \u2227 Q y) \u2227 \u00acQ x) \u2228 Q x) \u2227 Q y) \u2227 \u00acQ x) \u2228 Q x) \u21d4 \u2200(Q :\u03b1 -> bool). (\u00acQ x' \u2228 \u2203(x :\u03b1) (y :\u03b1). (R x y \u2227 Q y) \u2227 \u00acQ x) \u2228 Q x"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.NOT_EXISTS_THM, boolTheory.IMP_DISJ_THM, boolTheory.literal_case_THM, boolTheory.FUN_EQ_THM, relationTheory.RTC_ALT_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.CONJ_ASSOC, boolTheory.RES_SELECT_DEF, boolTheory.NOT_AND, boolTheory.NOT_IMP, boolTheory.ONE_ONE_THM]", "reward": 5}]], "\u2200(l :bool list). OR_EL l \u21d4 FOLDR $\\/ F l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$rich_list$ OR_EL Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :bool list). OR_EL l \u21d4 FOLDR $\\/ F l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$rich_list$ OR_EL Vl @ @ @ C$list$ FOLDR C$bool$ \\/ C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "OR_EL (l :bool list) \u21d4 FOLDR $\\/ F l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN_REVERSE, listTheory.EQ_LIST, listTheory.LIST_EQ_REWRITE, listTheory.MEM_SPLIT, rich_listTheory.ELL_CONS]", "reward": 0.1}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.EXISTS_FOLDR_MAP, listTheory.PAD_LEFT, listTheory.REVERSE_REVERSE, rich_listTheory.AND_EL_DEF, rich_listTheory.OR_EL_DEF]", "reward": 5}]], "BIGINTER (\u2205 :(\u03b1 -> bool) -> bool) = \ud835\udd4c(:\u03b1)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ BIGINTER C$pred_set$ EMPTY C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "BIGINTER (\u2205 :(\u03b1 -> bool) -> bool) = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ BIGINTER | Vx C$bool$ F @ @ C$bool$ IN Vx C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). x \u2208 BIGINTER (\u03bb(x :\u03b1 -> bool). F) \u21d4 x \u2208 \ud835\udd4c(:\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.FINITE_WEAK_ENUMERATE, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_applied, pred_setTheory.EXTENSION, pred_setTheory.HAS_SIZE_0]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx C$bool$ T Vx @ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "{x | T} (x :\u03b1) \u21d4 \ud835\udd4c(:\u03b1) x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.DIFF_INTER, pred_setTheory.BIJ_DEF, pred_setTheory.SCHROEDER_CLOSE, pred_setTheory.BIGINTER]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_DEF, pred_setTheory.COUNT_NOT_EMPTY, pred_setTheory.COUNT_SUC, pred_setTheory.GSPEC_ETA, pred_setTheory.FUNSET_INTER]", "reward": 5}]], "total (R1 :\u03b1 -> \u03b1 -> bool) \u2227 total (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 total (R1 LEX R2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$relation$ total VR1 @ C$relation$ total VR2 @ C$relation$ total @ @ C$pair$ LEX VR1 VR2"}, "plain": {"assumptions": [], "goal": "total (R1 :\u03b1 -> \u03b1 -> bool) \u2227 total (R2 :\u03b2 -> \u03b2 -> bool) \u21d2 total (R1 LEX R2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ @ VR1 Vx Vy @ @ VR1 Vy Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ @ VR2 Vx Vy @ @ VR2 Vy Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ VR1 @ C$pair$ FST Vx @ C$pair$ FST Vy @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vx @ C$pair$ FST Vy @ @ VR2 @ C$pair$ SND Vx @ C$pair$ SND Vy @ @ C$bool$ \\/ @ @ VR1 @ C$pair$ FST Vy @ C$pair$ FST Vx @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vy @ C$pair$ FST Vx @ @ VR2 @ C$pair$ SND Vy @ C$pair$ SND Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R1 :\u03b1 -> \u03b1 -> bool) x y \u2228 R1 y x) \u2227 (\u2200(x :\u03b2) (y :\u03b2). (R2 :\u03b2 -> \u03b2 -> bool) x y \u2228 R2 y x) \u21d2 \u2200(x :\u03b1 # \u03b2) (y :\u03b1 # \u03b2). (R1 (FST x) (FST y) \u2228 FST x = FST y \u2227 R2 (SND x) (SND y)) \u2228 R1 (FST y) (FST x) \u2228 FST y = FST x \u2227 R2 (SND y) (SND x)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pairTheory.ELIM_UNCURRY, relationTheory.IN_RDOM_DELETE, relationTheory.total_def, pairTheory.LEX_DEF, relationTheory.SC_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.Order, relationTheory.symmetric_def, relationTheory.EMPTY_REL_DEF, relationTheory.WF_SUBSET, pairTheory.UNCURRY_DEF]", "reward": 5}]], "IDEM (STRORD :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$relation$ IDEM C$relation$ STRORD"}, "plain": {"assumptions": [], "goal": "IDEM (STRORD :(\u03b1 -> \u03b1 -> bool) -> \u03b1 -> \u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ STRORD @ C$relation$ STRORD Vx @ C$relation$ STRORD Vx"}, "plain": {"assumptions": [], "goal": "STRORD (STRORD (x :\u03b1 -> \u03b1 -> bool)) = STRORD x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.INVOL, relationTheory.IDEM, relationTheory.reflexive_def, relationTheory.reflexive_def, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET @ C$relation$ STRORD @ C$relation$ STRORD Vx @ C$relation$ STRORD Vx @ @ C$relation$ RSUBSET @ C$relation$ STRORD Vx @ C$relation$ STRORD @ C$relation$ STRORD Vx"}, "plain": {"assumptions": [], "goal": "STRORD (STRORD (x :\u03b1 -> \u03b1 -> bool)) \u2286\u1d63 STRORD x \u2227 STRORD x \u2286\u1d63 STRORD (STRORD x)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[relationTheory.TC_implies_one_step, relationTheory.WFP_RULES, relationTheory.transitive_def, relationTheory.IDEM, relationTheory.EqIsBothRSUBSET]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[relationTheory.irreflexive_def, relationTheory.INVOL, relationTheory.RSUBSET, relationTheory.SC_DEF, relationTheory.STRORD]", "reward": 5}]], "SING ((x :\u03b1) INSERT (s :\u03b1 -> bool)) \u21d4 s = (\u2205 :\u03b1 -> bool) \u2228 s = {x}": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ SING @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ \\/ @ @ C$min$ = Vs C$pred_set$ EMPTY @ @ C$min$ = Vs @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "SING ((x :\u03b1) INSERT (s :\u03b1 -> bool)) \u21d4 s = (\u2205 :\u03b1 -> bool) \u2228 s = {x}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ C$bool$ ! | Vx'' @ @ C$min$ = @ @ C$bool$ IN Vx'' @ @ C$pred_set$ INSERT Vx Vs @ @ C$bool$ IN Vx'' @ @ C$pred_set$ INSERT Vx' C$pred_set$ EMPTY @ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "(\u2203(x' :\u03b1). \u2200(x'' :\u03b1). x'' \u2208 (x :\u03b1) INSERT (s :\u03b1 -> bool) \u21d4 x'' \u2208 {x'}) \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 (\u2205 :\u03b1 -> bool)) \u2228 \u2200(x' :\u03b1). x' \u2208 s \u21d4 x' \u2208 {x}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SING_DEF, pred_setTheory.DIFF_INTER2, pred_setTheory.SUBSET_INSERT_DELETE, pred_setTheory.EXTENSION, pred_setTheory.INSERT_applied]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ C$bool$ ! | Vx'' @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx'' Vx @ Vs Vx'' @ @ C$bool$ \\/ @ @ C$min$ = Vx'' Vx' @ C$pred_set$ EMPTY Vx'' @ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ! | Vx' @ @ C$min$ = @ Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ C$pred_set$ EMPTY Vx'"}, "plain": {"assumptions": [], "goal": "(\u2203(x' :\u03b1). \u2200(x'' :\u03b1). x'' = (x :\u03b1) \u2228 (s :\u03b1 -> bool) x'' \u21d4 x'' = x' \u2228 \u2205 x'') \u21d4 (\u2200(x :\u03b1). s x \u21d4 \u2205 x) \u2228 \u2200(x' :\u03b1). s x' \u21d4 x' = x \u2228 \u2205 x'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.UNION_DEF, pred_setTheory.UNIV_DEF, pred_setTheory.INSERT_applied, pred_setTheory.IN_INTER]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.INTER_EMPTY, pred_setTheory.INSERT_applied, pred_setTheory.MEMBER_NOT_EMPTY, pred_setTheory.DIFF_SAME_UNION]", "reward": 5}]], "\u2200(n :num). ALL_DISTINCT (COUNT_LIST n)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). ALL_DISTINCT (COUNT_LIST n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST C$num$ 0"}, "plain": {"assumptions": [], "goal": "ALL_DISTINCT (COUNT_LIST (0 :num))"}}, {"polished": {"assumptions": ["@ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST Vn"], "goal": "@ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn"}, "plain": {"assumptions": ["ALL_DISTINCT (COUNT_LIST (n :num))"], "goal": "ALL_DISTINCT (COUNT_LIST (SUC (n :num)))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST Vn"], "goal": "@ C$list$ ALL_DISTINCT @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn"}, "plain": {"assumptions": ["ALL_DISTINCT (COUNT_LIST (n :num))"], "goal": "ALL_DISTINCT (COUNT_LIST (SUC (n :num)))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.COUNT_LIST_def, rich_listTheory.FLAT_REVERSE, rich_listTheory.MAP_COUNT_LIST, listTheory.LIST_TO_SET, listTheory.list_CASES]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EL_REVERSE, rich_listTheory.ELL_EL, rich_listTheory.COUNT_LIST_GENLIST, rich_listTheory.COUNT_LIST_GENLIST, listTheory.ALL_DISTINCT_GENLIST]", "reward": 5}]], "\u2200(a :\u03b1 -> bool) (b :\u03b2 -> bool) (c :\u03b2 -> bool). FUNSET a (b \u2229 c) = FUNSET a b \u2229 FUNSET a c": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ = @ @ C$pred_set$ FUNSET Va @ @ C$pred_set$ INTER Vb Vc @ @ C$pred_set$ INTER @ @ C$pred_set$ FUNSET Va Vb @ @ C$pred_set$ FUNSET Va Vc"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 -> bool) (b :\u03b2 -> bool) (c :\u03b2 -> bool). FUNSET a (b \u2229 c) = FUNSET a b \u2229 FUNSET a c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Va Vx' @ @ C$bool$ /\\ @ Vb @ Vx Vx' @ Vc @ Vx Vx' @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Va Vx' @ Vb @ Vx Vx' @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Va Vx' @ Vc @ Vx Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). (a :\u03b1 -> bool) x' \u21d2 (b :\u03b2 -> bool) ((x :\u03b1 -> \u03b2) x') \u2227 (c :\u03b2 -> bool) (x x')) \u21d4 (\u2200(x' :\u03b1). a x' \u21d2 b (x x')) \u2227 \u2200(x' :\u03b1). a x' \u21d2 c (x x')"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FUNSET_applied, pred_setTheory.SPECIFICATION, pred_setTheory.EXTENSION, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_INTER]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.IN_DELETE_EQ, pred_setTheory.EMPTY_DEF, pred_setTheory.IN_ABS, pred_setTheory.EXTENSION]", "reward": 5}]], "\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). \u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (h::(l :\u03b1 list)) ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). \u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) (h::(l :\u03b1 list)) ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.GENLIST_FUN_EQ, listTheory.SUM_SNOC, listTheory.SUM_MAP_MEM_bound, listTheory.MEM_FILTER, listTheory.SHORTLEX_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_DEF, listTheory.EL_LENGTH_SNOC, listTheory.SHORTLEX_THM, listTheory.LIST_REL_EL_EQN, boolTheory.MONO_IMP]", "reward": 5}]], "\u2200(n :num). count (SUC n) = n INSERT count n": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ C$pred_set$ count @ C$num$ SUC Vn @ @ C$pred_set$ INSERT Vn @ C$pred_set$ count Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). count (SUC n) = n INSERT count n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.count_def, pred_setTheory.GSPEC_ETA, pred_setTheory.EXTENSION, pred_setTheory.INSERT_DEF]", "reward": 5}]], "(x :\u03b1 -> bool) \u2229 COMPL x = (\u2205 :\u03b1 -> bool) \u2227 COMPL x \u2229 x = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ INTER Vx @ C$pred_set$ COMPL Vx C$pred_set$ EMPTY @ @ C$min$ = @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vx Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "(x :\u03b1 -> bool) \u2229 COMPL x = (\u2205 :\u03b1 -> bool) \u2227 COMPL x \u2229 x = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' @ @ C$pred_set$ INTER Vx @ C$pred_set$ COMPL Vx @ @ C$bool$ IN Vx' | Vx C$bool$ F @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vx Vx @ @ C$bool$ IN Vx' | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). x' \u2208 (x :\u03b1 -> bool) \u2229 COMPL x \u21d4 x' \u2208 (\u03bb(x :\u03b1). F)) \u2227 \u2200(x' :\u03b1). x' \u2208 COMPL x \u2229 x \u21d4 x' \u2208 (\u03bb(x :\u03b1). F)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.AND1_THM, pred_setTheory.INJ_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.IN_DEF, pred_setTheory.COMPL_applied, pred_setTheory.SUBSET_ANTISYM_EQ, pred_setTheory.SPECIFICATION, pred_setTheory.INTER_applied]", "reward": 5}]], "(x1 :num) \u2297 (y1 :num) = (x2 :num) \u2297 (y2 :num) \u21d4 x1 = x2 \u2227 y1 = y2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$numpair$ npair Vx1 Vy1 @ @ C$numpair$ npair Vx2 Vy2 @ @ C$bool$ /\\ @ @ C$min$ = Vx1 Vx2 @ @ C$min$ = Vy1 Vy2"}, "plain": {"assumptions": [], "goal": "(x1 :num) \u2297 (y1 :num) = (x2 :num) \u2297 (y2 :num) \u21d4 x1 = x2 \u2227 y1 = y2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[numpairTheory.nsnd_def, numpairTheory.nfst_npair, numpairTheory.nfst_def, boolTheory.LET_DEF, numpairTheory.nsnd_npair]", "reward": 5}]], "(s1 :\u03b1 -> bool) \u2286 (s2 :\u03b1 -> bool) \u21d2 REL_RESTRICT (R :\u03b1 -> \u03b1 -> bool) s1 \u2286\u1d63 REL_RESTRICT R s2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vs1 Vs2 @ @ C$relation$ RSUBSET @ @ C$pred_set$ REL_RESTRICT VR Vs1 @ @ C$pred_set$ REL_RESTRICT VR Vs2"}, "plain": {"assumptions": [], "goal": "(s1 :\u03b1 -> bool) \u2286 (s2 :\u03b1 -> bool) \u21d2 REL_RESTRICT (R :\u03b1 -> \u03b1 -> bool) s1 \u2286\u1d63 REL_RESTRICT R s2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs1 @ @ C$bool$ IN Vx Vs2 @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ @ C$pred_set$ REL_RESTRICT VR Vs1 Vx Vy @ @ @ @ C$pred_set$ REL_RESTRICT VR Vs2 Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s1 :\u03b1 -> bool) \u21d2 x \u2208 (s2 :\u03b1 -> bool)) \u21d2 \u2200(x :\u03b1) (y :\u03b1). REL_RESTRICT (R :\u03b1 -> \u03b1 -> bool) s1 x y \u21d2 REL_RESTRICT R s2 x y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IMAGE_SING, relationTheory.RSUBSET, relationTheory.RSUBSET, relationTheory.STRORD, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SURJ_DEF, pred_setTheory.REL_RESTRICT_DEF, relationTheory.TC_CASES2_E, pred_setTheory.EXTENSION, relationTheory.RUNION]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). BIGINTER {P; Q} = P \u2229 Q": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ @ C$min$ = @ C$pred_set$ BIGINTER @ @ C$pred_set$ INSERT VP @ @ C$pred_set$ INSERT VQ C$pred_set$ EMPTY @ @ C$pred_set$ INTER VP VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b1 -> bool). BIGINTER {P; Q} = P \u2229 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ IN Vs @ @ C$pred_set$ INSERT VP @ @ C$pred_set$ INSERT VQ C$pred_set$ EMPTY @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx VP @ @ C$bool$ IN Vx VQ"}, "plain": {"assumptions": [], "goal": "{x | \u2200(s :\u03b1 -> bool). s \u2208 {(P :\u03b1 -> bool); (Q :\u03b1 -> bool)} \u21d2 x \u2208 s} = {x | x \u2208 P \u2227 x \u2208 Q}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.PSUBSET_INSERT_SUBSET, pred_setTheory.BIGINTER, pred_setTheory.IMAGE_DEF, pred_setTheory.UNION_OVER_INTER, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vs VP @ @ C$bool$ \\/ @ @ C$min$ = Vs VQ @ C$pred_set$ EMPTY Vs @ Vs Vx | Vx @ @ C$bool$ /\\ @ VP Vx @ VQ Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). \u2200(s :\u03b1 -> bool). s = (P :\u03b1 -> bool) \u2228 s = (Q :\u03b1 -> bool) \u2228 \u2205 s \u21d2 s x) = (\u03bb(x :\u03b1). P x \u2227 Q x)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.INSERT_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.schroeder_close_def, pred_setTheory.EMPTY_DEF, pred_setTheory.SCHROEDER_CLOSED, pred_setTheory.EXTENSION]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b1) (s :\u03b1 -> bool). (x :\u03b1) \u2208 schroeder_close f s \u21d4 \u2203(n :num). x \u2208 FUNPOW (IMAGE f) n s": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ schroeder_close Vf Vs @ C$bool$ ? | Vn @ @ C$bool$ IN Vx @ @ @ C$arithmetic$ FUNPOW @ C$pred_set$ IMAGE Vf Vn Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b1) (s :\u03b1 -> bool). (x :\u03b1) \u2208 schroeder_close f s \u21d4 \u2203(n :num). x \u2208 FUNPOW (IMAGE f) n s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.SPECIFICATION, pred_setTheory.PSUBSET_UNIV, arithmeticTheory.NRC, pred_setTheory.schroeder_close_def]", "reward": 5}]], "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (TAKE m l) \u21d2 EXISTS P l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vm @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (m :num) (P :\u03b1 -> bool). EXISTS P (TAKE m l) \u21d2 EXISTS P l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE C$num$ 0 Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (0 :num) l) \u21d2 EXISTS P l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (SUC (m :num)) l) \u21d2 EXISTS P l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `m`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (SUC (m :num)) l) \u21d2 EXISTS P l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_APPLY_def, listTheory.LEN_LENGTH_LEM, boolTheory.LEFT_AND_FORALL_THM, listTheory.dropWhile_APPEND_EXISTS, listTheory.MEM_TL]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm C$list$ NIL @ @ C$list$ EXISTS VP C$list$ NIL"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (m :num) l) \u21d2 EXISTS P l"], "goal": "EXISTS (P :\u03b1 -> bool) (TAKE (SUC (m :num)) ([] :\u03b1 list)) \u21d2 EXISTS P ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl", "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["EXISTS (P :\u03b1 -> bool) (TAKE (SUC (m :num)) (l :\u03b1 list)) \u21d2 EXISTS P l", "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(h :\u03b1). EXISTS (P :\u03b1 -> bool) (TAKE (SUC (m :num)) (h::(l :\u03b1 list))) \u21d2 EXISTS P (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm Vl @ @ C$list$ EXISTS VP Vl", "@ C$bool$ ! | Vl @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE Vm Vl @ @ C$list$ EXISTS VP Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$list$ EXISTS VP @ @ C$list$ TAKE @ C$num$ SUC Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ EXISTS VP @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["EXISTS (P :\u03b1 -> bool) (TAKE (SUC (m :num)) (l :\u03b1 list)) \u21d2 EXISTS P l", "\u2200(l :\u03b1 list) (P :\u03b1 -> bool). EXISTS P (TAKE (m :num) l) \u21d2 EXISTS P l"], "goal": "\u2200(h :\u03b1). EXISTS (P :\u03b1 -> bool) (TAKE (SUC (m :num)) (h::(l :\u03b1 list))) \u21d2 EXISTS P (h::l)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_rules, listTheory.LIST_REL_SPLIT2, listTheory.TAKE_def, listTheory.SUM_SUM_ACC, listTheory.MEM]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.ZIP_EQ_NIL, listTheory.TAKE_def, listTheory.SUM_ACC_DEF, listTheory.UNZIP, listTheory.dropWhile_def]", "reward": 5}]], "\u2200(P :(\u03b1 -> bool) -> bool). (BIGUNION P = (\u2205 :\u03b1 -> bool) \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)}) \u2227 ((\u2205 :\u03b1 -> bool) = BIGUNION P \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)})": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ C$pred_set$ BIGUNION VP C$pred_set$ EMPTY @ @ C$bool$ \\/ @ @ C$min$ = VP C$pred_set$ EMPTY @ @ C$min$ = VP @ @ C$pred_set$ INSERT C$pred_set$ EMPTY C$pred_set$ EMPTY @ @ C$min$ = @ @ C$min$ = C$pred_set$ EMPTY @ C$pred_set$ BIGUNION VP @ @ C$bool$ \\/ @ @ C$min$ = VP C$pred_set$ EMPTY @ @ C$min$ = VP @ @ C$pred_set$ INSERT C$pred_set$ EMPTY C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(P :(\u03b1 -> bool) -> bool). (BIGUNION P = (\u2205 :\u03b1 -> bool) \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)}) \u2227 ((\u2205 :\u03b1 -> bool) = BIGUNION P \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)})"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ @ C$min$ = @ @ C$min$ = @ C$pred_set$ BIGUNION VP C$pred_set$ EMPTY @ @ C$bool$ \\/ @ @ C$min$ = VP C$pred_set$ EMPTY @ @ C$min$ = VP @ @ C$pred_set$ INSERT C$pred_set$ EMPTY C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(P :(\u03b1 -> bool) -> bool). BIGUNION P = (\u2205 :\u03b1 -> bool) \u21d4 P = (\u2205 :(\u03b1 -> bool) -> bool) \u2228 P = {(\u2205 :\u03b1 -> bool)}"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.BIJ_ALT, pred_setTheory.SURJ_DEF, pred_setTheory.BIJ_INV, boolTheory.LCOMM_THM, boolTheory.SELECT_REFL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$pred_set$ BIGUNION VP | Vx C$bool$ F @ @ C$bool$ \\/ @ @ C$min$ = VP | Vx C$bool$ F @ @ C$min$ = VP @ @ C$pred_set$ INSERT | Vx C$bool$ F | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "BIGUNION (P :(\u03b1 -> bool) -> bool) = (\u03bb(x :\u03b1). F) \u21d4 P = (\u03bb(x :\u03b1 -> bool). F) \u2228 P = (\u03bb(x :\u03b1). F) INSERT (\u03bb(x :\u03b1 -> bool). F)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.INSERT_applied, pred_setTheory.IN_UNION, pred_setTheory.EMPTY_DEF, boolTheory.IMP_F_EQ_F, boolTheory.CONJ_ASSOC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs VP @ @ C$bool$ IN Vx Vs | Vx C$bool$ F @ @ C$bool$ \\/ @ @ C$min$ = VP | Vx C$bool$ F @ @ C$min$ = VP @ @ C$pred_set$ INSERT | Vx C$bool$ F | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "{x | \u2203(s :\u03b1 -> bool). s \u2208 (P :(\u03b1 -> bool) -> bool) \u2227 x \u2208 s} = (\u03bb(x :\u03b1). F) \u21d4 P = (\u03bb(x :\u03b1 -> bool). F) \u2228 P = (\u03bb(x :\u03b1). F) INSERT (\u03bb(x :\u03b1 -> bool). F)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INSERT, boolTheory.EQ_REFL, pred_setTheory.BIGUNION, pred_setTheory.FUNSET_INTER, pred_setTheory.EMPTY_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = | Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ VP Vs @ Vs Vx | Vx C$bool$ F @ @ C$bool$ \\/ @ @ C$min$ = VP | Vx C$bool$ F @ @ C$min$ = VP | Vy @ @ C$min$ = Vy | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). \u2203(s :\u03b1 -> bool). (P :(\u03b1 -> bool) -> bool) s \u2227 s x) = (\u03bb(x :\u03b1). F) \u21d4 P = (\u03bb(x :\u03b1 -> bool). F) \u2228 P = (\u03bb(y :\u03b1 -> bool). y = (\u03bb(x :\u03b1). F))"}}], "parent": 3, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.SPECIFICATION, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_DEF, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$bool$ \\/ @ C$bool$ ~ @ VP Vs @ C$bool$ ~ @ Vs Vx @ @ C$bool$ \\/ @ C$bool$ ! | Vx @ C$bool$ ~ @ VP Vx @ C$bool$ ! | Vx @ @ C$min$ = @ VP Vx @ C$bool$ ! | Vx' @ C$bool$ ~ @ Vx Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (s :\u03b1 -> bool). \u00ac(P :(\u03b1 -> bool) -> bool) s \u2228 \u00acs x) \u21d4 (\u2200(x :\u03b1 -> bool). \u00acP x) \u2228 \u2200(x :\u03b1 -> bool). P x \u21d4 \u2200(x' :\u03b1). \u00acx x'"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_ABS, pred_setTheory.EXTENSION, pred_setTheory.IN_APP, pred_setTheory.INFINITE_INJ, pred_setTheory.SURJ_EMPTY]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, boolTheory.bool_INDUCT, pred_setTheory.IMAGE_applied, pred_setTheory.NOT_EQUAL_SETS, boolTheory.OR_IMP_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f (COMPL s) = COMPL (PREIMAGE f s)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ C$pred_set$ COMPL Vs @ C$pred_set$ COMPL @ @ C$pred_set$ PREIMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b2 -> bool). PREIMAGE f (COMPL s) = COMPL (PREIMAGE f s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ Vf Vx @ C$pred_set$ COMPL Vs @ C$pred_set$ COMPL @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ Vf Vx Vs"}, "plain": {"assumptions": [], "goal": "{x | (f :\u03b1 -> \u03b2) x \u2208 COMPL (s :\u03b2 -> bool)} = COMPL {x | f x \u2208 s}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.SCHROEDER_BERNSTEIN_AUTO, pred_setTheory.DELETE_NON_ELEMENT_RWT, pred_setTheory.PREIMAGE_def, pred_setTheory.GSPEC_AND]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.IN_COMPL, pred_setTheory.GSPEC_ETA, pred_setTheory.EXTENSION, pred_setTheory.BIGINTER]", "reward": 5}]], "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2": [24, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). l1 \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn @ C$list$ LENGTH Vl2", "@ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn @ C$list$ LENGTH Vl1", "@ @ C$list$ isPREFIX Vl1 Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["(\u03bb(x :num) (y :num). y = SUC x)\u207a (n :num) (LENGTH (l2 :\u03b1 list))", "(\u03bb(x :num) (y :num). y = SUC x)\u207a (n :num) (LENGTH (l1 :\u03b1 list))", "(l1 :\u03b1 list) \u227c (l2 :\u03b1 list)"], "goal": "EL (n :num) (l1 :\u03b1 list) = EL n (l2 :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[prim_recTheory.LESS_ALT, listTheory.FLAT_APPEND, listTheory.MEM_SPLIT, listTheory.MEM_REVERSE, prim_recTheory.PRIM_REC_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l2 :\u03b1 list). ([] :\u03b1 list) \u227c l2 \u2227 n < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH l2 \u21d2 EL n ([] :\u03b1 list) = EL n l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). h::(l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH (h::l1) \u2227 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). h::(l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH (h::l1) \u2227 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_11, listTheory.EL_SNOC, listTheory.ALL_DISTINCT_ZIP, listTheory.EL_compute, listTheory.EL_ZIP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). h::(l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH (h::l1) \u2227 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list). ([] :\u03b1 list) \u227c l2 \u2227 (n :num) < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH l2 \u21d2 EL n ([] :\u03b1 list) = EL n l2"}}], "parent": 2, "goal": 0, "by_tactic": "strip_tac", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h :\u03b1) (n :num) (l2 :\u03b1 list). h::(l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH (h::l1) \u2227 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL C$list$ NIL @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). ([] :\u03b1 list) \u227c ([] :\u03b1 list) \u2227 n < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH ([] :\u03b1 list) \u21d2 EL n ([] :\u03b1 list) = EL n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(n :num). ([] :\u03b1 list) \u227c (l2 :\u03b1 list) \u2227 n < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH l2 \u21d2 EL n ([] :\u03b1 list) = EL n l2"], "goal": "\u2200(h :\u03b1) (n :num). ([] :\u03b1 list) \u227c h::(l2 :\u03b1 list) \u2227 n < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH (h::l2) \u21d2 EL n ([] :\u03b1 list) = EL n (h::l2)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l2`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list). ([] :\u03b1 list) \u227c l2 \u2227 (n :num) < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH l2 \u21d2 EL n ([] :\u03b1 list) = EL n l2"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH (l2 :\u03b1 list)", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "EL (n :num) ((h :\u03b1)::(l1 :\u03b1 list)) = EL n (l2 :\u03b1 list)"}}], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_EQ_SUM, listTheory.MEM_ZIP, boolTheory.literal_case_RAND, listTheory.DROP_TAKE, listTheory.LAST_compute]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH (l2 :\u03b1 list)", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "EL (n :num) ((h :\u03b1)::(l1 :\u03b1 list)) = EL n (l2 :\u03b1 list)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_BIND_MAP, listTheory.MEM, listTheory.EXISTS_SNOC, listTheory.SUM_ACC_DEF, listTheory.REVERSE_SNOC_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX C$list$ NIL Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn C$list$ NIL @ @ C$list$ EL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list). ([] :\u03b1 list) \u227c l2 \u2227 (n :num) < LENGTH ([] :\u03b1 list) \u2227 n < LENGTH l2 \u21d2 EL n ([] :\u03b1 list) = EL n l2"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn C$list$ NIL"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "(h :\u03b1)::(l1 :\u03b1 list) \u227c ([] :\u03b1 list) \u21d2 (n :num) < LENGTH ([] :\u03b1 list) \u21d2 EL n (h::l1) = EL n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list) \u21d2 (n :num) < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h' :\u03b1). (h :\u03b1)::(l1 :\u03b1 list) \u227c h'::(l2 :\u03b1 list) \u21d2 (n :num) < LENGTH (h'::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)"}}], "parent": 4, "goal": 0, "by_tactic": "Induct_on `l2`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn C$list$ NIL"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "(h :\u03b1)::(l1 :\u03b1 list) \u227c ([] :\u03b1 list) \u21d2 (n :num) < LENGTH ([] :\u03b1 list) \u21d2 EL n (h::l1) = EL n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list) \u21d2 (n :num) < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h' :\u03b1). (h :\u03b1)::(l1 :\u03b1 list) \u227c h'::(l2 :\u03b1 list) \u21d2 (n :num) < LENGTH (h'::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)"}}], "parent": 8, "goal": 0, "by_tactic": "fs[listTheory.list_case_def, listTheory.list_case_def, listTheory.UNIQUE_LENGTH_FILTER, listTheory.LENGTH_NIL_SYM, boolTheory.LEFT_FORALL_OR_THM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list) \u21d2 (n :num) < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "\u2200(h' :\u03b1). (h :\u03b1)::(l1 :\u03b1 list) \u227c h'::(l2 :\u03b1 list) \u21d2 (n :num) < LENGTH (h'::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 C$list$ NIL", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn C$list$ NIL"}, "plain": {"assumptions": ["(n :num) < LENGTH ([] :\u03b1 list)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c ([] :\u03b1 list)", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "EL (n :num) ((h :\u03b1)::(l1 :\u03b1 list)) = EL n ([] :\u03b1 list)"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_SING, boolTheory.OR_CONG, listTheory.LIST_TO_SET_FLAT, listTheory.EVERY2_EVERY, boolTheory.T_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH C$list$ NIL", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 C$list$ NIL", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn C$list$ NIL"}, "plain": {"assumptions": ["(n :num) < LENGTH ([] :\u03b1 list)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c ([] :\u03b1 list)", "(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "EL (n :num) ((h :\u03b1)::(l1 :\u03b1 list)) = EL n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL C$num$ 0 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "(0 :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 (0 :num) < LENGTH l2 \u21d2 EL (0 :num) (h::l1) = EL (0 :num) l2) \u21d2 (0 :num) < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (0 :num) (h::l1) = EL (0 :num) (h'::l2)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2) \u21d2 n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 SUC n < LENGTH l2 \u21d2 EL (SUC n) (h::l1) = EL (SUC n) l2) \u21d2 SUC n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (SUC n) (h::l1) = EL (SUC n) (h'::l2)"}}], "parent": 10, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL C$num$ 0 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "(0 :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 (0 :num) < LENGTH l2 \u21d2 EL (0 :num) (h::l1) = EL (0 :num) l2) \u21d2 (0 :num) < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (0 :num) (h::l1) = EL (0 :num) (h'::l2)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2) \u21d2 n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 SUC n < LENGTH l2 \u21d2 EL (SUC n) (h::l1) = EL (SUC n) l2) \u21d2 SUC n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (SUC n) (h::l1) = EL (SUC n) (h'::l2)"}}], "parent": 11, "goal": 0, "by_tactic": "fs[boolTheory.UNWIND_FORALL_THM2, listTheory.ALL_DISTINCT_FLAT_REVERSE, listTheory.SET_TO_LIST_primitive_def, listTheory.list_distinct, listTheory.BIGUNION_IMAGE_set_SUBSET]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2) \u21d2 n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 SUC n < LENGTH l2 \u21d2 EL (SUC n) (h::l1) = EL (SUC n) l2) \u21d2 SUC n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (SUC n) (h::l1) = EL (SUC n) (h'::l2)"}}], "parent": 12, "goal": 0, "by_tactic": "fs[listTheory.dropWhile_eq_nil, listTheory.SNOC, listTheory.LENGTH_EQ_NIL, listTheory.list_to_set_diff, listTheory.oHD_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL Vn @ @ C$list$ CONS Vh' Vl2", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ ==> @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2 @ @ C$min$ = @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL @ C$num$ SUC Vn @ @ C$list$ CONS Vh' Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 n < LENGTH l2 \u21d2 EL n (h::l1) = EL n l2) \u21d2 n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL n (h::l1) = EL n (h'::l2)", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "SUC (n :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list)) \u21d2 (h::l1 \u227c (l2 :\u03b1 list) \u21d2 SUC n < LENGTH l2 \u21d2 EL (SUC n) (h::l1) = EL (SUC n) l2) \u21d2 SUC n < LENGTH ((h' :\u03b1)::l2) \u21d2 EL (SUC n) (h::l1) = EL (SUC n) (h'::l2)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh' Vl2", "@ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL C$num$ 0 @ @ C$list$ CONS Vh Vl1 @ @ C$list$ EL C$num$ 0 Vl2", "@ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1", "@ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Vh' Vl2", "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$list$ isPREFIX Vl1 Vl2 @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ @ C$min$ = @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2"], "goal": "@ @ C$min$ = Vh Vh'"}, "plain": {"assumptions": ["(0 :num) < LENGTH ((h' :\u03b1)::(l2 :\u03b1 list))", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (l2 :\u03b1 list) \u21d2 (0 :num) < LENGTH l2 \u21d2 EL (0 :num) (h::l1) = EL (0 :num) l2", "(0 :num) < LENGTH ((h :\u03b1)::(l1 :\u03b1 list))", "(h :\u03b1)::(l1 :\u03b1 list) \u227c (h' :\u03b1)::(l2 :\u03b1 list)", "\u2200(n :num) (l2 :\u03b1 list). (l1 :\u03b1 list) \u227c l2 \u2227 n < LENGTH l1 \u2227 n < LENGTH l2 \u21d2 EL n l1 = EL n l2"], "goal": "(h :\u03b1) = (h' :\u03b1)"}}], "parent": 12, "goal": 0, "by_tactic": "rw[listTheory.GENLIST_FUN_EQ, listTheory.GENLIST_CONG, listTheory.FRONT_DEF, listTheory.DROP_GENLIST, listTheory.GENLIST_AUX]", "reward": 0.1}, {"content": [], "parent": 13, "goal": 0, "by_tactic": "fs[listTheory.EVERY_EL, listTheory.INDEX_OF_def, listTheory.LIST_REL_NIL, listTheory.FRONT_DEF, listTheory.LENGTH_FRONT_CONS]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b2 -> bool) (R' :\u03b3 -> \u03b1 -> bool). (R \u2218\u1d63 R')\u1d40 = R'\u1d40 \u2218\u1d63 R\u1d40": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | VR' @ @ C$min$ = @ C$relation$ inv @ @ C$relation$ O VR VR' @ @ C$relation$ O @ C$relation$ inv VR' @ C$relation$ inv VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b2 -> bool) (R' :\u03b3 -> \u03b1 -> bool). (R \u2218\u1d63 R')\u1d40 = R'\u1d40 \u2218\u1d63 R\u1d40"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$relation$ inv @ @ C$relation$ O VR VR' Vx Vx' @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ @ C$relation$ inv VR Vx Vy @ @ @ C$relation$ inv VR' Vy Vx'"}, "plain": {"assumptions": [], "goal": "((R :\u03b1 -> \u03b2 -> bool) \u2218\u1d63 (R' :\u03b3 -> \u03b1 -> bool))\u1d40 (x :\u03b2) (x' :\u03b3) \u21d4 \u2203(y :\u03b1). R\u1d40 x y \u2227 R'\u1d40 y x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.O_DEF, boolTheory.FUN_EQ_THM, relationTheory.TC_implies_one_step, boolTheory.NOT_IMP]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.IDEM, relationTheory.inv_DEF, boolTheory.DISJ_COMM, relationTheory.O_DEF, boolTheory.RIGHT_OR_OVER_AND]", "reward": 5}]], "PROD_SET (\u2205 :num -> bool) = (1 :num) \u2227 \u2200(x :num) (s :num -> bool). FINITE s \u21d2 PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$pred_set$ PROD_SET C$pred_set$ EMPTY @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$bool$ ! | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ @ C$min$ = @ C$pred_set$ PROD_SET @ @ C$pred_set$ INSERT Vx Vs @ @ C$arithmetic$ * Vx @ C$pred_set$ PROD_SET @ @ C$pred_set$ DELETE Vs Vx"}, "plain": {"assumptions": [], "goal": "PROD_SET (\u2205 :num -> bool) = (1 :num) \u2227 \u2200(x :num) (s :num -> bool). FINITE s \u21d2 PROD_SET (x INSERT s) = x * PROD_SET (s DELETE x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_applied, pred_setTheory.SURJ_DEF, pred_setTheory.PROD_SET_DEF, arithmeticTheory.transitive_measure, pred_setTheory.PROD_IMAGE_THM]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 \u227c l1 \u21d4 \u2203(l :\u03b1 list). l1 = l2 ++ l": [7, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 \u227c l1 \u21d4 \u2203(l :\u03b1 list). l1 = l2 ++ l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": [], "goal": "(l2 :\u03b1 list) \u227c (l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_EQ_EMPTY, listTheory.TAKE_SUM, listTheory.CONS_ACYCLIC, listTheory.TL_GENLIST, listTheory.DROP_LENGTH_TOO_LONG]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 C$list$ NIL @ C$bool$ ? | Vl @ @ C$min$ = C$list$ NIL @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list). l2 \u227c ([] :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). ([] :\u03b1 list) = l2 \u29fa l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 @ @ C$list$ CONS Vh Vl1 @ C$bool$ ? | Vl @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). l2 \u227c (l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list). l2 \u227c h::(l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). h::l1 = l2 \u29fa l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 @ @ C$list$ CONS Vh Vl1 @ C$bool$ ? | Vl @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). l2 \u227c (l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list). l2 \u227c h::(l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). h::l1 = l2 \u29fa l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_MAP_inv_image, listTheory.APPEND, listTheory.GENLIST_PLUS_APPEND, listTheory.DROP_nil, listTheory.LIST_REL_EL_EQN]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"], "goal": "@ @ C$min$ = @ @ C$list$ isPREFIX Vl2 @ @ C$list$ CONS Vh Vl1 @ C$bool$ ? | Vl @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). l2 \u227c (l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"], "goal": "(l2 :\u03b1 list) \u227c (h :\u03b1)::(l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). h::l1 = l2 \u29fa l"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.EL_REVERSE, listTheory.dropWhile_APPEND_EXISTS, listTheory.SUM_ACC_DEF, listTheory.FLAT_EQ_NIL, listTheory.isPREFIX_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ isPREFIX Vl2 Vl1 @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vl2 C$list$ NIL @ C$bool$ ? | Vxs @ @ C$bool$ /\\ @ @ C$min$ = Vl2 @ @ C$list$ CONS Vh Vxs @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vxs Vl @ C$bool$ ? | Vl @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl2 C$list$ NIL @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl1 @ C$bool$ ? | Vlt @ @ C$bool$ /\\ @ @ C$min$ = Vl2 @ @ C$list$ CONS Vh Vlt @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vlt Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list). l2 \u227c (l1 :\u03b1 list) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"], "goal": "(l2 :\u03b1 list) = ([] :\u03b1 list) \u2228 (\u2203(xs :\u03b1 list). l2 = (h :\u03b1)::xs \u2227 \u2203(l :\u03b1 list). (l1 :\u03b1 list) = xs \u29fa l) \u21d4 \u2203(l :\u03b1 list). l2 = ([] :\u03b1 list) \u2227 l = h::l1 \u2228 \u2203(lt :\u03b1 list). l2 = h::lt \u2227 l1 = lt \u29fa l"}}], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.EL_REVERSE, listTheory.isPREFIX_CONSR, listTheory.EL_ALL_DISTINCT_EL_EQ, listTheory.ALL_DISTINCT_FILTER, listTheory.APPEND_EQ_CONS]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.LIST_TO_SET_EQ_EMPTY, listTheory.LIST_REL_MAP_inv_image, listTheory.SING_HD, listTheory.REVERSE_DEF, listTheory.UNZIP]", "reward": 5}]], "\u2200(l :\u03b1 list). LASTN (LENGTH l) l = l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH Vl Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). LASTN (LENGTH l) l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH C$list$ NIL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LASTN (LENGTH ([] :\u03b1 list)) ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH Vl Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LASTN (LENGTH (l :\u03b1 list)) l = l"], "goal": "\u2200(h :\u03b1). LASTN (LENGTH (h::(l :\u03b1 list))) (h::l) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH Vl Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LASTN (LENGTH (l :\u03b1 list)) l = l"], "goal": "\u2200(h :\u03b1). LASTN (LENGTH (h::(l :\u03b1 list))) (h::l) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST, listTheory.TAKE_SUM, listTheory.LIST_TO_SET_GENLIST, rich_listTheory.LASTN, listTheory.list_CASES]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ LASTN @ C$list$ LENGTH Vl Vl Vl"], "goal": "@ @ C$min$ = @ @ C$rich_list$ LASTN @ C$num$ SUC @ C$list$ LENGTH Vl @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LASTN (LENGTH (l :\u03b1 list)) l = l"], "goal": "LASTN (SUC (LENGTH (l :\u03b1 list))) ((h :\u03b1)::l) = h::l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LEN_LENGTH_LEM, listTheory.SET_TO_LIST_IN_MEM, listTheory.splitAtPki_MAP, rich_listTheory.SPLITP_splitAtPki, listTheory.isPREFIX_NILR]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.APPEND_EQ_SING, listTheory.SWAP_REVERSE_SYM, rich_listTheory.FLAT_SNOC, rich_listTheory.LASTN_def, rich_listTheory.UNZIP_FST_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). equivalence R \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 R x = R y": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ equivalence VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ VR Vx Vy @ @ C$min$ = @ VR Vx @ VR Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). equivalence R \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 R x = R y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ VR Vx Vx @ @ C$bool$ /\\ @ C$relation$ symmetric VR @ C$relation$ transitive VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ VR Vx Vy @ @ C$min$ = @ VR Vx @ VR Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x x) \u2227 symmetric R \u2227 transitive R \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 R x = R y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.irreflexive_def, boolTheory.REFL_CLAUSE, boolTheory.EXISTS_SIMP, relationTheory.equivalence_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ VR Vx Vx @ @ C$bool$ /\\ @ C$relation$ symmetric VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ VR Vx Vy @ C$bool$ ! | Vx' @ @ C$min$ = @ @ VR Vx Vx' @ @ VR Vy Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x x) \u2227 symmetric R \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z) \u21d4 \u2200(x :\u03b1) (y :\u03b1). R x y \u21d4 \u2200(x' :\u03b1). R x x' \u21d4 R y x'"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.COND_RATOR, relationTheory.irreflexive_def, relationTheory.TC_implies_one_step, relationTheory.transitive_def, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.FUN_EQ_THM, relationTheory.TC_DEF, boolTheory.NOT_IMP, relationTheory.reflexive_TC, relationTheory.symmetric_def]", "reward": 5}]], "\u2200(M :\u03b1 list) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). M = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE VM Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"}, "plain": {"assumptions": [], "goal": "\u2200(M :\u03b1 list) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). M = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE C$list$ NIL Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"}, "plain": {"assumptions": [], "goal": "\u2200(M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). ([] :\u03b1 list) = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE ([] :\u03b1 list) v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE VM Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh VM VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh VM Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"}, "plain": {"assumptions": ["\u2200(M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). (M :\u03b1 list) = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"], "goal": "\u2200(h :\u03b1) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). h::(M :\u03b1 list) = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE (h::M) v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `M`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE VM Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VM' @ C$bool$ ! | Vv @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh VM VM' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = VM' C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ @ C$min$ ==> @ @ C$min$ = VM' @ @ C$list$ CONS Va0 Va1 @ @ C$min$ = @ @ Vf Va0 Va1 @ @ Vf' Va0 Va1 @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh VM Vv Vf @ @ @ C$list$ list_CASE VM' Vv' Vf'"}, "plain": {"assumptions": ["\u2200(M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). (M :\u03b1 list) = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE M v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"], "goal": "\u2200(h :\u03b1) (M' :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2). h::(M :\u03b1 list) = M' \u2227 (M' = ([] :\u03b1 list) \u21d2 v = (v' :\u03b2)) \u2227 (\u2200(a0 :\u03b1) (a1 :\u03b1 list). M' = a0::a1 \u21d2 f a0 a1 = (f' :\u03b1 -> \u03b1 list -> \u03b2) a0 a1) \u21d2 (list_CASE (h::M) v f :\u03b2) = (list_CASE M' v' f' :\u03b2)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.list_case_def, boolTheory.AND_CLAUSES, boolTheory.TYPE_DEFINITION_THM, listTheory.list_case_def, boolTheory.LEFT_OR_CONG]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.list_case_def, boolTheory.OR_CLAUSES, boolTheory.EQ_EXT, listTheory.list_case_def, listTheory.list_case_def]", "reward": 5}]], "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). (R1 \u2229\u1d63 R2)\ua673 x y \u21d2 (R1\ua673 \u2229\u1d63 R2\ua673) x y": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR1 @ C$bool$ ! | VR2 @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC @ @ C$relation$ RINTER VR1 VR2 Vx Vy @ @ @ @ C$relation$ RINTER @ C$relation$ RTC VR1 @ C$relation$ RTC VR2 Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). (R1 \u2229\u1d63 R2)\ua673 x y \u21d2 (R1\ua673 \u2229\u1d63 R2\ua673) x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ? | VQ @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ VQ Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vy @ C$bool$ ~ @ @ @ @ C$relation$ RINTER VR1 VR2 Vy Vz @ VQ Vz @ C$bool$ ~ @ VQ Vy @ @ @ @ C$relation$ RINTER @ C$relation$ RTC VR1 @ C$relation$ RTC VR2 Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2203(Q :\u03b1 -> bool). (Q (x :\u03b1) \u2227 \u2200(y :\u03b1) (z :\u03b1). (\u00acQ y \u2228 \u00ac((R1 :\u03b1 -> \u03b1 -> bool) \u2229\u1d63 (R2 :\u03b1 -> \u03b1 -> bool)) y z) \u2228 Q z) \u2227 \u00acQ (y :\u03b1)) \u2228 (R1\ua673 \u2229\u1d63 R2\ua673) x y"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.SC_SYMMETRIC, relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.inv_inv, boolTheory.IMP_DISJ_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ? | VQ @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ VQ Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ C$bool$ ~ @ VQ Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ VR1 Vy Vz @ C$bool$ ~ @ @ VR2 Vy Vz @ VQ Vz @ C$bool$ ~ @ VQ Vy @ @ C$bool$ /\\ @ C$bool$ ! | VQ @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vy @ @ VR1 Vy Vz @ VQ Vz @ VQ Vy @ C$bool$ ! | VQ @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vy @ @ VR2 Vy Vz @ VQ Vz @ VQ Vy"}, "plain": {"assumptions": [], "goal": "(\u2203(Q :\u03b1 -> bool). (Q (x :\u03b1) \u2227 \u2200(y :\u03b1) (z :\u03b1). (\u00acQ y \u2228 \u00ac(R1 :\u03b1 -> \u03b1 -> bool) y z \u2228 \u00ac(R2 :\u03b1 -> \u03b1 -> bool) y z) \u2228 Q z) \u2227 \u00acQ (y :\u03b1)) \u2228 (\u2200(Q :\u03b1 -> bool). Q x \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R1 y z \u21d2 Q z) \u21d2 Q y) \u2227 \u2200(Q :\u03b1 -> bool). Q x \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R2 y z \u21d2 Q z) \u21d2 Q y"}}], "parent": 1, "goal": 0, "by_tactic": "fs[relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.reflexive_TC, boolTheory.LET_DEF, boolTheory.itself_case_thm, relationTheory.RINTER]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.BOOL_FUN_INDUCT, boolTheory.BOOL_EQ_DISTINCT, boolTheory.DE_MORGAN_THM, boolTheory.LEFT_OR_OVER_AND, relationTheory.WF_SUBSET]", "reward": 5}]], "(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,COUNT_LIST n) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , Vl1 @ C$rich_list$ COUNT_LIST Vn @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn Vl1 Vn @ C$list$ LENGTH Vl1"}, "plain": {"assumptions": [], "goal": "(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,COUNT_LIST n) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn Vl1 Vn @ C$list$ LENGTH Vl1"}, "plain": {"assumptions": [], "goal": "(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,GENLIST (I :num -> num) (LENGTH l1)) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[rich_listTheory.TAKE_REVERSE, rich_listTheory.COUNT_LIST_GENLIST, listTheory.MAP_DROP, listTheory.GENLIST, rich_listTheory.LASTN_CONS]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH C$list$ NIL @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn C$list$ NIL Vn @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(n :num) = LENGTH ([] :\u03b1 list) \u21d2 ZIP (([] :\u03b1 list),GENLIST (I :num -> num) (LENGTH ([] :\u03b1 list))) = GENLIST (\u03bb(n :num). (EL n ([] :\u03b1 list),n)) (LENGTH ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn Vl1 Vn @ C$list$ LENGTH Vl1"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1"}, "plain": {"assumptions": ["(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,GENLIST (I :num -> num) (LENGTH l1)) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)"], "goal": "\u2200(h :\u03b1). (n :num) = LENGTH (h::(l1 :\u03b1 list)) \u21d2 ZIP (h::l1,GENLIST (I :num -> num) (LENGTH (h::l1))) = GENLIST (\u03bb(n :num). (EL n (h::l1),n)) (LENGTH (h::l1))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn Vl1 Vn @ C$list$ LENGTH Vl1"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$min$ = Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1"}, "plain": {"assumptions": ["(n :num) = LENGTH (l1 :\u03b1 list) \u21d2 ZIP (l1,GENLIST (I :num -> num) (LENGTH l1)) = GENLIST (\u03bb(n :num). (EL n l1,n)) (LENGTH l1)"], "goal": "\u2200(h :\u03b1). (n :num) = LENGTH (h::(l1 :\u03b1 list)) \u21d2 ZIP (h::l1,GENLIST (I :num -> num) (LENGTH (h::l1))) = GENLIST (\u03bb(n :num). (EL n (h::l1),n)) (LENGTH (h::l1))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP_DROP, rich_listTheory.BUTLASTN_SUC_FRONT, rich_listTheory.SNOC_REVERSE_CONS, rich_listTheory.UNZIP_SNOC, listTheory.FRONT_DEF]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = Vn @ C$num$ SUC @ C$list$ LENGTH Vl1", "C$bool$ T"], "goal": "@ @ C$min$ = @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vl1 @ @ C$list$ GENLIST C$combin$ I @ C$num$ SUC @ C$list$ LENGTH Vl1 @ @ C$list$ GENLIST | Vn @ @ C$pair$ , @ @ C$list$ EL Vn @ @ C$list$ CONS Vh Vl1 Vn @ C$num$ SUC @ C$list$ LENGTH Vl1"}, "plain": {"assumptions": ["(n :num) = SUC (LENGTH (l1 :\u03b1 list))", "T"], "goal": "ZIP ((h :\u03b1)::(l1 :\u03b1 list),GENLIST (I :num -> num) (SUC (LENGTH l1))) = GENLIST (\u03bb(n :num). (EL n (h::l1),n)) (SUC (LENGTH l1))"}}], "parent": 3, "goal": 0, "by_tactic": "fs[rich_listTheory.ELL_REVERSE, listTheory.UNZIP, rich_listTheory.TL_T_def, rich_listTheory.COUNT_LIST_def, listTheory.LIST_BIND_THM]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_EVERY_ZIP, listTheory.ZIP_GENLIST, listTheory.GENLIST, listTheory.HD_GENLIST, rich_listTheory.COUNT_LIST_AUX_def]", "reward": 5}]], "RC ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ RC C$pred_set$ PSUBSET C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "RC ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET @ C$relation$ RC C$pred_set$ PSUBSET C$pred_set$ SUBSET @ @ C$relation$ RSUBSET C$pred_set$ SUBSET @ C$relation$ RC C$pred_set$ PSUBSET"}, "plain": {"assumptions": [], "goal": "RC ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2227 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 RC ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.TC_CASES1, pred_setTheory.EMPTY_DEF, relationTheory.inv_TC, pred_setTheory.EXTENSION, relationTheory.EqIsBothRSUBSET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$pred_set$ PSUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$pred_set$ PSUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x = y \u2228 x \u2282 y \u21d2 x \u2286 y) \u2227 \u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u2286 y \u21d2 x = y \u2228 x \u2282 y"}}], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.INVOL, pred_setTheory.IN_APP, relationTheory.RSUBSET, relationTheory.RSUBSET, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vx Vy @ @ C$pred_set$ SUBSET Vy Vx @ @ C$bool$ /\\ @ @ C$pred_set$ SUBSET Vx Vy @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$pred_set$ SUBSET Vx Vy @ C$bool$ ~ @ @ C$pred_set$ SUBSET Vy Vx @ @ C$pred_set$ SUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u2286 y \u2227 y \u2286 x \u2228 x \u2286 y \u2227 (\u00ac(x \u2286 y) \u2228 \u00ac(y \u2286 x)) \u21d2 x \u2286 y"}}], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.SET_EQ_SUBSET, relationTheory.IN_RDOM, pred_setTheory.GSPECIFICATION, relationTheory.RUNION, pred_setTheory.PSUBSET_DEF]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.EXTENSION, relationTheory.transitive_def, pred_setTheory.EXTENSION, relationTheory.diag_def]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n \u2212 LENGTH l1) l2": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl1 Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (n :num). LENGTH l1 \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 ++ l2) = l1 ++ TAKE (n \u2212 LENGTH l1) l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH C$list$ NIL Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH C$list$ NIL Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). LENGTH ([] :\u03b1 list) \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (([] :\u03b1 list) \u29fa l2) = ([] :\u03b1 list) \u29fa TAKE (n \u2212 LENGTH ([] :\u03b1 list)) l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl1 Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l1 :\u03b1 list) \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 \u29fa l2) = l1 \u29fa TAKE (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l1 :\u03b1 list)) \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (h::l1 \u29fa l2) = h::l1 \u29fa TAKE (n \u2212 LENGTH (h::l1)) l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl1 Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vn @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l1 :\u03b1 list) \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (l1 \u29fa l2) = l1 \u29fa TAKE (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l1 :\u03b1 list)) \u2264 n \u21d2 \u2200(l2 :\u03b1 list). TAKE n (h::l1 \u29fa l2) = h::l1 \u29fa TAKE (n \u2212 LENGTH (h::l1)) l2"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.list_CASES, listTheory.APPEND_SNOC, arithmeticTheory.MIN_MAX_LE, arithmeticTheory.MOD_MOD, arithmeticTheory.LESS_DIV_EQ_ZERO]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.LESS_EQ, listTheory.UNZIP_THM, listTheory.LENGTH_MAP2, arithmeticTheory.ADD1, listTheory.FRONT_DEF]", "reward": 5}]], "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 (FILTER P2 l) \u21d4 EVERY (\u03bb(x :\u03b1). P2 x \u21d2 P1 x) l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP1 @ C$bool$ ! | VP2 @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY VP1 @ @ C$list$ FILTER VP2 Vl @ @ C$list$ EVERY | Vx @ @ C$min$ ==> @ VP2 Vx @ VP1 Vx Vl"}, "plain": {"assumptions": [], "goal": "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). EVERY P1 (FILTER P2 l) \u21d4 EVERY (\u03bb(x :\u03b1). P2 x \u21d2 P1 x) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP1 @ C$bool$ ! | VP2 @ C$bool$ ! | Vl @ @ C$min$ = @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ FILTER VP2 Vl @ VP1 Ve @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$min$ ==> @ VP2 Vx @ VP1 Vx"}, "plain": {"assumptions": [], "goal": "\u2200(P1 :\u03b1 -> bool) (P2 :\u03b1 -> bool) (l :\u03b1 list). (\u2200(e :\u03b1). MEM e (FILTER P2 l) \u21d2 P1 e) \u21d4 \u2200(x :\u03b1). MEM x l \u21d2 P2 x \u21d2 P1 x"}}], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.NULL_APPEND, boolTheory.ITSELF_UNIQUE, listTheory.EVERY_MEM, listTheory.EL_MAP, listTheory.FILTER_F]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.EQ_SYM_EQ, listTheory.EXISTS_MEM, listTheory.MEM_FILTER, listTheory.FILTER_NEQ_ID, boolTheory.itself_case_thm]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). (IMAGE f s = (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)) \u2227 ((\u2205 :\u03b2 -> bool) = IMAGE f s \u21d4 s = (\u2205 :\u03b1 -> bool))": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY @ @ C$min$ = @ @ C$min$ = C$pred_set$ EMPTY @ @ C$pred_set$ IMAGE Vf Vs @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). (IMAGE f s = (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)) \u2227 ((\u2205 :\u03b2 -> bool) = IMAGE f s \u21d4 s = (\u2205 :\u03b1 -> bool))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (f :\u03b1 -> \u03b2). ((\u2200(x :\u03b2). x \u2208 IMAGE f s \u21d4 x \u2208 (\u2205 :\u03b2 -> bool)) \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 (\u2205 :\u03b1 -> bool)) \u2227 ((\u2200(x :\u03b2). x \u2208 (\u2205 :\u03b2 -> bool) \u21d4 x \u2208 IMAGE f s) \u21d4 \u2200(x :\u03b1). x \u2208 s \u21d4 x \u2208 (\u2205 :\u03b1 -> bool))"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.EXTENSION, pred_setTheory.IN_INTER, pred_setTheory.IN_UNION, pred_setTheory.EXTENSION, pred_setTheory.NOT_EQUAL_SETS]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.SPECIFICATION, pred_setTheory.EMPTY_DEF, pred_setTheory.CHOICE_SING, pred_setTheory.EXTENSION, pred_setTheory.IN_IMAGE]", "reward": 5}]], "numeral$iiSUC ZERO = BIT2 ZERO \u2227 numeral$iiSUC (BIT1 (n :num)) = BIT1 (SUC n) \u2227 numeral$iiSUC (BIT2 n) = BIT2 (SUC n)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$numeral$ iiSUC C$arithmetic$ ZERO @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ @ C$bool$ /\\ @ @ C$min$ = @ C$numeral$ iiSUC @ C$arithmetic$ BIT1 Vn @ C$arithmetic$ BIT1 @ C$num$ SUC Vn @ @ C$min$ = @ C$numeral$ iiSUC @ C$arithmetic$ BIT2 Vn @ C$arithmetic$ BIT2 @ C$num$ SUC Vn"}, "plain": {"assumptions": [], "goal": "numeral$iiSUC ZERO = BIT2 ZERO \u2227 numeral$iiSUC (BIT1 (n :num)) = BIT1 (SUC n) \u2227 numeral$iiSUC (BIT2 n) = BIT2 (SUC n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "fs[arithmeticTheory.MODEQ_MULT_CONG, arithmeticTheory.SUC_ADD_SYM, numeralTheory.iiSUC, numeralTheory.numeral_suc, arithmeticTheory.MIN_DEF]", "reward": 5}]], "reflexive ((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) \u21d4 reflexive R1 \u2228 reflexive R2": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ reflexive @ @ C$pair$ LEX VR1 VR2 @ @ C$bool$ \\/ @ C$relation$ reflexive VR1 @ C$relation$ reflexive VR2"}, "plain": {"assumptions": [], "goal": "reflexive ((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) \u21d4 reflexive R1 \u2228 reflexive R2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ @ @ C$pair$ LEX VR1 VR2 Vx Vx @ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ VR1 Vx Vx @ C$bool$ ! | Vx @ @ VR2 Vx Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 # \u03b2). ((R1 :\u03b1 -> \u03b1 -> bool) LEX (R2 :\u03b2 -> \u03b2 -> bool)) x x) \u21d4 (\u2200(x :\u03b1). R1 x x) \u2228 \u2200(x :\u03b2). R2 x x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[relationTheory.reflexive_def, relationTheory.EqIsBothRSUBSET, pairTheory.UNCURRY_ONE_ONE_THM, relationTheory.RC_DEF, pairTheory.RPROD_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.inv_DEF, pairTheory.PAIR, relationTheory.reflexive_def, relationTheory.IN_RDOM_RUNION, pairTheory.LEX_DEF_THM]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). StrongOrder R \u21d2 STRORD (RC R) = R": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ StrongOrder VR @ @ C$min$ = @ C$relation$ STRORD @ C$relation$ RC VR VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). StrongOrder R \u21d2 STRORD (RC R) = R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$relation$ transitive VR", "@ C$relation$ irreflexive VR"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ @ C$relation$ RC VR Vx Vx' @ C$bool$ ~ @ @ C$min$ = Vx Vx' @ @ VR Vx Vx'"}, "plain": {"assumptions": ["transitive (R :\u03b1 -> \u03b1 -> bool)", "(irreflexive (R :\u03b1 -> \u03b1 -> bool) :bool)"], "goal": "RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (x' :\u03b1) \u2227 x \u2260 x' \u21d4 R x x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_REFL, relationTheory.STRORD, boolTheory.FUN_EQ_THM, relationTheory.EQC_REFL, relationTheory.StrongOrder]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, relationTheory.inv_DEF, relationTheory.RSUBSET, relationTheory.inv_DEF, relationTheory.irreflexive_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). diamond R \u21d2 diamond (RC R)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ ==> @ C$relation$ diamond VR @ C$relation$ diamond @ C$relation$ RC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). diamond R \u21d2 diamond (RC R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ @ C$relation$ RC VR Vx Vz", "@ @ @ C$relation$ RC VR Vx Vy", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vx Vz @ C$bool$ ? | Vu @ @ C$bool$ /\\ @ @ VR Vy Vu @ @ VR Vz Vu"], "goal": "@ C$bool$ ? | Vu @ @ C$bool$ /\\ @ @ @ C$relation$ RC VR Vy Vu @ @ @ C$relation$ RC VR Vz Vu"}, "plain": {"assumptions": ["RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1)", "RC (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1)", "\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R x z \u21d2 \u2203(u :\u03b1). R y u \u2227 R z u"], "goal": "\u2203(u :\u03b1). RC (R :\u03b1 -> \u03b1 -> bool) (y :\u03b1) u \u2227 RC R (z :\u03b1) u"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.diamond_def, relationTheory.RC_lifts_equalities, boolTheory.ONTO_THM, relationTheory.TC_TRANSITIVE, boolTheory.IN_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.RC_DEF, boolTheory.JRH_INDUCT_UTIL, relationTheory.approx_def, relationTheory.inv_DEF, relationTheory.EqIsBothRSUBSET]", "reward": 5}]], "\u2200(P :num -> bool) (n :num). EVERY P (COUNT_LIST n) \u21d4 \u2200(m :num). m < n \u21d2 P m": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ EVERY VP @ C$rich_list$ COUNT_LIST Vn @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vm Vn @ VP Vm"}, "plain": {"assumptions": [], "goal": "\u2200(P :num -> bool) (n :num). EVERY P (COUNT_LIST n) \u21d4 \u2200(m :num). m < n \u21d2 P m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.COUNT_LIST_COUNT, listTheory.EVERY_MEM, listTheory.EVERY_MEM, rich_listTheory.LENGTH_COUNT_LIST, rich_listTheory.NIL_IN_common_prefixes]", "reward": 5}]], "\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d4 l = ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). LENGTH l = (0 :num) \u21d4 l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH C$list$ NIL C$num$ 0 @ @ C$min$ = C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LENGTH ([] :\u03b1 list) = (0 :num) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl C$num$ 0 @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["LENGTH (l :\u03b1 list) = (0 :num) \u21d4 l = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). LENGTH (h::(l :\u03b1 list)) = (0 :num) \u21d4 h::l = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl C$num$ 0 @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["LENGTH (l :\u03b1 list) = (0 :num) \u21d4 l = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). LENGTH (h::(l :\u03b1 list)) = (0 :num) \u21d4 h::l = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.EL_APPEND_EQN, listTheory.FLAT_compute, listTheory.LENGTH, listTheory.list_case_def, listTheory.list_size_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_DEF, listTheory.list_CASES, listTheory.LENGTH, listTheory.EQ_LIST, listTheory.NOT_CONS_NIL]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). BIGUNION {s; t} = s \u222a t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ C$pred_set$ BIGUNION @ @ C$pred_set$ INSERT Vs @ @ C$pred_set$ INSERT Vt C$pred_set$ EMPTY @ @ C$pred_set$ UNION Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). BIGUNION {s; t} = s \u222a t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ C$bool$ IN Vs' @ @ C$pred_set$ INSERT Vs @ @ C$pred_set$ INSERT Vt C$pred_set$ EMPTY @ @ C$bool$ IN Vx Vs' @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 {x | \u2203(s' :\u03b1 -> bool). s' \u2208 {(s :\u03b1 -> bool); (t :\u03b1 -> bool)} \u2227 x \u2208 s'} \u21d4 x \u2208 {x | x \u2208 s \u2228 x \u2208 t}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM1, pred_setTheory.UNION_DEF, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION, pred_setTheory.BIGUNION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vs' Vs @ @ C$bool$ \\/ @ @ C$min$ = Vs' Vt @ C$pred_set$ EMPTY Vs' @ Vs' Vx @ @ C$bool$ \\/ @ Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(s' :\u03b1 -> bool). (s' = (s :\u03b1 -> bool) \u2228 s' = (t :\u03b1 -> bool) \u2228 \u2205 s') \u2227 s' (x :\u03b1)) \u21d4 s x \u2228 t x"}}], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA, pred_setTheory.LINV_OPT_def, pred_setTheory.IN_INSERT, pred_setTheory.FUNSET_EMPTY]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.BIJ_LINV_BIJ, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_applied, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). (SC R)\u1d40 = SC R \u2227 SC R\u1d40 = SC R": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$bool$ /\\ @ @ C$min$ = @ C$relation$ inv @ C$relation$ SC VR @ C$relation$ SC VR @ @ C$min$ = @ C$relation$ SC @ C$relation$ inv VR @ C$relation$ SC VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). (SC R)\u1d40 = SC R \u2227 SC R\u1d40 = SC R"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ VR Vx' Vx @ @ VR Vx Vx' @ @ C$bool$ \\/ @ @ VR Vx Vx' @ @ VR Vx' Vx"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool) (x' :\u03b1) (x :\u03b1) \u2228 R x x' \u21d4 R x x' \u2228 R x' x"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ VR Vx' Vx @ @ VR Vx Vx' @ @ C$bool$ \\/ @ @ VR Vx Vx' @ @ VR Vx' Vx"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool) (x' :\u03b1) (x :\u03b1) \u2228 R x x' \u21d4 R x x' \u2228 R x' x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.FORALL_THM, relationTheory.SC_DEF, boolTheory.FUN_EQ_THM, boolTheory.ABS_SIMP, relationTheory.inv_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ VR Vx' Vx @ @ VR Vx Vx' @ @ C$bool$ \\/ @ @ VR Vx Vx' @ @ VR Vx' Vx"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool) (x' :\u03b1) (x :\u03b1) \u2228 R x x' \u21d4 R x x' \u2228 R x' x"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[relationTheory.WF_EQ_WFP, relationTheory.reflexive_def, relationTheory.symmetric_def, relationTheory.RC_DEF, relationTheory.inv_DEF]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[relationTheory.WF_EQ_WFP, relationTheory.reflexive_def, relationTheory.RC_DEF, relationTheory.RC_DEF, boolTheory.NOT_IMP]", "reward": 5}]], "\u2200(s :\u03b1) (x :\u03b1 -> bool). x \u2282 {s} \u21d4 x = (\u2205 :\u03b1 -> bool)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ PSUBSET Vx @ @ C$pred_set$ INSERT Vs C$pred_set$ EMPTY @ @ C$min$ = Vx C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1) (x :\u03b1 -> bool). x \u2282 {s} \u21d4 x = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vx Vx' @ @ @ C$pred_set$ INSERT Vs C$pred_set$ EMPTY Vx' @ C$bool$ ? | Vx' @ C$bool$ ~ @ @ C$min$ = @ Vx Vx' @ @ @ C$pred_set$ INSERT Vs C$pred_set$ EMPTY Vx' @ C$bool$ ! | Vx' @ @ C$min$ = @ Vx Vx' @ C$pred_set$ EMPTY Vx'"}, "plain": {"assumptions": [], "goal": "(\u2200(x' :\u03b1). (x :\u03b1 -> bool) x' \u21d2 {(s :\u03b1)} x') \u2227 (\u2203(x' :\u03b1). x x' \u21ce {s} x') \u21d4 \u2200(x' :\u03b1). x x' \u21d4 \u2205 x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.DELETE_SUBSET, pred_setTheory.SUBSET_applied, pred_setTheory.PSUBSET_DEF, pred_setTheory.INTER_applied, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.EMPTY_DEF, pred_setTheory.DIFF_INTER_COMPL, pred_setTheory.INSERT_applied, pred_setTheory.subset_countable]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION (s INSERT P) = s \u222a BIGUNION P": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | VP @ @ C$min$ = @ C$pred_set$ BIGUNION @ @ C$pred_set$ INSERT Vs VP @ @ C$pred_set$ UNION Vs @ C$pred_set$ BIGUNION VP"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (P :(\u03b1 -> bool) -> bool). BIGUNION (s INSERT P) = s \u222a BIGUNION P"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ BIGUNION @ @ C$pred_set$ INSERT Vs VP Vx @ @ @ C$pred_set$ UNION Vs @ C$pred_set$ BIGUNION VP Vx"}, "plain": {"assumptions": [], "goal": "BIGUNION ((s :\u03b1 -> bool) INSERT (P :(\u03b1 -> bool) -> bool)) (x :\u03b1) \u21d4 (s \u222a BIGUNION P) x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.IN_INTER, boolTheory.FUN_EQ_THM, boolTheory.FUN_EQ_THM, boolTheory.literal_case_CONG]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vs' @ @ C$bool$ /\\ @ Vs' Vx @ @ @ C$pred_set$ INSERT Vs VP Vs' @ @ C$bool$ \\/ @ Vs Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ Vs Vx @ VP Vs"}, "plain": {"assumptions": [], "goal": "(\u2203(s' :\u03b1 -> bool). s' (x :\u03b1) \u2227 ((s :\u03b1 -> bool) INSERT (P :(\u03b1 -> bool) -> bool)) s') \u21d4 s x \u2228 \u2203(s :\u03b1 -> bool). s x \u2227 P s"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.BIGUNION_applied, pred_setTheory.REST_DEF, pred_setTheory.UNION_applied, pred_setTheory.IN_UNION]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.SPECIFICATION, pred_setTheory.REST_SUBSET, pred_setTheory.INSERT_applied, pred_setTheory.IMAGE_applied]", "reward": 5}]], "TAKE (n :num) (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 l = ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn Vl C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "TAKE (n :num) (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 l = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn C$list$ NIL C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "TAKE (n :num) ([] :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn Vl C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["TAKE (n :num) (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 l = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). TAKE (n :num) (h::(l :\u03b1 list)) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 h::l = ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn Vl C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$bool$ \\/ @ @ C$min$ = Vn C$num$ 0 @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["TAKE (n :num) (l :\u03b1 list) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 l = ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). TAKE (n :num) (h::(l :\u03b1 list)) = ([] :\u03b1 list) \u21d4 n = (0 :num) \u2228 h::l = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_DEF, listTheory.TAKE_def, listTheory.UNZIP, listTheory.UNZIP, listTheory.FRONT_CONS]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.EL_MAP2, listTheory.MEM, listTheory.TAKE_def, listTheory.ZIP_def, listTheory.APPEND_11]", "reward": 5}]], "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n \u2212 LENGTH l1) l2": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l1 :\u03b1 list) (l2 :\u03b1 list). DROP n (l1 ++ l2) = DROP n l1 ++ DROP (n \u2212 LENGTH l1) l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP C$num$ 0 @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP C$num$ 0 Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - C$num$ 0 @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (0 :num) (l1 \u29fa l2) = DROP (0 :num) l1 \u29fa DROP ((0 :num) \u2212 LENGTH l1) l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (n :num) (l1 \u29fa l2) = DROP n l1 \u29fa DROP (n \u2212 LENGTH l1) l2"], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (SUC (n :num)) (l1 \u29fa l2) = DROP (SUC n) l1 \u29fa DROP (SUC n \u2212 LENGTH l1) l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH Vl1 Vl2"}, "plain": {"assumptions": ["\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (n :num) (l1 \u29fa l2) = DROP n l1 \u29fa DROP (n \u2212 LENGTH l1) l2"], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (SUC (n :num)) (l1 \u29fa l2) = DROP (SUC n) l1 \u29fa DROP (SUC n \u2212 LENGTH l1) l2"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.SNOC_APPEND, listTheory.MAP_APPEND, boolTheory.ONE_ONE_DEF, listTheory.LIST_IGNORE_BIND_def, arithmeticTheory.MULT_COMM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn C$list$ NIL @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL Vl2"}, "plain": {"assumptions": ["\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (n :num) (l1 \u29fa l2) = DROP n l1 \u29fa DROP (n \u2212 LENGTH l1) l2"], "goal": "DROP (SUC (n :num)) (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) = DROP (SUC n) ([] :\u03b1 list) \u29fa DROP (SUC n \u2212 LENGTH ([] :\u03b1 list)) l2"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH Vl1 Vl2", "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["DROP (SUC (n :num)) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = DROP (SUC n) l1 \u29fa DROP (SUC n \u2212 LENGTH l1) l2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (n :num) (l1 \u29fa l2) = DROP n l1 \u29fa DROP (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1). DROP (SUC (n :num)) (h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = DROP (SUC n) (h::l1) \u29fa DROP (SUC n \u2212 LENGTH (h::l1)) l2"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH Vl1 Vl2", "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP Vn Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$list$ LENGTH Vl1 Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$list$ CONS Vh Vl1 @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$num$ SUC Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl1 Vl2"}, "plain": {"assumptions": ["DROP (SUC (n :num)) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = DROP (SUC n) l1 \u29fa DROP (SUC n \u2212 LENGTH l1) l2", "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). DROP (n :num) (l1 \u29fa l2) = DROP n l1 \u29fa DROP (n \u2212 LENGTH l1) l2"], "goal": "\u2200(h :\u03b1). DROP (SUC (n :num)) (h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = DROP (SUC n) (h::l1) \u29fa DROP (SUC n \u2212 LENGTH (h::l1)) l2"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_SNOC, listTheory.REVERSE_SNOC, arithmeticTheory.SUB_EQUAL_0, listTheory.LENGTH, arithmeticTheory.LESS_MULT2]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.TAKE_SUM, arithmeticTheory.num_case_def, boolTheory.EXISTS_UNIQUE_DEF, listTheory.FILTER_EQ_CONS, listTheory.LIST_APPLY_o]", "reward": 5}]], "((INL (a :\u03b1) :\u03b1 + \u03b2) \u2208 (A :\u03b1 -> bool) \u2294 (B :\u03b2 -> bool) \u21d4 a \u2208 A) \u2227 ((INR (b :\u03b2) :\u03b1 + \u03b2) \u2208 A \u2294 B \u21d4 b \u2208 B)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ IN @ C$sum$ INL Va @ @ C$pred_set$ disjUNION VA VB @ @ C$bool$ IN Va VA @ @ C$min$ = @ @ C$bool$ IN @ C$sum$ INR Vb @ @ C$pred_set$ disjUNION VA VB @ @ C$bool$ IN Vb VB"}, "plain": {"assumptions": [], "goal": "((INL (a :\u03b1) :\u03b1 + \u03b2) \u2208 (A :\u03b1 -> bool) \u2294 (B :\u03b2 -> bool) \u21d4 a \u2208 A) \u2227 ((INR (b :\u03b2) :\u03b1 + \u03b2) \u2208 A \u2294 B \u21d4 b \u2208 B)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ IN @ C$sum$ INL Va @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Va @ @ C$pair$ , @ C$sum$ INL Va @ @ C$bool$ IN Va VA @ C$pred_set$ GSPEC | Vb @ @ C$pair$ , @ C$sum$ INR Vb @ @ C$bool$ IN Vb VB @ @ C$bool$ IN Va VA @ @ C$min$ = @ @ C$bool$ IN @ C$sum$ INR Vb @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Va @ @ C$pair$ , @ C$sum$ INL Va @ @ C$bool$ IN Va VA @ C$pred_set$ GSPEC | Vb @ @ C$pair$ , @ C$sum$ INR Vb @ @ C$bool$ IN Vb VB @ @ C$bool$ IN Vb VB"}, "plain": {"assumptions": [], "goal": "((INL (a :\u03b1) :\u03b1 + \u03b2) \u2208 {(INL a :\u03b1 + \u03b2) | a \u2208 (A :\u03b1 -> bool)} \u222a {(INR b :\u03b1 + \u03b2) | b \u2208 (B :\u03b2 -> bool)} \u21d4 a \u2208 A) \u2227 ((INR (b :\u03b2) :\u03b1 + \u03b2) \u2208 {(INL a :\u03b1 + \u03b2) | a \u2208 A} \u222a {(INR b :\u03b1 + \u03b2) | b \u2208 B} \u21d4 b \u2208 B)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[pred_setTheory.EXTENSION, sumTheory.OUTL, pred_setTheory.FINITE_HAS_SIZE, pred_setTheory.BIJ_FINITE_SUBSET, pred_setTheory.disjUNION_def]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.IN_APP, pred_setTheory.FINITE_DEF, pred_setTheory.UNION_applied, pred_setTheory.SUBSET_INTER1, pred_setTheory.GSPECIFICATION]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :(\u03b2 -> bool) -> bool). PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ C$pred_set$ BIGUNION Vs @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE @ C$pred_set$ PREIMAGE Vf Vs"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :(\u03b2 -> bool) -> bool). PREIMAGE f (BIGUNION s) = BIGUNION (IMAGE (PREIMAGE f) s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ Vf Vx @ C$pred_set$ BIGUNION Vs @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ Vf Vx Vx'"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 {x | (f :\u03b1 -> \u03b2) x \u2208 BIGUNION (s :(\u03b2 -> bool) -> bool)} \u21d4 \u2203(x' :\u03b2 -> bool). x' \u2208 s \u2227 x \u2208 {x | f x \u2208 x'}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.BIJ_DEF, pred_setTheory.BIJ_SYM, pred_setTheory.PREIMAGE_def, pred_setTheory.IN_BIGUNION_IMAGE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IMAGE_DEF, pred_setTheory.BIGUNION_applied, pred_setTheory.BIGUNION, pred_setTheory.BIGINTER, pred_setTheory.GSPECIFICATION]", "reward": 5}]], "\u2200(n :num) (x :\u03b1). LENGTH (REPLICATE n x) = n": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE Vn Vx Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (x :\u03b1). LENGTH (REPLICATE n x) = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE C$num$ 0 Vx C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). LENGTH (REPLICATE (0 :num) x) = (0 :num)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE Vn Vx Vn"], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vn Vx @ C$num$ SUC Vn"}, "plain": {"assumptions": ["\u2200(x :\u03b1). LENGTH (REPLICATE (n :num) x) = n"], "goal": "\u2200(x :\u03b1). LENGTH (REPLICATE (SUC (n :num)) x) = SUC n"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE Vn Vx Vn"], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vn Vx @ C$num$ SUC Vn"}, "plain": {"assumptions": ["\u2200(x :\u03b1). LENGTH (REPLICATE (n :num) x) = n"], "goal": "\u2200(x :\u03b1). LENGTH (REPLICATE (SUC (n :num)) x) = SUC n"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.REPLICATE, listTheory.EL_restricted, listTheory.GENLIST_AUX, listTheory.list_TY_DEF, listTheory.SHORTLEX_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[rich_listTheory.FLAT_FLAT, rich_listTheory.BUTLASTN_REVERSE, rich_listTheory.REPLICATE, listTheory.DROP_TAKE, listTheory.DROP_TAKE]", "reward": 5}]], "\u2200(n :num). count (n + (1 :num)) = n INSERT count n": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ C$pred_set$ count @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ @ C$pred_set$ INSERT Vn @ C$pred_set$ count Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). count (n + (1 :num)) = n INSERT count n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vx @ @ @ C$pred_set$ INSERT Vn @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm Vn Vx"}, "plain": {"assumptions": [], "goal": "{m | m < (n :num) + (1 :num)} (x :num) \u21d4 (n INSERT {m | m < n}) x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.NOT_EMPTY_SING, pred_setTheory.count_def, boolTheory.FUN_EQ_THM, pred_setTheory.DIFF_DEF, pred_setTheory.BIJ_ALT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.BIGUNION_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.INSERT_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t = (\u2205 :\u03b1 -> bool) \u21d4 s \u2286 t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vt C$pred_set$ EMPTY @ @ C$pred_set$ SUBSET Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s DIFF t = (\u2205 :\u03b1 -> bool) \u21d4 s \u2286 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vt C$pred_set$ EMPTY @ @ C$pred_set$ SUBSET Vs Vt"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) DIFF (t :\u03b1 -> bool) = (\u2205 :\u03b1 -> bool) \u21d4 s \u2286 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.FINITE_WEAK_ENUMERATE, pred_setTheory.IN_DISJOINT, pred_setTheory.INTER_applied, pred_setTheory.INTER_applied, pred_setTheory.SUBSET_DIFF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ DIFF Vs Vt Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). ((s :\u03b1 -> bool) DIFF (t :\u03b1 -> bool)) x \u21d4 \u2205 x) \u21d4 \u2200(x :\u03b1). s x \u21d2 t x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.IN_DEF, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_DEF, pred_setTheory.IN_UNION, boolTheory.DISJ_EQ_IMP]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_applied, pred_setTheory.DIFF_applied]", "reward": 5}]], "DROP (n :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 n) a": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm Vn Va"}, "plain": {"assumptions": [], "goal": "DROP (n :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 n) a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ DROP C$num$ 0 @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm C$num$ 0 Va"}, "plain": {"assumptions": [], "goal": "DROP (0 :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 (0 :num)) a"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm Vn Va"], "goal": "@ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm @ C$num$ SUC Vn Va"}, "plain": {"assumptions": ["DROP (n :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 n) a"], "goal": "DROP (SUC (n :num)) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 SUC n) a"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ DROP Vn @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm Vn Va"], "goal": "@ @ C$min$ = @ @ C$list$ DROP @ C$num$ SUC Vn @ @ C$rich_list$ REPLICATE Vm Va @ @ C$rich_list$ REPLICATE @ @ C$arithmetic$ - Vm @ C$num$ SUC Vn Va"}, "plain": {"assumptions": ["DROP (n :num) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 n) a"], "goal": "DROP (SUC (n :num)) (REPLICATE (m :num) (a :\u03b1)) = REPLICATE (m \u2212 SUC n) a"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.longest_prefix_def, rich_listTheory.EVERY2_DROP, listTheory.MAP_MAP_o, arithmeticTheory.LESS_EQ_LESS_TRANS, rich_listTheory.FLAT_REVERSE]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EL_REVERSE, rich_listTheory.REPLICATE_GENLIST, rich_listTheory.REPLICATE_GENLIST, rich_listTheory.COUNT_LIST_SNOC, listTheory.DROP_GENLIST]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1). (x INSERT P) \u00d7 Q = {x} \u00d7 Q \u222a P \u00d7 Q": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ CROSS @ @ C$pred_set$ INSERT Vx VP VQ @ @ C$pred_set$ UNION @ @ C$pred_set$ CROSS @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY VQ @ @ C$pred_set$ CROSS VP VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b1). (x INSERT P) \u00d7 Q = {x} \u00d7 Q \u222a P \u00d7 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp @ @ C$pred_set$ INSERT Vx VP @ @ C$bool$ IN @ C$pair$ SND Vp VQ @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$bool$ IN @ C$pair$ SND Vp VQ @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp VP @ @ C$bool$ IN @ C$pair$ SND Vp VQ"}, "plain": {"assumptions": [], "goal": "{p | FST p \u2208 (x :\u03b1) INSERT (P :\u03b1 -> bool) \u2227 SND p \u2208 (Q :\u03b2 -> bool)} = {p | FST p \u2208 {x} \u2227 SND p \u2208 Q} \u222a {p | FST p \u2208 P \u2227 SND p \u2208 Q}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.BIGUNION_PAIR, pred_setTheory.IN_DISJOINT, pred_setTheory.HAS_SIZE_CARD, pred_setTheory.CROSS_DEF, pred_setTheory.CROSS_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vp @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = @ C$pair$ FST Vp Vx @ VP @ C$pair$ FST Vp @ VQ @ C$pair$ SND Vp | Vx' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = @ C$pair$ FST Vx' Vx @ C$pred_set$ EMPTY @ C$pair$ FST Vx' @ VQ @ C$pair$ SND Vx' @ @ C$bool$ /\\ @ VP @ C$pair$ FST Vx' @ VQ @ C$pair$ SND Vx'"}, "plain": {"assumptions": [], "goal": "(\u03bb(p :\u03b1 # \u03b2). (FST p = (x :\u03b1) \u2228 (P :\u03b1 -> bool) (FST p)) \u2227 (Q :\u03b2 -> bool) (SND p)) = (\u03bb(x' :\u03b1 # \u03b2). (FST x' = x \u2228 \u2205 (FST x')) \u2227 Q (SND x') \u2228 P (FST x') \u2227 Q (SND x'))"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, boolTheory.PULL_EXISTS, pred_setTheory.GSPEC_ETA, pred_setTheory.INSERT_DEF, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EMPTY_DEF, pred_setTheory.INTER_UNIV, pred_setTheory.INTER_DEF, pred_setTheory.BIGINTER_applied, pred_setTheory.SUBSET_BIGUNION_I]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u2229 t = if x \u2208 t then x INSERT s \u2229 t else s \u2229 t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ INTER @ @ C$pred_set$ INSERT Vx Vs Vt @ @ @ C$bool$ COND @ @ C$bool$ IN Vx Vt @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ INTER Vs Vt @ @ C$pred_set$ INTER Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u2229 t = if x \u2208 t then x INSERT s \u2229 t else s \u2229 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx Vt"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": ["(x :\u03b1) \u2208 (t :\u03b1 -> bool)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 x' \u2208 (s :\u03b1 -> bool)) \u2227 x' \u2208 (t :\u03b1 -> bool) \u21d4 x' = x \u2228 x' \u2208 s \u2227 x' \u2208 t"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$bool$ IN Vx Vt"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": ["(x :\u03b1) \u2209 (t :\u03b1 -> bool)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 x' \u2208 (s :\u03b1 -> bool)) \u2227 x' \u2208 (t :\u03b1 -> bool) \u21d4 x' \u2208 s \u2227 x' \u2208 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.EXTENSION, pred_setTheory.DISJOINT_UNION_BOTH, pred_setTheory.IN_INSERT, pred_setTheory.NUM_SET_WOP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$bool$ IN Vx Vt"], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' Vt"}, "plain": {"assumptions": ["(x :\u03b1) \u2209 (t :\u03b1 -> bool)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 x' \u2208 (s :\u03b1 -> bool)) \u2227 x' \u2208 (t :\u03b1 -> bool) \u21d4 x' \u2208 s \u2227 x' \u2208 t"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INSERT_INSERT, pred_setTheory.INSERT_INSERT, pred_setTheory.EXTENSION, pred_setTheory.IN_INSERT, pred_setTheory.INSERT_COMM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.LEFT_OR_EXISTS_THM, boolTheory.EXISTS_UNIQUE_DEF, pred_setTheory.IN_DISJOINT, pred_setTheory.INSERT_INSERT, pred_setTheory.INSERT_applied]", "reward": 5}]], "COUNT_LIST (0 :num) = ([] :num list) \u2227 \u2200(n :num). COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$rich_list$ COUNT_LIST C$num$ 0 C$list$ NIL @ C$bool$ ! | Vn @ @ C$min$ = @ C$rich_list$ COUNT_LIST @ C$num$ SUC Vn @ @ C$list$ SNOC Vn @ C$rich_list$ COUNT_LIST Vn"}, "plain": {"assumptions": [], "goal": "COUNT_LIST (0 :num) = ([] :num list) \u2227 \u2200(n :num). COUNT_LIST (SUC n) = SNOC n (COUNT_LIST n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.TL_T_def, listTheory.oEL_DROP, listTheory.GENLIST, rich_listTheory.COUNT_LIST_GENLIST, rich_listTheory.COUNT_LIST_GENLIST]", "reward": 5}]], "\u2200(a0 :\u03b1) (a1 :\u03b1 list) (a0' :\u03b1) (a1' :\u03b1 list). a0::a1 = a0'::a1' \u21d4 a0 = a0' \u2227 a1 = a1'": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va0 @ C$bool$ ! | Va1 @ C$bool$ ! | Va0' @ C$bool$ ! | Va1' @ @ C$min$ = @ @ C$min$ = @ @ C$list$ CONS Va0 Va1 @ @ C$list$ CONS Va0' Va1' @ @ C$bool$ /\\ @ @ C$min$ = Va0 Va0' @ @ C$min$ = Va1 Va1'"}, "plain": {"assumptions": [], "goal": "\u2200(a0 :\u03b1) (a1 :\u03b1 list) (a0' :\u03b1) (a1' :\u03b1 list). a0::a1 = a0'::a1' \u21d4 a0 = a0' \u2227 a1 = a1'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.HD, listTheory.TL, listTheory.MAP2_NIL, listTheory.LIST_TO_SET, boolTheory.FUN_EQ_THM]", "reward": 5}]], "(diag (A :\u03b1 -> bool))\u1d40 = diag A": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ inv @ C$relation$ diag VA @ C$relation$ diag VA"}, "plain": {"assumptions": [], "goal": "(diag (A :\u03b1 -> bool))\u1d40 = diag A"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ diag VA Vy Vx @ @ @ C$relation$ diag VA Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ diag VA Vx Vy @ @ @ C$relation$ diag VA Vy Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). diag (A :\u03b1 -> bool) y x \u21d2 diag A x y) \u2227 \u2200(x :\u03b1) (y :\u03b1). diag A x y \u21d2 diag A y x"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.reflexive_EQC, relationTheory.RC_DEF, relationTheory.inv_DEF, relationTheory.RSUBSET, relationTheory.EqIsBothRSUBSET]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[relationTheory.diag_def, relationTheory.EqIsBothRSUBSET, relationTheory.WeakLinearOrder_dichotomy, relationTheory.TC_implies_one_step, relationTheory.transitive_def]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (B :(\u03b1 -> bool) -> bool). BIGINTER (P INSERT B) = P \u2229 BIGINTER B": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VB @ @ C$min$ = @ C$pred_set$ BIGINTER @ @ C$pred_set$ INSERT VP VB @ @ C$pred_set$ INTER VP @ C$pred_set$ BIGINTER VB"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (B :(\u03b1 -> bool) -> bool). BIGINTER (P INSERT B) = P \u2229 BIGINTER B"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ IN Vs @ @ C$pred_set$ INSERT VP VB @ @ C$bool$ IN Vx Vs @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx VP @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ IN Vs VB @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "{x | \u2200(s :\u03b1 -> bool). s \u2208 (P :\u03b1 -> bool) INSERT (B :(\u03b1 -> bool) -> bool) \u21d2 x \u2208 s} = {x | x \u2208 P \u2227 x \u2208 {x | \u2200(s :\u03b1 -> bool). s \u2208 B \u21d2 x \u2208 s}}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.BIGINTER, pred_setTheory.DIFF_DEF, pred_setTheory.INTER_DEF, pred_setTheory.IN_BIGINTER_IMAGE, pred_setTheory.EMPTY_UNION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = | Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vs VP @ VB Vs @ Vs Vx | Vx @ @ C$bool$ /\\ @ VP Vx @ C$bool$ ! | Vs @ @ C$min$ ==> @ VB Vs @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u03bb(x :\u03b1). \u2200(s :\u03b1 -> bool). s = (P :\u03b1 -> bool) \u2228 (B :(\u03b1 -> bool) -> bool) s \u21d2 s x) = (\u03bb(x :\u03b1). P x \u2227 \u2200(s :\u03b1 -> bool). B s \u21d2 s x)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_applied, pred_setTheory.INSERT_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPECIFICATION]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.SCHROEDER_CLOSE, pred_setTheory.SUBSET_FINITE_I, pred_setTheory.SCHROEDER_CLOSED, pred_setTheory.DIFF_INTER2]", "reward": 5}]], "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b2 -> \u03b2 -> bool) (v1 :\u03b1 # \u03b2) (v2 :\u03b1 # \u03b2) (R1' :\u03b1 -> \u03b1 -> bool) (R2' :\u03b2 -> \u03b2 -> bool) (v1' :\u03b1 # \u03b2) (v2' :\u03b1 # \u03b2). v1 = v1' \u2227 v2 = v2' \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u21d2 (R1 a c \u21d4 R1' a c)) \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u2227 a = c \u21d2 (R2 b d \u21d4 R2' b d)) \u21d2 ((R1 LEX R2) v1 v2 \u21d4 (R1' LEX R2') v1' v2')": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR1 @ C$bool$ ! | VR2 @ C$bool$ ! | Vv1 @ C$bool$ ! | Vv2 @ C$bool$ ! | VR1' @ C$bool$ ! | VR2' @ C$bool$ ! | Vv1' @ C$bool$ ! | Vv2' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vv1 Vv1' @ @ C$bool$ /\\ @ @ C$min$ = Vv2 Vv2' @ @ C$bool$ /\\ @ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vv1' @ @ C$pair$ , Va Vb @ @ C$min$ = Vv2' @ @ C$pair$ , Vc Vd @ @ C$min$ = @ @ VR1 Va Vc @ @ VR1' Va Vc @ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vv1' @ @ C$pair$ , Va Vb @ @ C$bool$ /\\ @ @ C$min$ = Vv2' @ @ C$pair$ , Vc Vd @ @ C$min$ = Va Vc @ @ C$min$ = @ @ VR2 Vb Vd @ @ VR2' Vb Vd @ @ C$min$ = @ @ @ @ C$pair$ LEX VR1 VR2 Vv1 Vv2 @ @ @ @ C$pair$ LEX VR1' VR2' Vv1' Vv2'"}, "plain": {"assumptions": [], "goal": "\u2200(R1 :\u03b1 -> \u03b1 -> bool) (R2 :\u03b2 -> \u03b2 -> bool) (v1 :\u03b1 # \u03b2) (v2 :\u03b1 # \u03b2) (R1' :\u03b1 -> \u03b1 -> bool) (R2' :\u03b2 -> \u03b2 -> bool) (v1' :\u03b1 # \u03b2) (v2' :\u03b1 # \u03b2). v1 = v1' \u2227 v2 = v2' \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u21d2 (R1 a c \u21d4 R1' a c)) \u2227 (\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). v1' = (a,b) \u2227 v2' = (c,d) \u2227 a = c \u21d2 (R2 b d \u21d4 R2' b d)) \u21d2 ((R1 LEX R2) v1 v2 \u21d4 (R1' LEX R2') v1' v2')"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vv1 @ @ C$pair$ , Vc Vb @ @ C$min$ = Vv2 @ @ C$pair$ , Vc Vd @ @ C$min$ = @ @ VR2 Vb Vd @ @ VR2' Vb Vd", "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vv1 @ @ C$pair$ , Va Vb @ @ C$min$ = Vv2 @ @ C$pair$ , Vc Vd @ @ C$min$ = @ @ VR1 Va Vc @ @ VR1' Va Vc"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ VR1 @ C$pair$ FST Vv1 @ C$pair$ FST Vv2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vv1 @ C$pair$ FST Vv2 @ @ VR2 @ C$pair$ SND Vv1 @ C$pair$ SND Vv2 @ @ C$bool$ \\/ @ @ VR1' @ C$pair$ FST Vv1 @ C$pair$ FST Vv2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vv1 @ C$pair$ FST Vv2 @ @ VR2' @ C$pair$ SND Vv1 @ C$pair$ SND Vv2"}, "plain": {"assumptions": ["\u2200(b :\u03b2) (c :\u03b1) (d :\u03b2). (v1 :\u03b1 # \u03b2) = (c,b) \u2227 (v2 :\u03b1 # \u03b2) = (c,d) \u21d2 ((R2 :\u03b2 -> \u03b2 -> bool) b d \u21d4 (R2' :\u03b2 -> \u03b2 -> bool) b d)", "\u2200(a :\u03b1) (b :\u03b2) (c :\u03b1) (d :\u03b2). (v1 :\u03b1 # \u03b2) = (a,b) \u2227 (v2 :\u03b1 # \u03b2) = (c,d) \u21d2 ((R1 :\u03b1 -> \u03b1 -> bool) a c \u21d4 (R1' :\u03b1 -> \u03b1 -> bool) a c)"], "goal": "(R1 :\u03b1 -> \u03b1 -> bool) (FST (v1 :\u03b1 # \u03b2)) (FST (v2 :\u03b1 # \u03b2)) \u2228 FST v1 = FST v2 \u2227 (R2 :\u03b2 -> \u03b2 -> bool) (SND v1) (SND v2) \u21d4 (R1' :\u03b1 -> \u03b1 -> bool) (FST v1) (FST v2) \u2228 FST v1 = FST v2 \u2227 (R2' :\u03b2 -> \u03b2 -> bool) (SND v1) (SND v2)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pairTheory.LEX_DEF, boolTheory.DISJ_COMM, pairTheory.UNCURRY_VAR, pairTheory.UNCURRY_CONG, pairTheory.WF_RPROD]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.TYPE_DEFINITION, pairTheory.PAIR, pairTheory.FST, pairTheory.PAIR_MAP, pairTheory.FST_PAIR_MAP]", "reward": 5}]], "\u2200(l :\u03b1 list). FINITE (set l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$pred_set$ FINITE @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). FINITE (set l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ FINITE @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FINITE (set ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$pred_set$ FINITE @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$pred_set$ FINITE @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FINITE (set (l :\u03b1 list))"], "goal": "\u2200(h :\u03b1). FINITE (set (h::(l :\u03b1 list)))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$pred_set$ FINITE @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$pred_set$ FINITE @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["FINITE (set (l :\u03b1 list))"], "goal": "\u2200(h :\u03b1). FINITE (set (h::(l :\u03b1 list)))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.LENGTH_TL, listTheory.LIST_TO_SET, pred_setTheory.count_def, pred_setTheory.SUBSET_reflexive]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET, listTheory.FRONT_DEF, pred_setTheory.PROD_SET_EMPTY, pred_setTheory.SUM_SET_DEF, pred_setTheory.POW_DEF]", "reward": 5}]], "((A :\u03b1 -> bool) \u222a (B :\u03b1 -> bool)) \u2229 A = A \u2227 (B \u222a A) \u2229 A = A \u2227 A \u2229 (A \u222a B) = A \u2227 A \u2229 (B \u222a A) = A": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ INTER @ @ C$pred_set$ UNION VA VB VA VA @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ INTER @ @ C$pred_set$ UNION VB VA VA VA @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ INTER VA @ @ C$pred_set$ UNION VA VB VA @ @ C$min$ = @ @ C$pred_set$ INTER VA @ @ C$pred_set$ UNION VB VA VA"}, "plain": {"assumptions": [], "goal": "((A :\u03b1 -> bool) \u222a (B :\u03b1 -> bool)) \u2229 A = A \u2227 (B \u222a A) \u2229 A = A \u2227 A \u2229 (A \u222a B) = A \u2227 A \u2229 (B \u222a A) = A"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx VA @ @ C$bool$ IN Vx VB @ @ C$bool$ IN Vx VA @ VA Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$bool$ IN Vx VB @ @ C$bool$ IN Vx VA @ @ C$bool$ IN Vx VA @ VA Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ IN Vx VA @ @ C$bool$ \\/ @ @ C$bool$ IN Vx VA @ @ C$bool$ IN Vx VB @ VA Vx @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ IN Vx VA @ @ C$bool$ \\/ @ @ C$bool$ IN Vx VB @ @ C$bool$ IN Vx VA @ VA Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (x \u2208 (A :\u03b1 -> bool) \u2228 x \u2208 (B :\u03b1 -> bool)) \u2227 x \u2208 A \u21d4 A x) \u2227 (\u2200(x :\u03b1). (x \u2208 B \u2228 x \u2208 A) \u2227 x \u2208 A \u21d4 A x) \u2227 (\u2200(x :\u03b1). x \u2208 A \u2227 (x \u2208 A \u2228 x \u2208 B) \u21d4 A x) \u2227 \u2200(x :\u03b1). x \u2208 A \u2227 (x \u2208 B \u2228 x \u2208 A) \u21d4 A x"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_INTER, pred_setTheory.INTER_applied, pred_setTheory.IN_UNION, boolTheory.FUN_EQ_THM, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.BIJ_DELETE, pred_setTheory.pairwise_def, pred_setTheory.FINITE_DIFF_down, pred_setTheory.FINITE_CROSS_EQ]", "reward": 5}]], "\u2200(L :(\u03b1 # \u03b2) list). UNZIP L = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) L,MAP (SND :\u03b1 # \u03b2 -> \u03b2) L)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VL @ @ C$min$ = @ C$list$ UNZIP VL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST VL @ @ C$list$ MAP C$pair$ SND VL"}, "plain": {"assumptions": [], "goal": "\u2200(L :(\u03b1 # \u03b2) list). UNZIP L = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) L,MAP (SND :\u03b1 # \u03b2 -> \u03b2) L)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ UNZIP C$list$ NIL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST C$list$ NIL @ @ C$list$ MAP C$pair$ SND C$list$ NIL"}, "plain": {"assumptions": [], "goal": "UNZIP ([] :(\u03b1 # \u03b2) list) = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) ([] :(\u03b1 # \u03b2) list), MAP (SND :\u03b1 # \u03b2 -> \u03b2) ([] :(\u03b1 # \u03b2) list))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ UNZIP VL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST VL @ @ C$list$ MAP C$pair$ SND VL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ UNZIP @ @ C$list$ CONS Vh VL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST @ @ C$list$ CONS Vh VL @ @ C$list$ MAP C$pair$ SND @ @ C$list$ CONS Vh VL"}, "plain": {"assumptions": ["UNZIP (L :(\u03b1 # \u03b2) list) = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) L,MAP (SND :\u03b1 # \u03b2 -> \u03b2) L)"], "goal": "\u2200(h :\u03b1 # \u03b2). UNZIP (h::(L :(\u03b1 # \u03b2) list)) = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) (h::L),MAP (SND :\u03b1 # \u03b2 -> \u03b2) (h::L))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `L`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ UNZIP VL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST VL @ @ C$list$ MAP C$pair$ SND VL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ UNZIP @ @ C$list$ CONS Vh VL @ @ C$pair$ , @ @ C$list$ MAP C$pair$ FST @ @ C$list$ CONS Vh VL @ @ C$list$ MAP C$pair$ SND @ @ C$list$ CONS Vh VL"}, "plain": {"assumptions": ["UNZIP (L :(\u03b1 # \u03b2) list) = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) L,MAP (SND :\u03b1 # \u03b2 -> \u03b2) L)"], "goal": "\u2200(h :\u03b1 # \u03b2). UNZIP (h::(L :(\u03b1 # \u03b2) list)) = (MAP (FST :\u03b1 # \u03b2 -> \u03b1) (h::L),MAP (SND :\u03b1 # \u03b2 -> \u03b2) (h::L))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.MAP, listTheory.MAP, listTheory.UNZIP, listTheory.UNZIP, listTheory.UNZIP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.EXISTS_MAP, listTheory.EL, listTheory.UNZIP, listTheory.UNZIP_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). BIJ f s t \u2227 BIJ g t u \u21d2 BIJ (g \u2218 f) s u": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vu @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ @ C$pred_set$ BIJ Vg Vt Vu @ @ @ C$pred_set$ BIJ @ @ C$combin$ o Vg Vf Vs Vu"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (g :\u03b2 -> \u03b3) (s :\u03b1 -> bool) (t :\u03b2 -> bool) (u :\u03b3 -> bool). BIJ f s t \u2227 BIJ g t u \u21d2 BIJ (g \u2218 f) s u"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx Vu", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vu @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vt @ @ C$min$ = @ Vg Vy Vx", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vy Vt @ @ C$min$ = @ @ C$min$ = @ Vg Vx @ Vg Vy @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN @ Vg Vx Vu", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt"], "goal": "@ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vg @ Vf Vy Vx"}, "plain": {"assumptions": ["(x :\u03b3) \u2208 (u :\u03b3 -> bool)", "\u2200(x :\u03b3). x \u2208 (u :\u03b3 -> bool) \u21d2 \u2203(y :\u03b2). y \u2208 (t :\u03b2 -> bool) \u2227 (g :\u03b2 -> \u03b3) y = x", "\u2200(x :\u03b2) (y :\u03b2). x \u2208 (t :\u03b2 -> bool) \u2227 y \u2208 t \u21d2 ((g :\u03b2 -> \u03b3) x = g y \u21d4 x = y)", "\u2200(x :\u03b2). x \u2208 (t :\u03b2 -> bool) \u21d2 (g :\u03b2 -> \u03b3) x \u2208 (u :\u03b3 -> bool)", "\u2200(x :\u03b2). x \u2208 (t :\u03b2 -> bool) \u21d2 \u2203(y :\u03b1). y \u2208 (s :\u03b1 -> bool) \u2227 (f :\u03b1 -> \u03b2) y = x", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u21d2 ((f :\u03b1 -> \u03b2) x = f y \u21d4 x = y)", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool)"], "goal": "\u2203(y :\u03b1). y \u2208 (s :\u03b1 -> bool) \u2227 (g :\u03b2 -> \u03b3) ((f :\u03b1 -> \u03b2) y) = (x :\u03b3)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SURJ_DEF, boolTheory.DATATYPE_TAG_DEF, pred_setTheory.INJ_IFF, pred_setTheory.BIJ_DEF, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.EMPTY_DEF, pred_setTheory.REST_SING, pred_setTheory.IN_UNION, pred_setTheory.INTER_DEF, boolTheory.OR_IMP_THM]", "reward": 5}]], "\u2200(m :num) (l :\u03b1 list). m \u2264 LENGTH l \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (l :\u03b1 list). m \u2264 LENGTH l \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH C$list$ NIL @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm C$list$ NIL @ @ C$list$ TAKE Vn C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(m :num). m \u2264 LENGTH ([] :\u03b1 list) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m ([] :\u03b1 list)) = TAKE n ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num). m \u2264 LENGTH (l :\u03b1 list) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l"], "goal": "\u2200(h :\u03b1) (m :num). m \u2264 LENGTH (h::(l :\u03b1 list)) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m (h::l)) = TAKE n (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num). m \u2264 LENGTH (l :\u03b1 list) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l"], "goal": "\u2200(h :\u03b1) (m :num). m \u2264 LENGTH (h::(l :\u03b1 list)) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m (h::l)) = TAKE n (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.GENLIST_CONG, listTheory.LIST_REL_SPLIT1, listTheory.MAP_EQ_APPEND, listTheory.list_size_def, listTheory.LLEX_NIL2]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= Vn Vm", "@ @ C$arithmetic$ <= Vm @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$arithmetic$ <= Vm @ C$list$ LENGTH Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn Vm @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ TAKE Vm Vl @ @ C$list$ TAKE Vn Vl"], "goal": "@ @ C$min$ = @ @ C$list$ TAKE Vn @ @ @ C$bool$ COND @ @ C$min$ = Vm C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vm @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl"}, "plain": {"assumptions": ["(n :num) \u2264 (m :num)", "(m :num) \u2264 SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num). m \u2264 LENGTH (l :\u03b1 list) \u21d2 \u2200(n :num). n \u2264 m \u21d2 TAKE n (TAKE m l) = TAKE n l"], "goal": "TAKE (n :num) (if (m :num) = (0 :num) then ([] :\u03b1 list) else (h :\u03b1)::TAKE (m \u2212 (1 :num)) (l :\u03b1 list)) = if n = (0 :num) then ([] :\u03b1 list) else h::TAKE (n \u2212 (1 :num)) l"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.adjacent_cases, listTheory.TAKE_def, listTheory.SNOC_CASES, listTheory.FILTER_EQ_ID, listTheory.LIST_TO_SET_FILTER]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.EVERY_FILTER_IMP, listTheory.LUPDATE_def, listTheory.DROP_TAKE, listTheory.MEM_ZIP, listTheory.SNOC_APPEND]", "reward": 5}]], "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (l1 ++ l2) l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND Vl1 Vl2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list) (l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (l1 ++ l2) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND C$list$ NIL Vl2 Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (([] :\u03b1 list) \u29fa l2) l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND Vl1 Vl2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX ((l1 :\u03b1 list) \u29fa l2) l"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (h::(l1 :\u03b1 list) \u29fa l2) l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND Vl1 Vl2 Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$rich_list$ IS_SUFFIX Vl2 Vl @ @ C$rich_list$ IS_SUFFIX @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 Vl"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX ((l1 :\u03b1 list) \u29fa l2) l"], "goal": "\u2200(h :\u03b1) (l2 :\u03b1 list) (l :\u03b1 list). IS_SUFFIX l2 l \u21d2 IS_SUFFIX (h::(l1 :\u03b1 list) \u29fa l2) l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[rich_listTheory.FLAT_SNOC, rich_listTheory.OR_EL_DEF, listTheory.LIST_APPLY_def, listTheory.list_Axiom, rich_listTheory.OR_EL_DEF]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.NULL_FILTER, rich_listTheory.IS_SUFFIX_CONS, rich_listTheory.IS_SUBLIST_APPEND, listTheory.LIST_TO_SET_GENLIST, listTheory.HD]", "reward": 5}]], "\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ @ C$list$ LLEX VR Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ @ C$list$ LLEX VR C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ @ C$list$ LLEX VR Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ~ @ @ @ C$list$ LLEX VR @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). \u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (h::(l :\u03b1 list)) ([] :\u03b1 list)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ @ C$list$ LLEX VR Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ~ @ @ @ C$list$ LLEX VR @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (l :\u03b1 list) ([] :\u03b1 list)"], "goal": "\u2200(h :\u03b1). \u00acLLEX (R :\u03b1 -> \u03b1 -> bool) (h::(l :\u03b1 list)) ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.UNZIP, listTheory.LLEX_THM, listTheory.EL, listTheory.SHORTLEX_THM, listTheory.LLEX_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.LLEX_THM, listTheory.SHORTLEX_THM, listTheory.MAP2, listTheory.EQ_LIST]", "reward": 5}]], "(\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acSHORTLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 SHORTLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (SHORTLEX R (h1::t1) (h2::t2) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR C$list$ NIL C$list$ NIL @ C$bool$ ~ @ @ @ C$list$ SHORTLEX VR @ @ C$list$ CONS Vh1 Vt1 C$list$ NIL @ @ C$bool$ /\\ @ @ @ C$list$ SHORTLEX VR C$list$ NIL @ @ C$list$ CONS Vh2 Vt2 @ @ C$min$ = @ @ @ C$list$ SHORTLEX VR @ @ C$list$ CONS Vh1 Vt1 @ @ C$list$ CONS Vh2 Vt2 @ @ C$bool$ \\/ @ @ C$prim_rec$ < @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ SHORTLEX VR Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "(\u00acSHORTLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acSHORTLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 SHORTLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (SHORTLEX R (h1::t1) (h2::t2) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ~ @ @ @ C$list$ list_CASE C$list$ NIL C$bool$ F | Vh2 | Vt2 @ @ C$bool$ \\/ @ @ C$prim_rec$ < @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ SHORTLEX VR Vt1 Vt2 @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh2 Vt2 @ C$list$ LENGTH C$list$ NIL @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vx @ C$list$ LENGTH C$list$ NIL @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ CONS Vh2 Vt2 @ @ C$list$ EL Vx C$list$ NIL @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh2 Vt2 C$bool$ F | Vh2 | Vt2 @ @ C$bool$ \\/ @ @ C$prim_rec$ < @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ SHORTLEX VR Vt1 Vt2 @ @ C$bool$ \\/ @ @ C$prim_rec$ < @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vt1 @ C$list$ LENGTH Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ SHORTLEX VR Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "\u00ac(case ([] :\u03b1 list) of ([] :\u03b1 list) => F | h2::t2 => LENGTH (t1 :\u03b1 list) < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 ((R :\u03b1 -> \u03b1 -> bool) (h1 :\u03b1) h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2)) \u2227 (LENGTH ((h2 :\u03b1)::(t2 :\u03b1 list)) = LENGTH ([] :\u03b1 list) \u21d2 \u2203(x :num). x < LENGTH ([] :\u03b1 list) \u2227 EL x (h2::t2) \u2260 EL x ([] :\u03b1 list)) \u2227 ((case h2::t2 of ([] :\u03b1 list) => F | h2::t2 => LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2)) \u21d4 LENGTH t1 < LENGTH t2 \u2228 LENGTH t1 = LENGTH t2 \u2227 (R h1 h2 \u2228 h1 = h2 \u2227 SHORTLEX R t1 t2))"}}], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.SUM_MAP_MEM_bound, listTheory.SHORTLEX_def, listTheory.HD_GENLIST, listTheory.LIST_REL_def, listTheory.LIST_EQ_REWRITE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.PAD_RIGHT, listTheory.EL_TAKE, listTheory.LENGTH, listTheory.NULL_GENLIST, listTheory.list_case_def]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R^= x y": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ @ C$relation$ EQC VR Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R x y \u21d2 R^= x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ VR Vx Vy"], "goal": "@ @ @ C$relation$ RC @ C$relation$ TC @ C$relation$ SC VR Vx Vy"}, "plain": {"assumptions": ["(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1)"], "goal": "RC (SC (R :\u03b1 -> \u03b1 -> bool))\u207a (x :\u03b1) (y :\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[relationTheory.EQC_DEF, relationTheory.EXTEND_RTC_TC_EQN, relationTheory.RTC_RTC, relationTheory.symmetric_SC_identity, boolTheory.DISJ_EQ_IMP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ VR Vx Vy"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ @ @ C$relation$ RTC @ C$relation$ SC VR Vx @ C$min$ @ | Vy' @ @ C$bool$ /\\ @ @ @ C$relation$ RTC @ C$relation$ SC VR Vx Vy' @ @ C$bool$ \\/ @ @ VR Vy' Vy @ @ VR Vy Vy' @ @ C$bool$ \\/ @ @ VR @ C$min$ @ | Vy' @ @ C$bool$ /\\ @ @ @ C$relation$ RTC @ C$relation$ SC VR Vx Vy' @ @ C$bool$ \\/ @ @ VR Vy' Vy @ @ VR Vy Vy' Vy @ @ VR Vy @ C$min$ @ | Vy' @ @ C$bool$ /\\ @ @ @ C$relation$ RTC @ C$relation$ SC VR Vx Vy' @ @ C$bool$ \\/ @ @ VR Vy' Vy @ @ VR Vy Vy'"}, "plain": {"assumptions": ["(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1)"], "goal": "(x :\u03b1) = (y :\u03b1) \u2228 (SC (R :\u03b1 -> \u03b1 -> bool))\ua673 x (@(y' :\u03b1). (SC R)\ua673 x y' \u2227 (R y' y \u2228 R y y')) \u2227 (R (@(y' :\u03b1). (SC R)\ua673 x y' \u2227 (R y' y \u2228 R y y')) y \u2228 R y (@(y' :\u03b1). (SC R)\ua673 x y' \u2227 (R y' y \u2228 R y y')))"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.EXISTS_DEF, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN, relationTheory.SC_DEF, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[relationTheory.RTC_CASES2, relationTheory.RTC_ALT_RIGHT_DEF, boolTheory.literal_case_RAND, boolTheory.UNWIND_THM2, relationTheory.RC_MOVES_OUT]", "reward": 5}]], "\u2200(f :num -> \u03b1) (n :num). set (GENLIST f n) = IMAGE f (count n)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ C$list$ LIST_TO_SET @ @ C$list$ GENLIST Vf Vn @ @ C$pred_set$ IMAGE Vf @ C$pred_set$ count Vn"}, "plain": {"assumptions": [], "goal": "\u2200(f :num -> \u03b1) (n :num). set (GENLIST f n) = IMAGE f (count n)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ GENLIST Vf Vn @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$prim_rec$ < Vx' Vn"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b1) (GENLIST (f :num -> \u03b1) (n :num)) \u21d4 \u2203(x' :num). x = f x' \u2227 x' < n"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IMAGE_PREIMAGE, pred_setTheory.count_def, pred_setTheory.ITSET_EMPTY, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_FINITE_I]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vm @ @ C$bool$ /\\ @ @ C$prim_rec$ < Vm Vn @ @ C$min$ = Vx @ Vf Vm @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$prim_rec$ < Vx' Vn"}, "plain": {"assumptions": [], "goal": "(\u2203(m :num). m < (n :num) \u2227 (x :\u03b1) = (f :num -> \u03b1) m) \u21d4 \u2203(x' :num). x = f x' \u2227 x' < n"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, listTheory.MEM_GENLIST, listTheory.MAP_APPEND, listTheory.MEM_FILTER, listTheory.CONS_11]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, listTheory.EVERY_FILTER, listTheory.EXISTS_MEM, listTheory.LAST_DEF, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(c :bool) (l :\u03b1 list). EXISTS (\u03bb(x :\u03b1). c) l \u21d4 l \u2260 ([] :\u03b1 list) \u2227 c": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EXISTS | Vx Vc Vl @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :bool) (l :\u03b1 list). EXISTS (\u03bb(x :\u03b1). c) l \u21d4 l \u2260 ([] :\u03b1 list) \u2227 c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ EXISTS | Vx Vc Vl @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "EXISTS (\u03bb(x :\u03b1). (c :bool)) (l :\u03b1 list) \u21d4 l \u2260 ([] :\u03b1 list) \u2227 c"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_FORALL_OR_THM, boolTheory.IMP_DISJ_THM, boolTheory.F_IMP, listTheory.EVERY_MEM, boolTheory.F_IMP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$min$ ==> @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET Vl Vx Vc @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ~ Vc @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ LIST_TO_SET Vl Vx @ C$bool$ ~ Vc @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ~ Vc"}, "plain": {"assumptions": [], "goal": "((\u2203(x :\u03b1). set (l :\u03b1 list) x \u2227 (c :bool)) \u21d2 l \u2260 ([] :\u03b1 list) \u21d2 \u00acc) \u21d2 (\u2200(x :\u03b1). set l x \u21d2 \u00acc) \u2227 (l \u2260 ([] :\u03b1 list) \u21d2 \u00acc)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.IN_DEF, boolTheory.DISJ_EQ_IMP, listTheory.EXISTS_MEM, listTheory.EVERY_MEM, boolTheory.EQ_EXPAND]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.list_CASES, listTheory.MEM_TL, listTheory.LIST_TO_SET_DEF, listTheory.SUM, listTheory.EL]", "reward": 5}]], "\u2200(p :\u03b1 -> bool) (q :\u03b1 -> bool). p \u2229 q \u222a COMPL p \u2229 q = q": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp @ C$bool$ ! | Vq @ @ C$min$ = @ @ C$pred_set$ UNION @ @ C$pred_set$ INTER Vp Vq @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vp Vq Vq"}, "plain": {"assumptions": [], "goal": "\u2200(p :\u03b1 -> bool) (q :\u03b1 -> bool). p \u2229 q \u222a COMPL p \u2229 q = q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vp @ @ C$bool$ IN Vx Vq @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$pred_set$ COMPL Vp @ @ C$bool$ IN Vx Vq @ @ C$bool$ IN Vx Vq"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 (p :\u03b1 -> bool) \u2227 x \u2208 (q :\u03b1 -> bool) \u2228 x \u2208 COMPL p \u2227 x \u2208 q \u21d4 x \u2208 q"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.OR_INTRO_THM2, pred_setTheory.IN_UNION, pred_setTheory.IN_INTER, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ Vp Vx @ Vq Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ Vp Vx @ Vq Vx @ Vq Vx"}, "plain": {"assumptions": [], "goal": "(p :\u03b1 -> bool) (x :\u03b1) \u2227 (q :\u03b1 -> bool) x \u2228 \u00acp x \u2227 q x \u21d4 q x"}}], "parent": 1, "goal": 0, "by_tactic": "simp[boolTheory.EQ_TRANS, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.IN_APP, pred_setTheory.COMPL_applied, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.IMP_F, pred_setTheory.SPECIFICATION, boolTheory.OR_INTRO_THM1, pred_setTheory.IN_DELETE, pred_setTheory.SING_applied]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2208 partition R s \u21d2 t \u2286 s": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ IN Vt @ @ C$pred_set$ partition VR Vs @ @ C$pred_set$ SUBSET Vt Vs"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (t :\u03b1 -> bool). t \u2208 partition R s \u21d2 t \u2286 s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vt @ C$pred_set$ GSPEC | Vt @ @ C$pair$ , Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = Vt @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy"], "goal": "@ @ C$pred_set$ SUBSET Vt Vs"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) \u2208 {t | \u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 t = equiv_class (R :\u03b1 -> \u03b1 -> bool) s x}"], "goal": "(t :\u03b1 -> bool) \u2286 (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_UNION, pred_setTheory.count_def, pred_setTheory.IMAGE_SING, pred_setTheory.BIJ_ALT, pred_setTheory.partition_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = Vt @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy", "@ @ C$bool$ IN Vx Vs"], "goal": "@ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy Vx' @ Vs Vx'"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) = equiv_class (R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (x :\u03b1)", "(x :\u03b1) \u2208 (s :\u03b1 -> bool)"], "goal": "\u2200(x' :\u03b1). equiv_class (R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (x :\u03b1) x' \u21d2 s x'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.INSERT_COMM, pred_setTheory.IN_BIGUNION, pred_setTheory.SUBSET_applied, pred_setTheory.GSPECIFICATION, pred_setTheory.SUBSET_BIGUNION]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.SUM_IMAGE_SING, pred_setTheory.BIGINTER_INSERT, pred_setTheory.INSERT_applied]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (x :\u03b1). COMPL (x INSERT s) = COMPL s DELETE x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vx @ @ C$min$ = @ C$pred_set$ COMPL @ @ C$pred_set$ INSERT Vx Vs @ @ C$pred_set$ DELETE @ C$pred_set$ COMPL Vs Vx"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (x :\u03b1). COMPL (x INSERT s) = COMPL s DELETE x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ COMPL @ @ C$pred_set$ INSERT Vx Vs Vx' @ @ C$bool$ /\\ @ @ C$pred_set$ COMPL Vs Vx' @ C$bool$ ~ @ @ C$min$ = Vx' Vx"}, "plain": {"assumptions": [], "goal": "COMPL ((x :\u03b1) INSERT (s :\u03b1 -> bool)) (x' :\u03b1) \u21d4 COMPL s x' \u2227 x' \u2260 x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_DEF, pred_setTheory.EXTENSION, pred_setTheory.IN_DELETE, pred_setTheory.FUNSET_applied]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vx' Vx @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx' Vs @ C$bool$ ~ @ @ C$min$ = Vx' Vx"}, "plain": {"assumptions": [], "goal": "(x' :\u03b1) \u2260 (x :\u03b1) \u2227 x' \u2209 (s :\u03b1 -> bool) \u21d4 x' \u2209 s \u2227 x' \u2260 x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.COMPL_applied, pred_setTheory.GSPECIFICATION, boolTheory.PULL_FORALL, pred_setTheory.PSUBSET_FINITE, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.IN_COMPL, pred_setTheory.COMPL_applied, pred_setTheory.IN_APP, pred_setTheory.CROSS_INSERT_RIGHT]", "reward": 5}]], "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d2 LENGTH (TL l) = LENGTH l \u2212 (1 :num)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL Vl @ @ C$arithmetic$ - @ C$list$ LENGTH Vl @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). (0 :num) < LENGTH l \u21d2 LENGTH (TL l) = LENGTH l \u2212 (1 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL C$list$ NIL @ @ C$arithmetic$ - @ C$list$ LENGTH C$list$ NIL @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "(0 :num) < LENGTH ([] :\u03b1 list) \u21d2 LENGTH (TL ([] :\u03b1 list)) = LENGTH ([] :\u03b1 list) \u2212 (1 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL Vl @ @ C$arithmetic$ - @ C$list$ LENGTH Vl @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$arithmetic$ - @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(0 :num) < LENGTH (l :\u03b1 list) \u21d2 LENGTH (TL l) = LENGTH l \u2212 (1 :num)"], "goal": "\u2200(h :\u03b1). (0 :num) < LENGTH (h::(l :\u03b1 list)) \u21d2 LENGTH (TL (h::l)) = LENGTH (h::l) \u2212 (1 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH Vl @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL Vl @ @ C$arithmetic$ - @ C$list$ LENGTH Vl @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$prim_rec$ < C$num$ 0 @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ C$list$ LENGTH @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$arithmetic$ - @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(0 :num) < LENGTH (l :\u03b1 list) \u21d2 LENGTH (TL l) = LENGTH l \u2212 (1 :num)"], "goal": "\u2200(h :\u03b1). (0 :num) < LENGTH (h::(l :\u03b1 list)) \u21d2 LENGTH (TL (h::l)) = LENGTH (h::l) \u2212 (1 :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_CONS, boolTheory.EXISTS_UNIQUE_THM, listTheory.LENGTH, arithmeticTheory.LESS_MONO_ADD, listTheory.MAP_APPEND]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.TL_DEF, boolTheory.PULL_FORALL, listTheory.LIST_TO_SET, listTheory.LENGTH, listTheory.CONS_11]", "reward": 5}]], "\u2200(P :\u03b1 -> \u03b2 -> bool) (Q :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list). (\u2200(x :\u03b1 # \u03b2). MEM x (ZIP (l1,l2)) \u2227 UNCURRY P x \u21d2 UNCURRY Q x) \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL Q l1 l2": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vl1 Vl2 @ @ C$pair$ UNCURRY VP Vx @ @ C$pair$ UNCURRY VQ Vx @ @ @ C$list$ LIST_REL VP Vl1 Vl2 @ @ @ C$list$ LIST_REL VQ Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> \u03b2 -> bool) (Q :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list). (\u2200(x :\u03b1 # \u03b2). MEM x (ZIP (l1,l2)) \u2227 UNCURRY P x \u21d2 UNCURRY Q x) \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL Q l1 l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.COND_RATOR, listTheory.LIST_REL_EVERY_ZIP, listTheory.EVERY_FLAT, listTheory.LENGTH_UNZIP, listTheory.EVERY_MEM]", "reward": 5}]], "\u2200(n :num) (l2 :\u03b1 list). n < LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). ELL n (l1 ++ l2) = ELL n l2": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl2 @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2 @ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l2 :\u03b1 list). n < LENGTH l2 \u21d2 \u2200(l1 :\u03b1 list). ELL n (l1 ++ l2) = ELL n l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2"], "goal": "@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH (l2 :\u03b1 list)"], "goal": "ELL (n :num) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.APPEND_BUTLASTN_LASTN, listTheory.LIST_TO_SET_GENLIST, rich_listTheory.MEM_EXISTS, listTheory.FLAT, listTheory.LIST_REL_EL_EQN]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2"], "goal": "@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": ["(n :num) < LENGTH (l2 :\u03b1 list)"], "goal": "ELL (n :num) (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": ["ELL (n :num) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2", "(n :num) < LENGTH (l2 :\u03b1 list)"], "goal": "\u2200(h :\u03b1). ELL (n :num) (h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": ["ELL (n :num) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2", "(n :num) < LENGTH (l2 :\u03b1 list)"], "goal": "\u2200(h :\u03b1). ELL (n :num) (h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_SPLIT2, arithmeticTheory.LESS_MONO_REV, listTheory.MEM_APPEND, listTheory.EL_LENGTH_dropWhile_REVERSE, listTheory.NOT_NIL_EQ_LENGTH_NOT_0]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2", "@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl2"], "goal": "@ @ C$min$ = @ @ C$rich_list$ ELL Vn @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$rich_list$ ELL Vn Vl2"}, "plain": {"assumptions": ["ELL (n :num) ((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = ELL n l2", "(n :num) < LENGTH (l2 :\u03b1 list)"], "goal": "ELL (n :num) ((h :\u03b1)::((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list))) = ELL n l2"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.PAD_RIGHT, listTheory.EXISTS_GENLIST, prim_recTheory.EQ_LESS, rich_listTheory.FLAT_SNOC, rich_listTheory.UNZIP_FST_DEF]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[rich_listTheory.SPLITP, listTheory.LIST_NOT_EQ, rich_listTheory.ELL_CONS, rich_listTheory.IS_SUFFIX_REVERSE, listTheory.LENGTH_FRONT_CONS]", "reward": 5}]], "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). (MAP f l = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl C$list$ NIL @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf Vl @ @ C$min$ = Vl C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). (MAP f l = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf C$list$ NIL C$list$ NIL @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf C$list$ NIL @ @ C$min$ = C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (MAP f ([] :\u03b1 list) = ([] :\u03b2 list) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f ([] :\u03b1 list) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl C$list$ NIL @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf Vl @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). (MAP f (l :\u03b1 list) = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). (MAP f (h::(l :\u03b1 list)) = ([] :\u03b2 list) \u21d4 h::l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f (h::l) \u21d4 h::l = ([] :\u03b1 list))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl C$list$ NIL @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf Vl @ @ C$min$ = Vl C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). (MAP f (l :\u03b1 list) = ([] :\u03b2 list) \u21d4 l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f l \u21d4 l = ([] :\u03b1 list))"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). (MAP f (h::(l :\u03b1 list)) = ([] :\u03b2 list) \u21d4 h::l = ([] :\u03b1 list)) \u2227 (([] :\u03b2 list) = MAP f (h::l) \u21d4 h::l = ([] :\u03b1 list))"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.EL_MAP2, listTheory.MAP, listTheory.FOLDL, listTheory.NOT_CONS_NIL, listTheory.NOT_CONS_NIL]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "simp[listTheory.EL, listTheory.MAP, listTheory.NOT_CONS_NIL, listTheory.NOT_CONS_NIL, listTheory.list_distinct]", "reward": 5}]], "tri (n :num) = n * (n + (1 :num)) DIV (2 :num)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$numpair$ tri Vn @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "tri (n :num) = n * (n + (1 :num)) DIV (2 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$numpair$ tri C$num$ 0 @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * C$num$ 0 @ @ C$arithmetic$ + C$num$ 0 @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "tri (0 :num) = (((0 :num) * ((0 :num) + (1 :num))) :num) DIV (2 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$numpair$ tri Vn @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ = @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * @ C$num$ SUC Vn @ @ C$arithmetic$ + @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["tri (n :num) = ((n * (n + (1 :num))) :num) DIV (2 :num)"], "goal": "tri (SUC (n :num)) = ((SUC n * (SUC n + (1 :num))) :num) DIV (2 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$numpair$ tri Vn @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ = @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$arithmetic$ DIV @ @ C$arithmetic$ * @ C$num$ SUC Vn @ @ C$arithmetic$ + @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["tri (n :num) = ((n * (n + (1 :num))) :num) DIV (2 :num)"], "goal": "tri (SUC (n :num)) = ((SUC n * (SUC n + (1 :num))) :num) DIV (2 :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[arithmeticTheory.X_LT_X_SQUARED, arithmeticTheory.COMPLETE_INDUCTION, arithmeticTheory.FUNPOW_SUC, arithmeticTheory.LE, numpairTheory.tri_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.MULT_EXP_MONO, arithmeticTheory.DIV_EQ_X, arithmeticTheory.MULT_CLAUSES, numpairTheory.twotri_formula, arithmeticTheory.DIVMOD_CALC]", "reward": 5}]], "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = if x \u2208 t then s \u222a t else x INSERT s \u222a t": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ UNION @ @ C$pred_set$ INSERT Vx Vs Vt @ @ @ C$bool$ COND @ @ C$bool$ IN Vx Vt @ @ C$pred_set$ UNION Vs Vt @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ UNION Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool). (x INSERT s) \u222a t = if x \u2208 t then s \u222a t else x INSERT s \u222a t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx' @ @ C$min$ = @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vx' @ @ C$pair$ , Vx' @ @ C$bool$ \\/ @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy Vs @ @ C$bool$ IN Vx' Vt @ @ C$bool$ IN Vx' @ @ @ C$bool$ COND @ @ C$bool$ IN Vx Vt @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (s :\u03b1 -> bool) (t :\u03b1 -> bool) (x' :\u03b1). x' \u2208 {x' | x' \u2208 {y | y = x \u2228 y \u2208 s} \u2228 x' \u2208 t} \u21d4 x' \u2208 if x \u2208 t then {x | x \u2208 s \u2228 x \u2208 t} else {y | y = x \u2228 y \u2208 {x | x \u2208 s \u2228 x \u2208 t}}"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.INSERT_DEF, pred_setTheory.UNION_DEF, pred_setTheory.EXTENSION, boolTheory.FUN_EQ_THM, pred_setTheory.DIFF_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ Vt Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ Vs Vx' @ Vt Vx' @ @ C$bool$ \\/ @ Vs Vx' @ Vt Vx'"}, "plain": {"assumptions": ["(t :\u03b1 -> bool) (x :\u03b1)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 (s :\u03b1 -> bool) x') \u2228 (t :\u03b1 -> bool) x' \u21d4 s x' \u2228 t x'"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ Vt Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ Vs Vx' @ Vt Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ \\/ @ Vs Vx' @ Vt Vx'"}, "plain": {"assumptions": ["\u00ac(t :\u03b1 -> bool) (x :\u03b1)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 (s :\u03b1 -> bool) x') \u2228 (t :\u03b1 -> bool) x' \u21d4 x' = x \u2228 s x' \u2228 t x'"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.LET_THM, pred_setTheory.DIFF_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA, pred_setTheory.IN_APP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ Vt Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ Vs Vx' @ Vt Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ @ C$bool$ \\/ @ Vs Vx' @ Vt Vx'"}, "plain": {"assumptions": ["\u00ac(t :\u03b1 -> bool) (x :\u03b1)"], "goal": "((x' :\u03b1) = (x :\u03b1) \u2228 (s :\u03b1 -> bool) x') \u2228 (t :\u03b1 -> bool) x' \u21d4 x' = x \u2228 s x' \u2228 t x'"}}], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.SPECIFICATION, pred_setTheory.IN_INSERT, pred_setTheory.INSERT_applied, boolTheory.RIGHT_AND_FORALL_THM]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.INSERT_INSERT, pred_setTheory.SPECIFICATION, pred_setTheory.SPECIFICATION, pred_setTheory.UNION_DEF, pred_setTheory.INSERT_applied]", "reward": 5}]], "\u2200(f :num -> \u03b1) (n :num). LENGTH (GENLIST f n) = n": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf Vn Vn"}, "plain": {"assumptions": [], "goal": "\u2200(f :num -> \u03b1) (n :num). LENGTH (GENLIST f n) = n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u2200(f :num -> \u03b1). LENGTH (GENLIST f (0 :num)) = (0 :num)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf Vn Vn"], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn @ C$num$ SUC Vn"}, "plain": {"assumptions": ["\u2200(f :num -> \u03b1). LENGTH (GENLIST f (n :num)) = n"], "goal": "\u2200(f :num -> \u03b1). LENGTH (GENLIST f (SUC (n :num))) = SUC n"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf Vn Vn"], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ GENLIST Vf @ C$num$ SUC Vn @ C$num$ SUC Vn"}, "plain": {"assumptions": ["\u2200(f :num -> \u03b1). LENGTH (GENLIST f (n :num)) = n"], "goal": "\u2200(f :num -> \u03b1). LENGTH (GENLIST f (SUC (n :num))) = SUC n"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH C$list$ NIL C$num$ 0"}, "plain": {"assumptions": [], "goal": "LENGTH ([] :\u03b1 list) = (0 :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.ZIP_UNZIP, listTheory.ZIP, listTheory.LAST_EL, listTheory.GENLIST, listTheory.SET_TO_LIST_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH C$list$ NIL C$num$ 0"}, "plain": {"assumptions": [], "goal": "LENGTH ([] :\u03b1 list) = (0 :num)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.GENLIST, listTheory.HD_DROP, listTheory.LENGTH_SNOC, listTheory.list_size_cong, listTheory.LIST_REL_EL_EQN]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.SNOC, listTheory.SING_HD, listTheory.LIST_REL_EL_EQN, listTheory.LENGTH_EQ_NUM_compute]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = COMPL (COMPL s \u222a COMPL t)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ C$pred_set$ INTER Vs Vt @ C$pred_set$ COMPL @ @ C$pred_set$ UNION @ C$pred_set$ COMPL Vs @ C$pred_set$ COMPL Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). s \u2229 t = COMPL (COMPL s \u222a COMPL t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN Vx @ C$pred_set$ COMPL @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx @ C$pred_set$ COMPL Vs @ @ C$bool$ IN Vx @ C$pred_set$ COMPL Vt"}, "plain": {"assumptions": [], "goal": "(x :\u03b1) \u2208 {x | x \u2208 (s :\u03b1 -> bool) \u2227 x \u2208 (t :\u03b1 -> bool)} \u21d4 x \u2208 COMPL {x | x \u2208 COMPL s \u2228 x \u2208 COMPL t}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INSERT_SUBSET, pred_setTheory.UNION_DEF, pred_setTheory.INTER_DEF, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.COMPL_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.SING_applied, pred_setTheory.INTER_DEF]", "reward": 5}]], "(2 :num) * tri (n :num) = n * (n + (1 :num))": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri Vn @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "(2 :num) * tri (n :num) = n * (n + (1 :num))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri C$num$ 0 @ @ C$arithmetic$ * C$num$ 0 @ @ C$arithmetic$ + C$num$ 0 @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": [], "goal": "(((2 :num) * tri (0 :num)) :num) = (((0 :num) * ((0 :num) + (1 :num))) :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri Vn @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$arithmetic$ * @ C$num$ SUC Vn @ @ C$arithmetic$ + @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(((2 :num) * tri (n :num)) :num) = ((n * (n + (1 :num))) :num)"], "goal": "(((2 :num) * tri (SUC (n :num))) :num) = ((SUC n * (SUC n + (1 :num))) :num)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri Vn @ @ C$arithmetic$ * Vn @ @ C$arithmetic$ + Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"], "goal": "@ @ C$min$ = @ @ C$arithmetic$ * @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT2 C$arithmetic$ ZERO @ C$numpair$ tri @ C$num$ SUC Vn @ @ C$arithmetic$ * @ C$num$ SUC Vn @ @ C$arithmetic$ + @ C$num$ SUC Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO"}, "plain": {"assumptions": ["(((2 :num) * tri (n :num)) :num) = ((n * (n + (1 :num))) :num)"], "goal": "(((2 :num) * tri (SUC (n :num))) :num) = ((SUC n * (SUC n + (1 :num))) :num)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[arithmeticTheory.X_LT_X_SQUARED, arithmeticTheory.STRICTLY_INCREASING_TC, arithmeticTheory.MOD_LESS, arithmeticTheory.num_case_def, numpairTheory.tri_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.LESS_EQ_EXISTS, arithmeticTheory.num_CASES, arithmeticTheory.ADD1, numpairTheory.tri_def, arithmeticTheory.LESS_EQ_ADD_SUB]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (x INSERT s) DIFF t = if x \u2208 t then s DIFF t else x INSERT s DIFF t": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ DIFF @ @ C$pred_set$ INSERT Vx Vs Vt @ @ @ C$bool$ COND @ @ C$bool$ IN Vx Vt @ @ C$pred_set$ DIFF Vs Vt @ @ C$pred_set$ INSERT Vx @ @ C$pred_set$ DIFF Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (x INSERT s) DIFF t = if x \u2208 t then s DIFF t else x INSERT s DIFF t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = @ C$pred_set$ GSPEC | Vx' @ @ C$pair$ , Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' @ @ C$pred_set$ INSERT Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx' Vt @ @ @ C$bool$ COND @ @ C$bool$ IN Vx Vt @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt @ @ C$pred_set$ INSERT Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). {x' | x' \u2208 x INSERT s \u2227 x' \u2209 t} = if x \u2208 t then {x | x \u2208 s \u2227 x \u2209 t} else x INSERT {x | x \u2208 s \u2227 x \u2209 t}"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_DEF, pred_setTheory.INTER_applied, pred_setTheory.IN_DIFF, pred_setTheory.DIFF_DEF, pred_setTheory.DIFF_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vx @ @ C$min$ = | Vx' @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ Vs Vx' @ C$bool$ ~ @ Vt Vx' @ @ @ C$bool$ COND @ Vt Vx | Vx' @ @ C$bool$ /\\ @ Vs Vx' @ C$bool$ ~ @ Vt Vx' | Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ /\\ @ Vs Vy @ C$bool$ ~ @ Vt Vy"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool) (x :\u03b1). (\u03bb(x' :\u03b1). (x' = x \u2228 s x') \u2227 \u00act x') = if t x then (\u03bb(x' :\u03b1). s x' \u2227 \u00act x') else (\u03bb(y :\u03b1). y = x \u2228 s y \u2227 \u00act y)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.INSERT_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.DIFF_applied, pred_setTheory.IN_APP, boolTheory.UNWIND_FORALL_THM2, boolTheory.UNWIND_THM1, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "(\u2200(x :\u03b1) (xs :\u03b1 list). FRONT (x::xs) = ([] :\u03b1 list) \u21d4 xs = ([] :\u03b1 list)) \u2227 (\u2200(x :\u03b1) (xs :\u03b1 list). ([] :\u03b1 list) = FRONT (x::xs) \u21d4 xs = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (xs :\u03b1 list). NULL (FRONT (x::xs)) \u21d4 NULL xs": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vxs @ @ C$min$ = @ @ C$min$ = @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs C$list$ NIL @ @ C$min$ = Vxs C$list$ NIL @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vxs @ @ C$min$ = @ @ C$min$ = C$list$ NIL @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs @ @ C$min$ = Vxs C$list$ NIL @ C$bool$ ! | Vx @ C$bool$ ! | Vxs @ @ C$min$ = @ C$list$ NULL @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs @ C$list$ NULL Vxs"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (xs :\u03b1 list). FRONT (x::xs) = ([] :\u03b1 list) \u21d4 xs = ([] :\u03b1 list)) \u2227 (\u2200(x :\u03b1) (xs :\u03b1 list). ([] :\u03b1 list) = FRONT (x::xs) \u21d4 xs = ([] :\u03b1 list)) \u2227 \u2200(x :\u03b1) (xs :\u03b1 list). NULL (FRONT (x::xs)) \u21d4 NULL xs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.NULL_LENGTH, listTheory.LENGTH_FRONT_CONS, listTheory.MEM, listTheory.REVERSE_EQ_SING, listTheory.FRONT_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 # bool). (\u2200(x :\u03b1). \u00acSND (f x)) \u21d2 GSPEC f = (\u2205 :\u03b2 -> bool)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ~ @ C$pair$ SND @ Vf Vx @ @ C$min$ = @ C$pred_set$ GSPEC Vf C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 # bool). (\u2200(x :\u03b1). \u00acSND (f x)) \u21d2 GSPEC f = (\u2205 :\u03b2 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ~ @ C$pair$ SND @ Vf Vx"], "goal": "@ @ C$min$ = @ @ C$pred_set$ IMAGE @ @ C$combin$ o C$pair$ FST Vf @ @ C$combin$ o C$pair$ SND Vf | Vx C$bool$ F"}, "plain": {"assumptions": ["\u2200(x :\u03b1). \u00acSND ((f :\u03b1 -> \u03b2 # bool) x)"], "goal": "IMAGE ((FST :\u03b2 # bool -> \u03b2) \u2218 (f :\u03b1 -> \u03b2 # bool)) ((SND :\u03b2 # bool -> bool) \u2218 f) = (\u03bb(x :\u03b2). F)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.CARD_PSUBSET, pred_setTheory.FINITE_EMPTY, pred_setTheory.INSERT_INSERT, pred_setTheory.GSPEC_IMAGE, pred_setTheory.EMPTY_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ~ @ C$pair$ SND @ Vf Vx"], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE @ @ C$combin$ o C$pair$ FST Vf @ @ C$combin$ o C$pair$ SND Vf @ @ C$bool$ IN Vx | Vx C$bool$ F"}, "plain": {"assumptions": ["\u2200(x :\u03b1). \u00acSND ((f :\u03b1 -> \u03b2 # bool) x)"], "goal": "\u2200(x :\u03b2). x \u2208 IMAGE ((FST :\u03b2 # bool -> \u03b2) \u2218 (f :\u03b1 -> \u03b2 # bool)) ((SND :\u03b2 # bool -> bool) \u2218 f) \u21d4 x \u2208 (\u03bb(x :\u03b2). F)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.EMPTY_FUNSET, boolTheory.LEFT_OR_EXISTS_THM, pred_setTheory.EXTENSION, pred_setTheory.EXTENSION, pred_setTheory.BIGINTER]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.IN_DEF, pred_setTheory.IMAGE_DEF, pred_setTheory.IN_IMAGE, pred_setTheory.IMAGE_applied, pred_setTheory.SUM_IMAGE_DEF]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (M :\u03b1 -> num). (\u2203(x :\u03b1). x \u2208 s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 \u2200(y :\u03b1). y \u2208 s \u21d2 M x \u2264 M y": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | VM @ @ C$min$ = @ C$bool$ ? | Vx @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vs @ @ C$arithmetic$ <= @ VM Vx @ VM Vy"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (M :\u03b1 -> num). (\u2203(x :\u03b1). x \u2208 s) \u21d4 \u2203(x :\u03b1). x \u2208 s \u2227 \u2200(y :\u03b1). y \u2208 s \u21d2 M x \u2264 M y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vs @ @ C$arithmetic$ <= @ VM Vx @ VM Vy", "@ @ C$bool$ IN Vx Vs"], "goal": "@ C$bool$ ? | Vx @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": ["\u2200(y :\u03b1). y \u2208 (s :\u03b1 -> bool) \u21d2 (M :\u03b1 -> num) (x :\u03b1) \u2264 M y", "(x :\u03b1) \u2208 (s :\u03b1 -> bool)"], "goal": "\u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.LESS_EQ_LESS_EQ_MONO, arithmeticTheory.GREATER_EQ, arithmeticTheory.WOP_measure, boolTheory.EQ_IMP_THM, arithmeticTheory.DIV_MULT]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.literal_case_THM, arithmeticTheory.FUNPOW_1, arithmeticTheory.NRC_1, arithmeticTheory.MIN_MAX_LT, arithmeticTheory.EQ_MULT_LCANCEL]", "reward": 5}]], "\u2200(l :\u03b1 list). \u00acNULL l \u21d4 \u2203(e :\u03b1). MEM e l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$bool$ ~ @ C$list$ NULL Vl @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). \u00acNULL l \u21d4 \u2203(e :\u03b1). MEM e l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.DATATYPE_TAG_THM, listTheory.list_INDUCT0, listTheory.MAP2_NIL, listTheory.NULL_EQ, boolTheory.RIGHT_FORALL_IMP_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ C$bool$ ? | Ve @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d4 \u2203(e :\u03b1). MEM e (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "simp[boolTheory.DATATYPE_TAG_THM, listTheory.LIST_TO_SET, listTheory.LIST_TO_SET, listTheory.MEM_FILTER, listTheory.EVERY_MEM]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[listTheory.EL, listTheory.MEM, listTheory.MEM, listTheory.list_TY_DEF, listTheory.FILTER_EQ_CONS]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n l = DROP (LENGTH l \u2212 n) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ LASTN Vn Vl @ @ C$list$ DROP @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n \u2264 LENGTH l \u21d2 LASTN n l = DROP (LENGTH l \u2212 n) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.DROP_SEG, listTheory.dropWhile_APPEND_EXISTS, listTheory.LENGTH_LT_SHORTLEX, listTheory.EL_REVERSE, rich_listTheory.LASTN_SEG]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 # \u03b3) (a :\u03b2 -> bool) (b :\u03b3 -> bool). PREIMAGE f (a \u00d7 b) = PREIMAGE ((FST :\u03b2 # \u03b3 -> \u03b2) \u2218 f) a \u2229 PREIMAGE ((SND :\u03b2 # \u03b3 -> \u03b3) \u2218 f) b": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ CROSS Va Vb @ @ C$pred_set$ INTER @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ FST Vf Va @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ SND Vf Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 # \u03b3) (a :\u03b2 -> bool) (b :\u03b3 -> bool). PREIMAGE f (a \u00d7 b) = PREIMAGE ((FST :\u03b2 # \u03b3 -> \u03b2) \u2218 f) a \u2229 PREIMAGE ((SND :\u03b2 # \u03b3 -> \u03b3) \u2218 f) b"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ CROSS Va Vb @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ FST Vf Va @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ SND Vf Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 # \u03b3) (a :\u03b2 -> bool) (b :\u03b3 -> bool). PREIMAGE f ((a \u00d7 b) :\u03b2 # \u03b3 -> bool) = {x | x \u2208 PREIMAGE ((FST :\u03b2 # \u03b3 -> \u03b2) \u2218 f) a \u2227 x \u2208 PREIMAGE ((SND :\u03b2 # \u03b3 -> \u03b3) \u2218 f) b}"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_UNION, pred_setTheory.ITSET_def, pred_setTheory.INTER_DEF, pred_setTheory.ITSET_EMPTY, pred_setTheory.GSPECIFICATION_applied]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ PREIMAGE Vf @ @ C$pred_set$ CROSS Va Vb @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ FST Vf Va @ @ C$bool$ IN Vx @ @ C$pred_set$ PREIMAGE @ @ C$combin$ o C$pair$ SND Vf Vb"}, "plain": {"assumptions": [], "goal": "PREIMAGE (f :\u03b1 -> \u03b2 # \u03b3) (((a :\u03b2 -> bool) \u00d7 (b :\u03b3 -> bool)) :\u03b2 # \u03b3 -> bool) = {x | x \u2208 PREIMAGE ((FST :\u03b2 # \u03b3 -> \u03b2) \u2218 f) a \u2227 x \u2208 PREIMAGE ((SND :\u03b2 # \u03b3 -> \u03b3) \u2218 f) b}"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_BIGINTER_IMAGE, pred_setTheory.CROSS_EQNS, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.COMPL_SPLITS, pred_setTheory.RINV_LO]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ C$bool$ ! | Vb @ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST @ Vf Vx Va @ @ C$bool$ IN @ C$pair$ SND @ Vf Vx Vb @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ C$pair$ FST @ Vf Vx Va @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ IN @ C$pair$ SND @ Vf Vx Vb"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 # \u03b3) (a :\u03b2 -> bool) (b :\u03b3 -> bool). {x | FST (f x) \u2208 a \u2227 SND (f x) \u2208 b} = {x | x \u2208 {x | FST (f x) \u2208 a} \u2227 x \u2208 {x | SND (f x) \u2208 b}}"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.BIGUNION_CROSS, pred_setTheory.UNION_applied, pred_setTheory.PREIMAGE_def, pred_setTheory.IN_CROSS, pred_setTheory.PSUBSET_INSERT_SUBSET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ Va @ C$pair$ FST @ Vf Vx @ Vb @ C$pair$ SND @ Vf Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ Va @ C$pair$ FST @ Vf Vx Vx @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ Vb @ C$pair$ SND @ Vf Vx Vx"}, "plain": {"assumptions": [], "goal": "{x | (a :\u03b2 -> bool) (FST ((f :\u03b1 -> \u03b2 # \u03b3) x)) \u2227 (b :\u03b3 -> bool) (SND (f x))} = {x | {x | a (FST (f x))} x \u2227 {x | b (SND (f x))} x}"}}], "parent": 3, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.ITSET_EMPTY, pred_setTheory.SUM_SET_SING]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ Va @ C$pair$ FST @ Vf Vx @ Vb @ C$pair$ SND @ Vf Vx Vx @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ Va @ C$pair$ FST @ Vf Vx Vx @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ Vb @ C$pair$ SND @ Vf Vx Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). {x | (a :\u03b2 -> bool) (FST ((f :\u03b1 -> \u03b2 # \u03b3) x)) \u2227 (b :\u03b3 -> bool) (SND (f x))} x \u21d4 {x | {x | a (FST (f x))} x \u2227 {x | b (SND (f x))} x} x"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.INSERT_DEF, pred_setTheory.EMPTY_DEF, boolTheory.FUN_EQ_THM, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPECIFICATION_applied, pred_setTheory.EMPTY_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.SUBSET_DEF]", "reward": 5}]], "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). LENGTH (MAP f l) = LENGTH l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf Vl @ C$list$ LENGTH Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). LENGTH (MAP f l) = LENGTH l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf C$list$ NIL @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). LENGTH (MAP f ([] :\u03b1 list)) = LENGTH ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf Vl @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). LENGTH (MAP f (l :\u03b1 list)) = LENGTH l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). LENGTH (MAP f (h::(l :\u03b1 list))) = LENGTH (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf Vl @ C$list$ LENGTH Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). LENGTH (MAP f (l :\u03b1 list)) = LENGTH l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). LENGTH (MAP f (h::(l :\u03b1 list))) = LENGTH (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, listTheory.HD, boolTheory.LEFT_AND_FORALL_THM, listTheory.MAP, listTheory.LENGTH]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.FLAT, listTheory.list_size_def, listTheory.NULL, listTheory.LENGTH]", "reward": 5}]], "\u2200(ls :\u03b1 list list). set (FLAT ls) = BIGUNION (set (MAP (set :\u03b1 list -> \u03b1 -> bool) ls))": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vls @ @ C$min$ = @ C$list$ LIST_TO_SET @ C$list$ FLAT Vls @ C$pred_set$ BIGUNION @ C$list$ LIST_TO_SET @ @ C$list$ MAP C$list$ LIST_TO_SET Vls"}, "plain": {"assumptions": [], "goal": "\u2200(ls :\u03b1 list list). set (FLAT ls) = BIGUNION (set (MAP (set :\u03b1 list -> \u03b1 -> bool) ls))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LIST_TO_SET @ C$list$ FLAT Vls @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs @ C$list$ LIST_TO_SET @ @ C$list$ MAP C$list$ LIST_TO_SET Vls @ @ C$bool$ IN Vx Vs"}, "plain": {"assumptions": [], "goal": "set (FLAT (ls :\u03b1 list list)) = {x | \u2203(s :\u03b1 -> bool). MEM s (MAP (set :\u03b1 list -> \u03b1 -> bool) ls) \u2227 x \u2208 s}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.BIGINTER_applied, pred_setTheory.BIJ_DEF, pred_setTheory.BIGUNION, pred_setTheory.COMPL_SPLITS, listTheory.SNOC_APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET Vls Vl @ @ C$list$ LIST_TO_SET Vl Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET @ @ C$list$ MAP C$list$ LIST_TO_SET Vls Vs @ Vs Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). (\u2203(l :\u03b1 list). set (ls :\u03b1 list list) l \u2227 set l x) \u21d4 \u2203(s :\u03b1 -> bool). set (MAP (set :\u03b1 list -> \u03b1 -> bool) ls) s \u2227 s x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.BIGUNION_IMAGE_UNIV, pred_setTheory.EXTENSION, listTheory.MEM_FLAT, listTheory.CONS_11]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET Vls Vl @ @ C$list$ LIST_TO_SET Vl Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET @ @ C$list$ MAP C$list$ LIST_TO_SET Vls Vs @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). set (ls :\u03b1 list list) l \u2227 set l (x :\u03b1)) \u21d4 \u2203(s :\u03b1 -> bool). set (MAP (set :\u03b1 list -> \u03b1 -> bool) ls) s \u2227 s x"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_EVERY_ZIP, pred_setTheory.IN_FUNSET, listTheory.NULL_FILTER, pred_setTheory.SUBSET_CROSS, pred_setTheory.IN_APP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET Vls Vl @ @ C$list$ LIST_TO_SET Vl Vx @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$min$ = Vs @ C$list$ LIST_TO_SET Vx @ @ C$list$ LIST_TO_SET Vls Vx @ Vs Vx"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). set (ls :\u03b1 list list) l \u2227 set l (x :\u03b1)) \u21d4 \u2203(s :\u03b1 -> bool). (\u2203(x :\u03b1 list). s = set x \u2227 set ls x) \u2227 s x"}}], "parent": 3, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, listTheory.LIST_TO_SET_MAP, pred_setTheory.DIFF_INTER_COMPL, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[boolTheory.MONO_OR, listTheory.NULL_FILTER, listTheory.EVERY_MEM, listTheory.LENGTH_EQ_NIL, listTheory.NOT_NULL_MEM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (n :num) (x :\u03b1). MAP f (REPLICATE n x) = REPLICATE n (f x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$rich_list$ REPLICATE Vn @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (n :num) (x :\u03b1). MAP f (REPLICATE n x) = REPLICATE n (f x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.DROP_LENGTH_APPEND, rich_listTheory.FLAT_SNOC, listTheory.MAP_GENLIST, rich_listTheory.REPLICATE_GENLIST, rich_listTheory.AND_EL_DEF]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 R\u207a x y": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$relation$ RTC VR Vx Vy @ @ C$bool$ \\/ @ @ C$min$ = Vx Vy @ @ @ C$relation$ TC VR Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1). R\ua673 x y \u21d4 x = y \u2228 R\u207a x y"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[relationTheory.TC_lifts_monotonicities, relationTheory.RTC_CASES1, boolTheory.DATATYPE_TAG_THM, boolTheory.DISJ_IMP_THM, relationTheory.EXTEND_RTC_TC_EQN]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (M :(\u03b1 -> bool) -> bool). IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | VM @ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ C$pred_set$ BIGUNION VM @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE @ C$pred_set$ IMAGE Vf VM"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (M :(\u03b1 -> bool) -> bool). IMAGE f (BIGUNION M) = BIGUNION (IMAGE (IMAGE f) M)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ IMAGE Vf @ C$pred_set$ BIGUNION VM @ C$pred_set$ BIGUNION @ @ C$pred_set$ IMAGE @ C$pred_set$ IMAGE Vf VM"}, "plain": {"assumptions": [], "goal": "IMAGE (f :\u03b1 -> \u03b2) (BIGUNION (M :(\u03b1 -> bool) -> bool)) = BIGUNION (IMAGE (IMAGE f) M)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INTER, pred_setTheory.FUNSET_THM, pred_setTheory.DISJOINT_DELETE_SYM, pred_setTheory.INSERT_DEF, boolTheory.RIGHT_OR_EXISTS_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf @ C$pred_set$ BIGUNION VM @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' VM @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vx'"}, "plain": {"assumptions": [], "goal": "(x :\u03b2) \u2208 IMAGE (f :\u03b1 -> \u03b2) (BIGUNION (M :(\u03b1 -> bool) -> bool)) \u21d4 \u2203(x' :\u03b1 -> bool). x' \u2208 M \u2227 x \u2208 IMAGE f x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EXTENSION, pred_setTheory.DISJOINT_DELETE_SYM, pred_setTheory.BIJ_SYM_IMP, pred_setTheory.DIFF_UNION, pred_setTheory.IN_BIGUNION_IMAGE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ C$bool$ ? | Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vs VM @ @ C$bool$ IN Vx' Vs @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' VM @ C$bool$ ? | Vx'' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx'' @ @ C$bool$ IN Vx'' Vx'"}, "plain": {"assumptions": [], "goal": "(\u2203(x' :\u03b1). (x :\u03b2) = (f :\u03b1 -> \u03b2) x' \u2227 \u2203(s :\u03b1 -> bool). s \u2208 (M :(\u03b1 -> bool) -> bool) \u2227 x' \u2208 s) \u21d4 \u2203(x' :\u03b1 -> bool). x' \u2208 M \u2227 \u2203(x'' :\u03b1). x = f x'' \u2227 x'' \u2208 x'"}}], "parent": 2, "goal": 0, "by_tactic": "simp[pred_setTheory.BIGUNION, pred_setTheory.COMPL_COMPL, pred_setTheory.IN_IMAGE, pred_setTheory.DIFF_INTER_COMPL, pred_setTheory.GSPECIFICATION]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.SUBSET_UNION, pred_setTheory.DIFF_applied, pred_setTheory.DIFF_INTER_COMPL, pred_setTheory.SCHROEDER_CLOSED]", "reward": 5}]], "\u2200(pl :(\u03b1 # \u03b2) list). LENGTH (FST (UNZIP pl)) = LENGTH pl \u2227 LENGTH (SND (UNZIP pl)) = LENGTH pl": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vpl @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ C$pair$ FST @ C$list$ UNZIP Vpl @ C$list$ LENGTH Vpl @ @ C$min$ = @ C$list$ LENGTH @ C$pair$ SND @ C$list$ UNZIP Vpl @ C$list$ LENGTH Vpl"}, "plain": {"assumptions": [], "goal": "\u2200(pl :(\u03b1 # \u03b2) list). LENGTH (FST (UNZIP pl)) = LENGTH pl \u2227 LENGTH (SND (UNZIP pl)) = LENGTH pl"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_SPLIT2, pairTheory.ELIM_PFORALL, listTheory.UNZIP_MAP, pairTheory.UNCURRY_VAR, listTheory.LENGTH_MAP]", "reward": 5}]], "INJ (LINV_OPT (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool)) (IMAGE f s) (IMAGE (SOME :\u03b2 -> \u03b2 option) s)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ @ C$pred_set$ INJ @ @ C$pred_set$ LINV_OPT Vf Vs @ @ C$pred_set$ IMAGE Vf Vs @ @ C$pred_set$ IMAGE C$option$ SOME Vs"}, "plain": {"assumptions": [], "goal": "INJ (LINV_OPT (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool)) (IMAGE f s) (IMAGE (SOME :\u03b2 -> \u03b2 option) s)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ @ C$bool$ IN @ @ @ C$pred_set$ LINV_OPT Vf Vs Vx @ @ C$pred_set$ IMAGE C$option$ SOME Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ @ C$min$ ==> @ @ C$min$ = @ @ @ C$pred_set$ LINV_OPT Vf Vs Vx @ @ @ C$pred_set$ LINV_OPT Vf Vs Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 IMAGE (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool) \u21d2 LINV_OPT f s x \u2208 IMAGE (SOME :\u03b2 -> \u03b2 option) s) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 IMAGE f s \u2227 y \u2208 IMAGE f s \u21d2 LINV_OPT f s x = LINV_OPT f s y \u21d2 x = y"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_UNION, pred_setTheory.INJ_DEF, pred_setTheory.IMAGE_applied, pred_setTheory.DELETE_applied, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ @ C$bool$ IN @ C$option$ SOME @ C$min$ @ | Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$min$ = @ Vf Vx' Vx @ @ C$pred_set$ IMAGE C$option$ SOME Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE Vf Vs @ @ C$bool$ IN Vy @ @ C$pred_set$ IMAGE Vf Vs @ @ C$min$ ==> @ @ C$min$ = @ C$min$ @ | Vx' @ @ C$bool$ /\\ @ @ C$bool$ IN Vx' Vs @ @ C$min$ = @ Vf Vx' Vx @ C$min$ @ | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ Vf Vx Vy @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 IMAGE (f :\u03b2 -> \u03b1) (s :\u03b2 -> bool) \u21d2 SOME (@(x' :\u03b2). x' \u2208 s \u2227 f x' = x) \u2208 IMAGE (SOME :\u03b2 -> \u03b2 option) s) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 IMAGE f s \u2227 y \u2208 IMAGE f s \u21d2 (@(x' :\u03b2). x' \u2208 s \u2227 f x' = x) = (@(x :\u03b2). x \u2208 s \u2227 f x = y) \u21d2 x = y"}}], "parent": 1, "goal": 0, "by_tactic": "simp[pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.PSUBSET_DEF, pred_setTheory.LINV_OPT_def, pred_setTheory.FUNSET_applied, pred_setTheory.IMAGE_COMPOSE]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.SING_DELETE, pred_setTheory.SPECIFICATION, pred_setTheory.IMAGE_applied, pred_setTheory.SUBSET_DELETE]", "reward": 5}]], "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b2). P \u00d7 (x INSERT Q) = P \u00d7 {x} \u222a P \u00d7 Q": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | VQ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ CROSS VP @ @ C$pred_set$ INSERT Vx VQ @ @ C$pred_set$ UNION @ @ C$pred_set$ CROSS VP @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$pred_set$ CROSS VP VQ"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> bool) (Q :\u03b2 -> bool) (x :\u03b2). P \u00d7 (x INSERT Q) = P \u00d7 {x} \u222a P \u00d7 Q"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp VP @ @ C$bool$ IN @ C$pair$ SND Vp @ @ C$pred_set$ INSERT Vx VQ @ @ C$bool$ IN Vx' @ @ C$pred_set$ UNION @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp VP @ @ C$bool$ IN @ C$pair$ SND Vp @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ C$pred_set$ GSPEC | Vp @ @ C$pair$ , Vp @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vp VP @ @ C$bool$ IN @ C$pair$ SND Vp VQ"}, "plain": {"assumptions": [], "goal": "(x' :\u03b1 # \u03b2) \u2208 {p | FST p \u2208 (P :\u03b1 -> bool) \u2227 SND p \u2208 (x :\u03b2) INSERT (Q :\u03b2 -> bool)} \u21d4 x' \u2208 {p | FST p \u2208 P \u2227 SND p \u2208 {x}} \u222a {p | FST p \u2208 P \u2227 SND p \u2208 Q}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.EMPTY_UNION, pred_setTheory.CROSS_DEF, boolTheory.LEFT_OR_OVER_AND, pred_setTheory.EXTENSION, pred_setTheory.IN_BIGUNION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ VP @ C$pair$ FST Vx' @ @ @ C$pred_set$ INSERT Vx VQ @ C$pair$ SND Vx' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ VP @ C$pair$ FST Vx' @ @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ C$pair$ SND Vx' @ @ C$bool$ /\\ @ VP @ C$pair$ FST Vx' @ VQ @ C$pair$ SND Vx'"}, "plain": {"assumptions": [], "goal": "(P :\u03b1 -> bool) (FST (x' :\u03b1 # \u03b2)) \u2227 ((x :\u03b2) INSERT (Q :\u03b2 -> bool)) (SND x') \u21d4 P (FST x') \u2227 {x} (SND x') \u2228 P (FST x') \u2227 Q (SND x')"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.IN_BIGINTER, pred_setTheory.GSPEC_ETA, pred_setTheory.UNION_DEF, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.REST_SING, pred_setTheory.SUBSET_FINITE_I, pred_setTheory.INSERT_applied, pred_setTheory.IN_SING]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 s DIFF t \u2260 (\u2205 :\u03b1 -> bool)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ~ @ C$pred_set$ FINITE Vs @ C$pred_set$ FINITE Vt @ C$bool$ ~ @ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vt C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b1 -> bool). INFINITE s \u2227 FINITE t \u21d2 s DIFF t \u2260 (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$pred_set$ FINITE Vt", "@ C$bool$ ~ @ C$pred_set$ FINITE Vs"], "goal": "@ C$bool$ ~ @ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vt C$pred_set$ EMPTY"}, "plain": {"assumptions": ["FINITE (t :\u03b1 -> bool)", "INFINITE (s :\u03b1 -> bool)"], "goal": "(s :\u03b1 -> bool) DIFF (t :\u03b1 -> bool) \u2260 (\u2205 :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_INSERT, pred_setTheory.COUNT_applied, pred_setTheory.INSERT_DEF, pred_setTheory.FUNSET_INTER, boolTheory.NOT_F]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$pred_set$ DIFF Vs Vt C$pred_set$ EMPTY", "@ C$pred_set$ FINITE Vt", "@ C$bool$ ~ @ C$pred_set$ FINITE Vs"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["(s :\u03b1 -> bool) DIFF (t :\u03b1 -> bool) = (\u2205 :\u03b1 -> bool)", "FINITE (t :\u03b1 -> bool)", "INFINITE (s :\u03b1 -> bool)"], "goal": "F"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SURJ_DEF, pred_setTheory.INJ_DEF, pred_setTheory.INJ_DEF, pred_setTheory.PSUBSET_INSERT_SUBSET, boolTheory.COND_CLAUSES]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.NOT_IN_EMPTY, pred_setTheory.FINITE_DIFF_down, pred_setTheory.FINITE_EMPTY, pred_setTheory.UNIV_applied, pred_setTheory.FINITE_COUNT]", "reward": 5}]], "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b1 -> \u03b2 -> \u03b2) (f' :\u03b1 -> \u03b2 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f x a = f' x a) \u21d2 FOLDR f b l = FOLDR f' b' l'": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb Vl @ @ @ C$list$ FOLDR Vf' Vb' Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b1 -> \u03b2 -> \u03b2) (f' :\u03b1 -> \u03b2 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f x a = f' x a) \u21d2 FOLDR f b l = FOLDR f' b' l'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb Vl @ @ @ C$list$ FOLDR Vf' Vb Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (a :\u03b2). MEM x (l :\u03b1 list) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a"], "goal": "FOLDR (f :\u03b1 -> \u03b2 -> \u03b2) (b :\u03b2) (l :\u03b1 list) = FOLDR (f' :\u03b1 -> \u03b2 -> \u03b2) b l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.APPEND_LENGTH_EQ, boolTheory.AND_CLAUSES, listTheory.FOLDR, listTheory.MAP2, listTheory.MAP2]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb C$list$ NIL @ @ @ C$list$ FOLDR Vf' Vb C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (a :\u03b2). MEM x ([] :\u03b1 list) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a) \u21d2 FOLDR f (b :\u03b2) ([] :\u03b1 list) = FOLDR f' b ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb Vl @ @ @ C$list$ FOLDR Vf' Vb Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR Vf' Vb @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(\u2200(x :\u03b1) (a :\u03b2). MEM x (l :\u03b1 list) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a) \u21d2 FOLDR f (b :\u03b2) l = FOLDR f' b l"], "goal": "\u2200(h :\u03b1). (\u2200(x :\u03b1) (a :\u03b2). MEM x (h::(l :\u03b1 list)) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a) \u21d2 FOLDR f (b :\u03b2) (h::l) = FOLDR f' b (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb Vl @ @ @ C$list$ FOLDR Vf' Vb Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ Vf Vx Va @ @ Vf' Vx Va @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Vb @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDR Vf' Vb @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(\u2200(x :\u03b1) (a :\u03b2). MEM x (l :\u03b1 list) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a) \u21d2 FOLDR f (b :\u03b2) l = FOLDR f' b l"], "goal": "\u2200(h :\u03b1). (\u2200(x :\u03b1) (a :\u03b2). MEM x (h::(l :\u03b1 list)) \u21d2 (f :\u03b1 -> \u03b2 -> \u03b2) x a = (f' :\u03b1 -> \u03b2 -> \u03b2) x a) \u21d2 FOLDR f (b :\u03b2) (h::l) = FOLDR f' b (h::l)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_rules, listTheory.LIST_REL_SPLIT2, listTheory.FOLDR, listTheory.MAP2, listTheory.MAP2]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[boolTheory.NOT_CLAUSES, listTheory.FOLDR, listTheory.LIST_REL_SPLIT1, listTheory.LENGTH, listTheory.MEM]", "reward": 5}]], "\u2200(x :\u03b1 + \u03b2). \u00acISL x \u21d4 ISR x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$bool$ ~ @ C$sum$ ISL Vx @ C$sum$ ISR Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 + \u03b2). \u00acISL x \u21d4 ISR x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[sumTheory.ISR, boolTheory.IMP_CONG, sumTheory.ISL, boolTheory.EXISTS_UNIQUE_REFL, sumTheory.sum_CASES]", "reward": 5}]], "MAX (0 :num) (x :num) = x \u2227 MAX x (0 :num) = x \u2227 MAX (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then y else x)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$arithmetic$ MAX C$num$ 0 Vx Vx @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$arithmetic$ MAX Vx C$num$ 0 Vx @ @ C$min$ = @ @ C$arithmetic$ MAX @ C$arithmetic$ NUMERAL Vx @ C$arithmetic$ NUMERAL Vy @ C$arithmetic$ NUMERAL @ @ @ C$bool$ COND @ @ C$prim_rec$ < Vx Vy Vy Vx"}, "plain": {"assumptions": [], "goal": "MAX (0 :num) (x :num) = x \u2227 MAX x (0 :num) = x \u2227 MAX (NUMERAL x) (NUMERAL (y :num)) = NUMERAL (if x < y then y else x)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.NUMERAL_DEF, prim_recTheory.measure_thm, arithmeticTheory.MIN_COMM, arithmeticTheory.DIV2_def, arithmeticTheory.MAX_DEF]", "reward": 5}]], "\u2200(x :\u03b1) (y :\u03b2). {x} \u00d7 {y} = {(x,y)}": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$pred_set$ CROSS @ @ C$pred_set$ INSERT Vx C$pred_set$ EMPTY @ @ C$pred_set$ INSERT Vy C$pred_set$ EMPTY @ @ C$pred_set$ INSERT @ @ C$pair$ , Vx Vy C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (y :\u03b2). {x} \u00d7 {y} = {(x,y)}"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ CROSS @ @ C$pred_set$ INSERT Vx | Vx C$bool$ F @ @ C$pred_set$ INSERT Vy | Vx C$bool$ F @ @ C$pred_set$ INSERT @ @ C$pair$ , Vx Vy | Vx C$bool$ F"}, "plain": {"assumptions": [], "goal": "((((x :\u03b1) INSERT (\u03bb(x :\u03b1). F)) \u00d7 ((y :\u03b2) INSERT (\u03bb(x :\u03b2). F))) :\u03b1 # \u03b2 -> bool) = (x,y) INSERT (\u03bb(x :\u03b1 # \u03b2). F)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SURJ_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.BIJ_DEF, pred_setTheory.FUNSET_INTER, pred_setTheory.COUNT_NOT_EMPTY]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ CROSS @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$min$ = Vy Vx @ C$pred_set$ GSPEC | Vy' @ @ C$pair$ , Vy' @ @ C$min$ = Vy' Vy @ C$pred_set$ GSPEC | Vy' @ @ C$pair$ , Vy' @ @ C$min$ = Vy' @ @ C$pair$ , Vx Vy"}, "plain": {"assumptions": [], "goal": "(({y | y = (x :\u03b1)} \u00d7 {y' | y' = (y :\u03b2)}) :\u03b1 # \u03b2 -> bool) = {y' | y' = (x,y)}"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.IN_IMAGE, pred_setTheory.INSERT_DEF, pred_setTheory.IN_FUNSET, pred_setTheory.CROSS_EMPTY]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "simp[pred_setTheory.CROSS_DEF, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.REST_DEF, pred_setTheory.GSPECIFICATION_applied, pairTheory.PAIR_FST_SND_EQ]", "reward": 5}]], "\u2200(x :\u03b1 + \u03b2). ISL x \u2228 ISR x": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$bool$ \\/ @ C$sum$ ISL Vx @ C$sum$ ISR Vx"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 + \u03b2). ISL x \u2228 ISR x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[sumTheory.ISR, boolTheory.bool_INDUCT, sumTheory.ISL, sumTheory.ISL, sumTheory.sum_CASES]", "reward": 5}]], "\u2200(n :num) (m :num). n < m \u21d2 tri n < tri m": [22, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num). n < m \u21d2 tri n < tri m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn Vm"], "goal": "@ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"}, "plain": {"assumptions": ["(n :num) < (m :num)"], "goal": "tri (n :num) < tri (m :num)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_TRANS, arithmeticTheory.LESS_MONO_REV, numpairTheory.tri_eq_0, boolTheory.EQ_REFL, numpairTheory.tri_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"}, "plain": {"assumptions": [], "goal": "\u00ac((n :num) < (m :num)) \u2228 tri n < tri m"}}], "parent": 0, "goal": 0, "by_tactic": "rw[arithmeticTheory.LESS_MONO_REV, boolTheory.SELECT_REFL_2, boolTheory.IMP_DISJ_THM, prim_recTheory.PRIM_REC_FUN, prim_recTheory.TC_IM_RTC_SUC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < Vn Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"}, "plain": {"assumptions": [], "goal": "(n :num) < (m :num) \u21d2 tri n < tri m"}}], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.CONJ_ASSOC, boolTheory.DISJ_EQ_IMP, arithmeticTheory.LESS_MONO_REV, boolTheory.RIGHT_AND_OVER_OR, boolTheory.BOUNDED_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn C$num$ 0 @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u00ac((n :num) < (0 :num)) \u2228 tri n < tri (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"}, "plain": {"assumptions": ["\u00ac((n :num) < (m :num)) \u2228 tri n < tri m"], "goal": "\u00ac((n :num) < SUC (m :num)) \u2228 tri n < tri (SUC m)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `m`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"}, "plain": {"assumptions": ["\u00ac((n :num) < (m :num)) \u2228 tri n < tri m"], "goal": "\u00ac((n :num) < SUC (m :num)) \u2228 tri n < tri (SUC m)"}}], "parent": 4, "goal": 0, "by_tactic": "fs[prim_recTheory.LESS_NOT_EQ, prim_recTheory.LESS_THM, arithmeticTheory.LESS_MONO_EQ, boolTheory.DISJ_COMM, prim_recTheory.INV_SUC_EQ]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn @ C$num$ SUC Vm @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx @ C$numpair$ tri Vn @ @ C$arithmetic$ + @ C$num$ SUC Vm @ C$numpair$ tri Vm"}, "plain": {"assumptions": ["\u00ac(\u03bb(x :num) (y :num). y = SUC x)\u207a (n :num) (m :num)"], "goal": "\u00ac(\u03bb(x :num) (y :num). y = SUC x)\u207a (n :num) (SUC (m :num)) \u2228 (\u03bb(x :num) (y :num). y = SUC x)\u207a (tri n) (SUC m + tri m)"}}, {"polished": {"assumptions": ["@ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx @ C$numpair$ tri Vn @ C$numpair$ tri Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn @ C$num$ SUC Vm @ @ @ C$relation$ TC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx @ C$numpair$ tri Vn @ @ C$arithmetic$ + @ C$num$ SUC Vm @ C$numpair$ tri Vm"}, "plain": {"assumptions": ["(\u03bb(x :num) (y :num). y = SUC x)\u207a (tri (n :num)) (tri (m :num))"], "goal": "\u00ac(\u03bb(x :num) (y :num). y = SUC x)\u207a (n :num) (SUC (m :num)) \u2228 (\u03bb(x :num) (y :num). y = SUC x)\u207a (tri n) (SUC m + tri m)"}}], "parent": 5, "goal": 0, "by_tactic": "fs[numpairTheory.tri_def, prim_recTheory.SIMP_REC_REL_UNIQUE_RESULT, prim_recTheory.LESS_SUC, boolTheory.LET_DEF, prim_recTheory.LESS_ALT]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$prim_rec$ < Vn C$num$ 0 @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC C$num$ 0 @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC C$num$ 0"}, "plain": {"assumptions": [], "goal": "\u00ac((n :num) < (0 :num)) \u21d2 \u00ac(n < SUC (0 :num)) \u2228 tri n < tri (SUC (0 :num))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$prim_rec$ < Vn Vm @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC @ C$num$ SUC Vm"}, "plain": {"assumptions": ["\u00ac((n :num) < (m :num)) \u21d2 \u00ac(n < SUC m) \u2228 tri n < tri (SUC m)"], "goal": "\u00ac((n :num) < SUC (m :num)) \u21d2 \u00ac(n < SUC (SUC m)) \u2228 tri n < tri (SUC (SUC m))"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri C$num$ 0 @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC C$num$ 0 @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC C$num$ 0"}, "plain": {"assumptions": [], "goal": "tri (n :num) < tri (0 :num) \u21d2 \u00ac(n < SUC (0 :num)) \u2228 tri n < tri (SUC (0 :num))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"], "goal": "@ @ C$min$ ==> @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC @ C$num$ SUC Vm"}, "plain": {"assumptions": ["tri (n :num) < tri (m :num) \u21d2 \u00ac(n < SUC m) \u2228 tri n < tri (SUC m)"], "goal": "tri (n :num) < tri (SUC (m :num)) \u21d2 \u00ac(n < SUC (SUC m)) \u2228 tri n < tri (SUC (SUC m))"}}], "parent": 5, "goal": 0, "by_tactic": "Induct_on `m`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$prim_rec$ < Vn Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"}, "plain": {"assumptions": ["\u00ac((n :num) < (m :num))"], "goal": "\u00ac((n :num) < SUC (m :num)) \u2228 tri n < tri (SUC m)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri Vm"], "goal": "@ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$prim_rec$ < Vn @ C$num$ SUC Vm @ @ C$prim_rec$ < @ C$numpair$ tri Vn @ C$numpair$ tri @ C$num$ SUC Vm"}, "plain": {"assumptions": ["tri (n :num) < tri (m :num)"], "goal": "\u00ac((n :num) < SUC (m :num)) \u2228 tri n < tri (SUC m)"}}], "parent": 5, "goal": 0, "by_tactic": "rw[boolTheory.NOT_CLAUSES, boolTheory.LEFT_AND_CONG, boolTheory.EQ_IMP_THM, boolTheory.RES_ABSTRACT_DEF, boolTheory.ITSELF_UNIQUE]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "rw[numpairTheory.tri_def, prim_recTheory.TC_IM_RTC_SUC, boolTheory.IN_DEF, prim_recTheory.LESS_THM, prim_recTheory.SIMP_REC_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). FINITE (s DIFF t)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ ==> @ C$pred_set$ FINITE Vs @ C$bool$ ! | Vt @ C$pred_set$ FINITE @ @ C$pred_set$ DIFF Vs Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). FINITE s \u21d2 \u2200(t :\u03b1 -> bool). FINITE (s DIFF t)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ C$pred_set$ FINITE Vs"], "goal": "@ C$pred_set$ FINITE @ @ C$pred_set$ DIFF Vs Vt"}, "plain": {"assumptions": ["FINITE (s :\u03b1 -> bool)"], "goal": "FINITE ((s :\u03b1 -> bool) DIFF (t :\u03b1 -> bool))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DISJOINT, boolTheory.BOOL_FUN_CASES_THM, pred_setTheory.BIJ_DEF, boolTheory.IMP_ANTISYM_AX, boolTheory.SWAP_EXISTS_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SUBSET_OF_INSERT, pred_setTheory.SUBSET_FINITE_I, pred_setTheory.IN_DIFF, pred_setTheory.SUBSET_DEF, pred_setTheory.UNION_applied]", "reward": 5}]], "\ud835\udd4c(:\u03b1 + \u03b2) = IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b1) \u222a IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b2)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = C$pred_set$ UNIV @ @ C$pred_set$ UNION @ @ C$pred_set$ IMAGE C$sum$ INL C$pred_set$ UNIV @ @ C$pred_set$ IMAGE C$sum$ INR C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1 + \u03b2) = IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b1) \u222a IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = C$pred_set$ UNIV @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE C$sum$ INL C$pred_set$ UNIV @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE C$sum$ INR C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1 + \u03b2) = {x | x \u2208 IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b1) \u2228 x \u2208 IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) \ud835\udd4c(:\u03b2)}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.BIJ_SYM_IMP, pred_setTheory.INTER_applied, pred_setTheory.SCHROEDER_BERNSTEIN_AUTO, pred_setTheory.UNION_DEF, pred_setTheory.INTER_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx | Vx C$bool$ T @ @ C$bool$ IN Vx @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ \\/ @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE C$sum$ INL | Vx C$bool$ T @ @ C$bool$ IN Vx @ @ C$pred_set$ IMAGE C$sum$ INR | Vx C$bool$ T"}, "plain": {"assumptions": [], "goal": "(x :\u03b1 + \u03b2) \u2208 (\u03bb(x :\u03b1 + \u03b2). T) \u21d4 x \u2208 {x | x \u2208 IMAGE (INL :\u03b1 -> \u03b1 + \u03b2) (\u03bb(x :\u03b1). T) \u2228 x \u2208 IMAGE (INR :\u03b2 -> \u03b1 + \u03b2) (\u03bb(x :\u03b2). T)}"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.DISJOINT_BIGUNION, pred_setTheory.UNIV_DEF, sumTheory.INR_INL_11, pred_setTheory.EXTENSION, pred_setTheory.SUBSET_ADD]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA, sumTheory.sum_INDUCT, pred_setTheory.IMAGE_applied, pred_setTheory.IN_UNION]", "reward": 5}]], "\u2200(x :\u03b1) (xs :\u03b1 list). LENGTH (FRONT (x::xs)) = LENGTH xs": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vxs @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs @ C$list$ LENGTH Vxs"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (xs :\u03b1 list). LENGTH (FRONT (x::xs)) = LENGTH xs"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx C$list$ NIL @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). LENGTH (FRONT [x]) = LENGTH ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs @ C$list$ LENGTH Vxs"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vxs @ C$list$ LENGTH @ @ C$list$ CONS Vh Vxs"}, "plain": {"assumptions": ["\u2200(x :\u03b1). LENGTH (FRONT (x::(xs :\u03b1 list))) = LENGTH xs"], "goal": "\u2200(h :\u03b1) (x :\u03b1). LENGTH (FRONT (x::h::(xs :\u03b1 list))) = LENGTH (h::xs)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `xs`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx Vxs @ C$list$ LENGTH Vxs"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ LENGTH @ C$list$ FRONT @ @ C$list$ CONS Vx @ @ C$list$ CONS Vh Vxs @ C$list$ LENGTH @ @ C$list$ CONS Vh Vxs"}, "plain": {"assumptions": ["\u2200(x :\u03b1). LENGTH (FRONT (x::(xs :\u03b1 list))) = LENGTH xs"], "goal": "\u2200(h :\u03b1) (x :\u03b1). LENGTH (FRONT (x::h::(xs :\u03b1 list))) = LENGTH (h::xs)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.NULL, listTheory.LIST_REL_EVERY_ZIP, listTheory.FRONT_DEF, listTheory.LENGTH_EQ_SUM, listTheory.LIST_REL_EVERY_ZIP]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.DISJ_IMP_THM, listTheory.FRONT_CONS, listTheory.LENGTH, listTheory.UNZIP, listTheory.MAP]", "reward": 5}]], "\u2200(l :bool list). AND_EL l \u21d4 FOLDL $/\\ T l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$rich_list$ AND_EL Vl @ @ @ C$list$ FOLDL C$bool$ /\\ C$bool$ T Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :bool list). AND_EL l \u21d4 FOLDL $/\\ T l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.SWAP_REVERSE, rich_listTheory.EVERY_FOLDL_MAP, listTheory.SINGL_APPLY_MAP, rich_listTheory.AND_EL_DEF, boolTheory.LEFT_OR_EXISTS_THM]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). COMPL s \u2229 s = (\u2205 :\u03b1 -> bool) \u2227 COMPL s \u222a s = \ud835\udd4c(:\u03b1)": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vs Vs C$pred_set$ EMPTY @ @ C$min$ = @ @ C$pred_set$ UNION @ C$pred_set$ COMPL Vs Vs C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). COMPL s \u2229 s = (\u2205 :\u03b1 -> bool) \u2227 COMPL s \u222a s = \ud835\udd4c(:\u03b1)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ INTER @ C$pred_set$ COMPL Vs Vs @ @ C$bool$ IN Vx | Vx C$bool$ F @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ @ C$pred_set$ UNION @ C$pred_set$ COMPL Vs Vs @ @ C$bool$ IN Vx C$pred_set$ UNIV"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2200(x :\u03b1). x \u2208 COMPL s \u2229 s \u21d4 x \u2208 (\u03bb(x :\u03b1). F)) \u2227 \u2200(x :\u03b1). x \u2208 COMPL s \u222a s \u21d4 x \u2208 \ud835\udd4c(:\u03b1)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.ETA_THM, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_INSERT, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ @ C$pred_set$ COMPL Vs Vx @ Vs Vx Vx @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$pred_set$ UNION @ C$pred_set$ COMPL Vs Vs Vx @ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2200(x :\u03b1). \u00ac{x | COMPL s x \u2227 s x} x) \u2227 \u2200(x :\u03b1). (COMPL s \u222a s) x \u21d4 \ud835\udd4c(:\u03b1) x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.INTER_DEF, pred_setTheory.disjUNION_def, pred_setTheory.BIGUNION, pred_setTheory.SUBSET_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx @ @ C$bool$ /\\ @ C$bool$ ~ @ Vs Vx @ Vs Vx Vx @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$pred_set$ GSPEC | Vx @ @ C$pair$ , Vx C$bool$ T Vx @ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). (\u2200(x :\u03b1). \u00ac{x | \u00acs x \u2227 s x} x) \u2227 \u2200(x :\u03b1). {x | T} x \u21d4 \ud835\udd4c(:\u03b1) x"}}], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.COMPL_applied, pred_setTheory.UNION_DEF, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.INSERT_UNIV]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$pred_set$ UNIV Vx"}, "plain": {"assumptions": [], "goal": "\ud835\udd4c(:\u03b1) (x :\u03b1)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.IMAGE_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.GSPEC_ETA, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "rw[pred_setTheory.UNIV_applied, pred_setTheory.INTER_DEF, pred_setTheory.SUBSET_BIGUNION, boolTheory.IN_DEF, pred_setTheory.IMAGE_II]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). BIJ f (\u2205 :\u03b1 -> bool) s \u21d4 s = (\u2205 :\u03b2 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). BIJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ @ C$pred_set$ BIJ Vf C$pred_set$ EMPTY Vs @ @ C$min$ = Vs C$pred_set$ EMPTY @ C$bool$ ! | Vs @ @ C$min$ = @ @ @ C$pred_set$ BIJ Vf Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). BIJ f (\u2205 :\u03b1 -> bool) s \u21d4 s = (\u2205 :\u03b2 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). BIJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ @ @ C$pred_set$ INJ Vf C$pred_set$ EMPTY Vs @ @ @ C$pred_set$ SURJ Vf C$pred_set$ EMPTY Vs @ @ C$min$ = Vs C$pred_set$ EMPTY @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ @ @ C$pred_set$ INJ Vf Vs C$pred_set$ EMPTY @ @ @ C$pred_set$ SURJ Vf Vs C$pred_set$ EMPTY @ @ C$min$ = Vs C$pred_set$ EMPTY"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). INJ f (\u2205 :\u03b1 -> bool) s \u2227 SURJ f (\u2205 :\u03b1 -> bool) s \u21d4 s = (\u2205 :\u03b2 -> bool)) \u2227 \u2200(s :\u03b1 -> bool). INJ f s (\u2205 :\u03b2 -> bool) \u2227 SURJ f s (\u2205 :\u03b2 -> bool) \u21d4 s = (\u2205 :\u03b1 -> bool)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[pred_setTheory.DISJOINT_SYM, pred_setTheory.BIJ_DEF, pred_setTheory.UNION_DEF, pred_setTheory.IMAGE_DEF, pred_setTheory.IMAGE_SING]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$bool$ /\\ @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN @ Vf Vx Vs @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN Vy C$pred_set$ EMPTY @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ @ C$bool$ IN @ Vf Vx Vs @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy C$pred_set$ EMPTY @ @ C$min$ = @ Vf Vy Vx @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ! | Vs @ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx C$pred_set$ EMPTY @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx C$pred_set$ EMPTY @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). (\u2200(s :\u03b2 -> bool). ((\u2200(x :\u03b1). x \u2208 (\u2205 :\u03b1 -> bool) \u21d2 f x \u2208 s) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 (\u2205 :\u03b1 -> bool) \u2227 y \u2208 (\u2205 :\u03b1 -> bool) \u21d2 f x = f y \u21d2 x = y) \u2227 (\u2200(x :\u03b1). x \u2208 (\u2205 :\u03b1 -> bool) \u21d2 f x \u2208 s) \u2227 (\u2200(x :\u03b2). x \u2208 s \u21d2 \u2203(y :\u03b1). y \u2208 (\u2205 :\u03b1 -> bool) \u2227 f y = x) \u21d4 \u2200(x :\u03b2). s x \u21d4 \u2205 x) \u2227 \u2200(s :\u03b1 -> bool). ((\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 (\u2205 :\u03b2 -> bool)) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 f x = f y \u21d2 x = y) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 (\u2205 :\u03b2 -> bool)) \u2227 (\u2200(x :\u03b2). x \u2208 (\u2205 :\u03b2 -> bool) \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 f y = x) \u21d4 \u2200(x :\u03b1). s x \u21d4 \u2205 x"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.INTER_applied, pred_setTheory.SURJ_DEF, boolTheory.FUN_EQ_THM, pred_setTheory.INJ_DEF, pred_setTheory.REST_applied]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.INTER_UNIV, pred_setTheory.EMPTY_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.DIFF_applied]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\u207a x z": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ @ C$relation$ RTC VR Vy Vz @ @ @ C$relation$ TC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R\ua673 y z \u21d2 R\u207a x z"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vy Vz Vt Vt @ @ @ C$relation$ TC VR Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). (\u2200(t :bool). (R x y \u21d2 R\ua673 y z \u21d2 t) \u21d2 t) \u21d2 R\u207a x z"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.FUN_EQ_THM, boolTheory.OR_INTRO_THM2, relationTheory.TC_SUBSET, boolTheory.EQ_IMP_THM, boolTheory.AND_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC VR Vy Vz Vt Vt @ C$bool$ ! | VP @ @ C$min$ ==> @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VP Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz @ @ VP Vx Vz"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) (z :\u03b1). (\u2200(t :bool). (R x y \u21d2 R\ua673 y z \u21d2 t) \u21d2 t) \u21d2 \u2200(P :\u03b1 -> \u03b1 -> bool). (\u2200(x :\u03b1) (y :\u03b1). R x y \u21d2 P x y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). P x y \u2227 P y z \u21d2 P x z) \u21d2 P x z"}}], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.RC_DEF, relationTheory.TC_DEF, relationTheory.TC_SUBSET, relationTheory.EQC_DEF, boolTheory.BETA_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vx Vy @ @ VP Vy Vz @ @ VP Vx Vz", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ VR Vx Vy @ @ VP Vx Vy", "@ C$bool$ ! | Vt @ @ C$min$ ==> @ @ C$min$ ==> @ @ VR Vx Vy @ @ C$min$ ==> @ C$bool$ ! | VQ @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vy @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ VQ Vy @ @ VR Vy Vz @ VQ Vz @ VQ Vz Vt Vt"], "goal": "@ @ VP Vx Vz"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). (P :\u03b1 -> \u03b1 -> bool) x y \u2227 P y z \u21d2 P x z", "\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u21d2 (P :\u03b1 -> \u03b1 -> bool) x y", "\u2200(t :bool). ((R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (y :\u03b1) \u21d2 (\u2200(Q :\u03b1 -> bool). Q y \u2227 (\u2200(y :\u03b1) (z :\u03b1). Q y \u2227 R y z \u21d2 Q z) \u21d2 Q (z :\u03b1)) \u21d2 t) \u21d2 t"], "goal": "(P :\u03b1 -> \u03b1 -> bool) (x :\u03b1) (z :\u03b1)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[relationTheory.RTC_ALT_RIGHT_DEF, relationTheory.RTC_RULES_RIGHT1, boolTheory.EXISTS_SIMP, boolTheory.EQ_IMP_THM, boolTheory.DISJ_COMM]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[boolTheory.IMP_F_EQ_F, boolTheory.DE_MORGAN_THM, boolTheory.NOT_IMP, relationTheory.symmetric_RC, boolTheory.EQ_SYM]", "reward": 5}]], "\u2200(M :\u03b1 list) (N :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = N \u2227 (\u2200(x :\u03b1). MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | VN @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VN @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET VN @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' VN"}, "plain": {"assumptions": [], "goal": "\u2200(M :\u03b1 list) (N :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = N \u2227 (\u2200(x :\u03b1). MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VM @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM C$list$ NIL @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(M :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = ([] :\u03b1 list) \u2227 (\u2200(x :\u03b1). MEM x ([] :\u03b1 list) \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | VM @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VN @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET VN @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' VN"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VM @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM @ @ C$list$ CONS Vh VN @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VN @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' @ @ C$list$ CONS Vh VN"}, "plain": {"assumptions": ["\u2200(M :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = (N :\u03b1 list) \u2227 (\u2200(x :\u03b1). MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N"], "goal": "\u2200(h :\u03b1) (M :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = h::(N :\u03b1 list) \u2227 (\u2200(x :\u03b1). MEM x (h::N) \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' (h::N)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `N`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | VM @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM VN @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET VN @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' VN"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | VM @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = VM @ @ C$list$ CONS Vh VN @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VN @ @ C$min$ = @ Vf Vx @ Vf' Vx @ @ C$min$ = @ @ C$list$ list_size Vf VM @ @ C$list$ list_size Vf' @ @ C$list$ CONS Vh VN"}, "plain": {"assumptions": ["\u2200(M :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = (N :\u03b1 list) \u2227 (\u2200(x :\u03b1). MEM x N \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' N"], "goal": "\u2200(h :\u03b1) (M :\u03b1 list) (f :\u03b1 -> num) (f' :\u03b1 -> num). M = h::(N :\u03b1 list) \u2227 (\u2200(x :\u03b1). MEM x (h::N) \u21d2 f x = f' x) \u21d2 list_size f M = list_size f' (h::N)"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.LIST_EQ_REWRITE, listTheory.LIST_REL_SPLIT1, listTheory.MAP2_APPEND, listTheory.LIST_REL_cases, listTheory.list_size_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.SUM_eq_0, boolTheory.PULL_EXISTS, listTheory.list_size_def, listTheory.LENGTH, listTheory.MEM]", "reward": 5}]], "\u2200(m :num) (n :num). n \u2264 n \u2297 m": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$arithmetic$ <= Vn @ @ C$numpair$ npair Vn Vm"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). n \u2264 n \u2297 m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ @ C$arithmetic$ <= C$num$ 0 @ @ C$numpair$ npair C$num$ 0 Vm"}, "plain": {"assumptions": [], "goal": "\u2200(m :num). (0 :num) \u2264 (0 :num) \u2297 m"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vm @ @ C$arithmetic$ <= Vn @ @ C$numpair$ npair Vn Vm"], "goal": "@ C$bool$ ! | Vm @ @ C$arithmetic$ <= @ C$num$ SUC Vn @ @ C$numpair$ npair @ C$num$ SUC Vn Vm"}, "plain": {"assumptions": ["\u2200(m :num). (n :num) \u2264 n \u2297 m"], "goal": "\u2200(m :num). SUC (n :num) \u2264 SUC n \u2297 m"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ @ C$arithmetic$ <= Vn @ @ C$numpair$ npair Vn Vm"], "goal": "@ C$bool$ ! | Vm @ @ C$arithmetic$ <= @ C$num$ SUC Vn @ @ C$numpair$ npair @ C$num$ SUC Vn Vm"}, "plain": {"assumptions": ["\u2200(m :num). (n :num) \u2264 n \u2297 m"], "goal": "\u2200(m :num). SUC (n :num) \u2264 SUC n \u2297 m"}}], "parent": 1, "goal": 0, "by_tactic": "rw[arithmeticTheory.MODEQ_REFL, arithmeticTheory.DIV_SUB, numpairTheory.tri_def, arithmeticTheory.LESS_NOT_SUC, boolTheory.BOOL_EQ_DISTINCT]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[numpairTheory.npair_def, numpairTheory.npair, numpairTheory.invtri0_thm, numpairTheory.tri_def, arithmeticTheory.ADD_CLAUSES]", "reward": 5}]], "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$bool$ \\/ @ @ C$min$ = Vs C$pred_set$ EMPTY @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ @ C$bool$ /\\ @ @ C$min$ = Vs @ @ C$pred_set$ INSERT Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool). s = (\u2205 :\u03b1 -> bool) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vs C$pred_set$ EMPTY @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ @ C$bool$ /\\ @ @ C$min$ = Vs @ @ C$pred_set$ INSERT Vx Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) = (\u2205 :\u03b1 -> bool) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). s = x INSERT t \u2227 x \u2209 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_DISJOINT, pred_setTheory.GSPECIFICATION, boolTheory.SWAP_FORALL_THM, boolTheory.LEFT_OR_EXISTS_THM, pred_setTheory.IN_EQ_UNIV_IMP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vs C$pred_set$ EMPTY @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ @ C$bool$ /\\ @ @ C$min$ = Vs @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(s :\u03b1 -> bool) = (\u2205 :\u03b1 -> bool) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). s = {y | y = x \u2228 y \u2208 t} \u2227 x \u2209 t"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INSERT_DEF, boolTheory.BOOL_FUN_CASES_THM, pred_setTheory.SUBSET_DEF, boolTheory.literal_case_CONG, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vx C$pred_set$ EMPTY @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$bool$ IN Vx' Vs @ @ C$bool$ IN Vx' @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ IN Vy Vt @ C$bool$ ~ @ @ C$bool$ IN Vx Vt"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d4 x \u2208 (\u2205 :\u03b1 -> bool)) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). \u2200(x' :\u03b1). (x' \u2208 s \u21d4 x' \u2208 {y | y = x \u2228 y \u2208 t}) \u2227 x \u2209 t"}}], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_AND_FORALL_THM, pred_setTheory.EXTENSION, pred_setTheory.INTER_DEF, pred_setTheory.UNION_DEF, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ C$min$ = @ Vs Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$min$ = @ Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx' Vx @ Vt Vx' @ C$bool$ ~ @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d4 \u2205 x) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). \u2200(x' :\u03b1). (s x' \u21d4 x' = x \u2228 t x') \u2227 \u00act x"}}], "parent": 3, "goal": 0, "by_tactic": "simp[boolTheory.DISJ_IMP_THM, pred_setTheory.IN_GSPEC_IFF, pred_setTheory.IN_APP, pred_setTheory.IN_APP, pred_setTheory.INSERT_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ! | Vx @ @ C$bool$ /\\ @ @ C$min$ ==> @ C$pred_set$ EMPTY Vx @ Vs Vx @ @ C$min$ ==> @ Vs Vx @ C$pred_set$ EMPTY Vx @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$min$ ==> @ Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx Vx' @ Vt Vx' @ @ C$min$ ==> @ @ C$bool$ \\/ @ @ C$min$ = Vx Vx' @ Vt Vx' @ Vs Vx' @ C$bool$ ~ @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (\u2205 x \u21d2 (s :\u03b1 -> bool) x) \u2227 (s x \u21d2 \u2205 x)) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). \u2200(x' :\u03b1). ((s x' \u21d2 x = x' \u2228 t x') \u2227 (x = x' \u2228 t x' \u21d2 s x')) \u2227 \u00act x"}}], "parent": 4, "goal": 0, "by_tactic": "rw[boolTheory.IMP_CONJ_THM, boolTheory.EQ_SYM_EQ, pred_setTheory.INTER_DEF, pred_setTheory.EMPTY_UNION, boolTheory.EQ_IMP_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ C$bool$ ! | Vx @ C$bool$ ~ @ Vs Vx @ C$bool$ ? | Vx @ C$bool$ ? | Vt @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$min$ ==> @ Vs Vx' @ @ C$bool$ \\/ @ @ C$min$ = Vx Vx' @ Vt Vx' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$min$ = Vx Vx' @ Vs Vx' @ @ C$min$ ==> @ Vt Vx' @ Vs Vx' @ C$bool$ ~ @ Vt Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). \u00ac(s :\u03b1 -> bool) x) \u2228 \u2203(x :\u03b1) (t :\u03b1 -> bool). \u2200(x' :\u03b1). ((s x' \u21d2 x = x' \u2228 t x') \u2227 (x = x' \u21d2 s x') \u2227 (t x' \u21d2 s x')) \u2227 \u00act x"}}], "parent": 5, "goal": 0, "by_tactic": "rw[boolTheory.UNWIND_THM2, boolTheory.PULL_EXISTS, pred_setTheory.EMPTY_DEF, pred_setTheory.SUBSET_DEF, boolTheory.DISJ_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 6, "goal": 0, "by_tactic": "metis_tac[boolTheory.COND_RATOR, pred_setTheory.SPECIFICATION, pred_setTheory.EMPTY_UNION, boolTheory.OR_IMP_THM, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). POW set e \u21d4 e \u2286 set": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vset @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$pred_set$ POW Vset Ve @ @ C$pred_set$ SUBSET Ve Vset"}, "plain": {"assumptions": [], "goal": "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). POW set e \u21d4 e \u2286 set"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.GSPEC_ETA, pred_setTheory.COUNT_SUC, pred_setTheory.IN_POW, pred_setTheory.COMPL_applied, pred_setTheory.POW_DEF]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2) (ls :\u03b1 list). ALL_DISTINCT ls \u21d2 (MEM x (ZIP (ls,MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x))": [14, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ C$bool$ ! | Vls @ @ C$min$ ==> @ C$list$ ALL_DISTINCT Vls @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2) (ls :\u03b1 list). ALL_DISTINCT ls \u21d2 (MEM x (ZIP (ls,MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$list$ ALL_DISTINCT C$list$ NIL @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL @ @ C$list$ MAP Vf C$list$ NIL @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). ALL_DISTINCT ([] :\u03b1 list) \u21d2 (MEM x (ZIP (([] :\u03b1 list),MAP f ([] :\u03b1 list))) \u21d4 MEM (FST x) ([] :\u03b1 list) \u2227 SND x = f (FST x))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$list$ ALL_DISTINCT Vls @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$list$ ALL_DISTINCT @ @ C$list$ CONS Vh Vls @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vls @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). ALL_DISTINCT (ls :\u03b1 list) \u21d2 (MEM x (ZIP (ls,MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x))"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). ALL_DISTINCT (h::(ls :\u03b1 list)) \u21d2 (MEM x (ZIP (h::ls,MAP f (h::ls))) \u21d4 MEM (FST x) (h::ls) \u2227 SND x = f (FST x))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$list$ ALL_DISTINCT Vls @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ ==> @ C$list$ ALL_DISTINCT @ @ C$list$ CONS Vh Vls @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vls @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). ALL_DISTINCT (ls :\u03b1 list) \u21d2 (MEM x (ZIP (ls,MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x))"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). ALL_DISTINCT (h::(ls :\u03b1 list)) \u21d2 (MEM x (ZIP (h::ls,MAP f (h::ls))) \u21d4 MEM (FST x) (h::ls) \u2227 SND x = f (FST x))"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp_1 @ C$bool$ ! | Vp_2 @ C$bool$ ! | Vf @ @ C$min$ ==> @ C$list$ ALL_DISTINCT C$list$ NIL @ @ C$min$ = @ @ C$bool$ IN @ @ C$pair$ , Vp_1 Vp_2 @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL @ @ C$list$ MAP Vf C$list$ NIL @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST @ @ C$pair$ , Vp_1 Vp_2 @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$min$ = @ C$pair$ SND @ @ C$pair$ , Vp_1 Vp_2 @ Vf @ C$pair$ FST @ @ C$pair$ , Vp_1 Vp_2"}, "plain": {"assumptions": [], "goal": "\u2200(p_1 :\u03b1) (p_2 :\u03b2) (f :\u03b1 -> \u03b2). ALL_DISTINCT ([] :\u03b1 list) \u21d2 (MEM (p_1,p_2) (ZIP (([] :\u03b1 list),MAP f ([] :\u03b1 list))) \u21d4 MEM (FST (p_1,p_2)) ([] :\u03b1 list) \u2227 SND (p_1,p_2) = f (FST (p_1,p_2)))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vp_1 @ C$bool$ ! | Vp_2 @ C$bool$ ! | Vf @ @ C$min$ ==> @ C$list$ ALL_DISTINCT C$list$ NIL @ @ C$min$ = @ @ C$bool$ IN @ @ C$pair$ , Vp_1 Vp_2 @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL @ @ C$list$ MAP Vf C$list$ NIL @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST @ @ C$pair$ , Vp_1 Vp_2 @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$min$ = @ C$pair$ SND @ @ C$pair$ , Vp_1 Vp_2 @ Vf @ C$pair$ FST @ @ C$pair$ , Vp_1 Vp_2"}, "plain": {"assumptions": [], "goal": "\u2200(p_1 :\u03b1) (p_2 :\u03b2) (f :\u03b1 -> \u03b2). ALL_DISTINCT ([] :\u03b1 list) \u21d2 (MEM (p_1,p_2) (ZIP (([] :\u03b1 list),MAP f ([] :\u03b1 list))) \u21d4 MEM (FST (p_1,p_2)) ([] :\u03b1 list) \u2227 SND (p_1,p_2) = f (FST (p_1,p_2)))"}}, {"polished": {"assumptions": ["@ C$list$ ALL_DISTINCT Vls", "@ C$bool$ ~ @ @ C$bool$ IN Vh @ C$list$ LIST_TO_SET Vls", "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx @ @ C$pair$ , Vh @ Vf Vh @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = @ C$pair$ FST Vx Vh @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": ["ALL_DISTINCT (ls :\u03b1 list)", "\u00acMEM (h :\u03b1) (ls :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). MEM x (ZIP ((ls :\u03b1 list),MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x)"], "goal": "(x :\u03b1 # \u03b2) = ((h :\u03b1),(f :\u03b1 -> \u03b2) h) \u2228 MEM (FST x) (ls :\u03b1 list) \u2227 SND x = f (FST x) \u21d4 (FST x = h \u2228 MEM (FST x) ls) \u2227 SND x = f (FST x)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[rich_listTheory.EVERY2_APPEND_suff, listTheory.LIST_TO_SET_MAP, listTheory.SUM_SNOC, pairTheory.UNCURRY_CURRY_THM, pairTheory.CURRY_UNCURRY_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$list$ ALL_DISTINCT Vls", "@ C$bool$ ~ @ @ C$bool$ IN Vh @ C$list$ LIST_TO_SET Vls", "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx @ @ C$pair$ , Vh @ Vf Vh @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = @ C$pair$ FST Vx Vh @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": ["ALL_DISTINCT (ls :\u03b1 list)", "\u00acMEM (h :\u03b1) (ls :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). MEM x (ZIP ((ls :\u03b1 list),MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x)"], "goal": "(x :\u03b1 # \u03b2) = ((h :\u03b1),(f :\u03b1 -> \u03b2) h) \u2228 MEM (FST x) (ls :\u03b1 list) \u2227 SND x = f (FST x) \u21d4 (FST x = h \u2228 MEM (FST x) ls) \u2227 SND x = f (FST x)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_SPLIT1, listTheory.FRONT_DEF, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.OPT_MMAP_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$list$ ALL_DISTINCT Vls", "@ C$bool$ ~ @ @ C$bool$ IN Vh @ C$list$ LIST_TO_SET Vls", "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ ZIP @ @ C$pair$ , Vls @ @ C$list$ MAP Vf Vls @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ C$pair$ FST Vx Vh @ @ C$min$ = @ C$pair$ SND Vx @ Vf Vh @ @ C$bool$ /\\ @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = @ C$pair$ FST Vx Vh @ @ C$bool$ IN @ C$pair$ FST Vx @ C$list$ LIST_TO_SET Vls @ @ C$min$ = @ C$pair$ SND Vx @ Vf @ C$pair$ FST Vx"}, "plain": {"assumptions": ["ALL_DISTINCT (ls :\u03b1 list)", "\u00acMEM (h :\u03b1) (ls :\u03b1 list)", "\u2200(f :\u03b1 -> \u03b2) (x :\u03b1 # \u03b2). MEM x (ZIP ((ls :\u03b1 list),MAP f ls)) \u21d4 MEM (FST x) ls \u2227 SND x = f (FST x)"], "goal": "FST (x :\u03b1 # \u03b2) = (h :\u03b1) \u2227 SND x = (f :\u03b1 -> \u03b2) h \u2228 MEM (FST x) (ls :\u03b1 list) \u2227 SND x = f (FST x) \u21d4 (FST x = h \u2228 MEM (FST x) ls) \u2227 SND x = f (FST x)"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.SUM_APPEND, pairTheory.PAIR_FST_SND_EQ, listTheory.EL_simp, listTheory.SWAP_REVERSE_SYM, listTheory.SUM_MAP_PLUS]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.MAP_EQ_SING, listTheory.FOLDL_UNION_BIGUNION_paired, listTheory.FOLDL_UNION_BIGUNION, listTheory.OPT_MMAP_def, listTheory.SWAP_REVERSE_SYM]", "reward": 5}]], "\u2200(n :num). count n = if n = (0 :num) then (\u2205 :num -> bool) else (let (p :num) = PRE n in p INSERT count p)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ C$pred_set$ count Vn @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 C$pred_set$ EMPTY @ @ C$bool$ LET | Vp @ @ C$pred_set$ INSERT Vp @ C$pred_set$ count Vp @ C$prim_rec$ PRE Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). count n = if n = (0 :num) then (\u2205 :num -> bool) else (let (p :num) = PRE n in p INSERT count p)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm C$bool$ F Vx @ C$pred_set$ EMPTY Vx"}, "plain": {"assumptions": [], "goal": "{m | F} (x :num) \u21d4 \u2205 x"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0"], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm Vn Vx @ @ @ C$pred_set$ INSERT @ C$prim_rec$ PRE Vn @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm @ C$prim_rec$ PRE Vn Vx"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num)"], "goal": "{m | m < (n :num)} (x :num) \u21d4 (PRE n INSERT {m | m < PRE n}) x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.count_def, prim_recTheory.LESS_LEMMA1, pred_setTheory.FUNSET_INTER, boolTheory.FUN_EQ_THM, pred_setTheory.IN_DISJOINT]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm Vn Vx @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ C$pred_set$ EMPTY Vx @ @ @ C$pred_set$ INSERT @ C$prim_rec$ PRE Vn @ C$pred_set$ GSPEC | Vm @ @ C$pair$ , Vm @ @ C$prim_rec$ < Vm @ C$prim_rec$ PRE Vn Vx"}, "plain": {"assumptions": [], "goal": "{m | m < (n :num)} (x :num) \u21d4 if n = (0 :num) then \u2205 x else (PRE n INSERT {m | m < PRE n}) x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.count_def, pred_setTheory.count_def, pred_setTheory.INTER_DEF, boolTheory.FUN_EQ_THM, boolTheory.COND_RATOR]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.GSPEC_ETA, pred_setTheory.EMPTY_DEF, pred_setTheory.INSERT_applied, pred_setTheory.IN_IMAGE]", "reward": 5}]], "\u2200(ls :\u03b1 list) (n :num). DROP n ls = ([] :\u03b1 list) \u21d4 LENGTH ls \u2264 n": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vls @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ @ C$list$ DROP Vn Vls C$list$ NIL @ @ C$arithmetic$ <= @ C$list$ LENGTH Vls Vn"}, "plain": {"assumptions": [], "goal": "\u2200(ls :\u03b1 list) (n :num). DROP n ls = ([] :\u03b1 list) \u21d4 LENGTH ls \u2264 n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ DROP Vn Vls @ C$list$ LENGTH C$list$ NIL @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ C$list$ DROP Vn Vls @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ DROP Vn Vls @ @ C$list$ EL Vx C$list$ NIL @ @ C$arithmetic$ <= @ C$list$ LENGTH Vls Vn"}, "plain": {"assumptions": [], "goal": "LENGTH (DROP (n :num) (ls :\u03b1 list)) = LENGTH ([] :\u03b1 list) \u2227 (\u2200(x :num). x < LENGTH (DROP n ls) \u21d2 EL x (DROP n ls) = EL x ([] :\u03b1 list)) \u21d4 LENGTH ls \u2264 n"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, arithmeticTheory.ABS_DIFF_SUC_LE, boolTheory.NOT_AND, listTheory.TAKE_TAKE_MIN, arithmeticTheory.SUB_CANCEL]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[boolTheory.EQ_IMP_THM, listTheory.EL_simp, listTheory.LENGTH_DROP, listTheory.UNZIP, listTheory.LENGTH]", "reward": 5}]], "\u2200(n :num) (x :\u03b1). REVERSE (REPLICATE n x) = REPLICATE n x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$rich_list$ REPLICATE Vn Vx"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (x :\u03b1). REVERSE (REPLICATE n x) = REPLICATE n x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ GENLIST @ C$combin$ K Vx Vn @ @ C$list$ GENLIST @ C$combin$ K Vx Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (x :\u03b1). REVERSE (GENLIST (K x :num -> \u03b1) n) = GENLIST (K x :num -> \u03b1) n"}}], "parent": 0, "goal": 0, "by_tactic": "fs[rich_listTheory.ELL_0_SNOC, listTheory.PAD_LEFT, listTheory.REVERSE_SNOC_DEF, rich_listTheory.REPLICATE_GENLIST, listTheory.EL_SNOC]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, listTheory.UNION_APPEND, boolTheory.NOT_AND, listTheory.REVERSE_GENLIST, rich_listTheory.BUTLASTN]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4) (z :\u03b1 + \u03b2). SUM_MAP f g z = (sum_CASE z ((INL :\u03b3 -> \u03b3 + \u03b4) \u2218 f) ((INR :\u03b4 -> \u03b3 + \u03b4) \u2218 g) :\u03b3 + \u03b4)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ C$bool$ ! | Vz @ @ C$min$ = @ @ @ C$sum$ SUM_MAP Vf Vg Vz @ @ @ C$sum$ sum_CASE Vz @ @ C$combin$ o C$sum$ INL Vf @ @ C$combin$ o C$sum$ INR Vg"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4) (z :\u03b1 + \u03b2). SUM_MAP f g z = (sum_CASE z ((INL :\u03b3 -> \u03b3 + \u03b4) \u2218 f) ((INR :\u03b4 -> \u03b3 + \u03b4) \u2218 g) :\u03b3 + \u03b4)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vg @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ = @ @ @ C$sum$ SUM_MAP Vf Vg @ C$sum$ INL Vx @ C$sum$ INL @ Vf Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ @ C$sum$ SUM_MAP Vf Vg @ C$sum$ INR Vy @ C$sum$ INR @ Vg Vy"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b3) (g :\u03b2 -> \u03b4). (\u2200(x :\u03b1). SUM_MAP f g (INL x :\u03b1 + \u03b2) = (INL (f x) :\u03b3 + \u03b4)) \u2227 \u2200(y :\u03b2). SUM_MAP f g (INR y :\u03b1 + \u03b2) = (INR (g y) :\u03b3 + \u03b4)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, sumTheory.sum_case_def, sumTheory.FORALL_SUM, boolTheory.PULL_EXISTS, boolTheory.OR_ELIM_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_OR_OVER_AND, boolTheory.OR_CLAUSES, sumTheory.SUM_MAP_def, boolTheory.ABS_REP_THM, boolTheory.DISJ_EQ_IMP]", "reward": 5}]], "(\u2200(x :\u03b1). MEM x (ls :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) x x) \u21d2 LIST_REL R ls ls": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ @ VR Vx Vx @ @ @ C$list$ LIST_REL VR Vls Vls"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). MEM x (ls :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) x x) \u21d2 LIST_REL R ls ls"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vls", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vls @ @ VR Vx Vx"], "goal": "@ @ VR @ @ C$list$ EL Vn Vls @ @ C$list$ EL Vn Vls"}, "plain": {"assumptions": ["(n :num) < LENGTH (ls :\u03b1 list)", "\u2200(x :\u03b1). MEM x (ls :\u03b1 list) \u21d2 (R :\u03b1 -> \u03b1 -> bool) x x"], "goal": "(R :\u03b1 -> \u03b1 -> bool) (EL (n :num) (ls :\u03b1 list)) (EL n ls)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EL_REVERSE, listTheory.LIST_REL_EL_EQN, listTheory.REVERSE_GENLIST, listTheory.list_case_cong, listTheory.EVERY2_sym]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.MEM_EL, listTheory.EL_LENGTH_SNOC, listTheory.isPREFIX, listTheory.APPEND_SNOC, listTheory.REV_DEF]", "reward": 5}]], "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vm @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vn Vm @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ LASTN Vn @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$rich_list$ BUTLASTN Vm @ @ C$rich_list$ LASTN @ @ C$arithmetic$ + Vn Vm Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (m :num) (l :\u03b1 list). n + m \u2264 LENGTH l \u21d2 LASTN n (BUTLASTN m l) = BUTLASTN m (LASTN (n + m) l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl"], "goal": "@ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ TAKE Vn @ C$list$ REVERSE @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$rich_list$ BUTLASTN Vm @ C$list$ REVERSE @ @ C$list$ TAKE @ @ C$arithmetic$ + Vm Vn @ C$list$ REVERSE Vl"}, "plain": {"assumptions": ["(m :num) + (n :num) \u2264 LENGTH (l :\u03b1 list)"], "goal": "REVERSE (TAKE (n :num) (REVERSE (BUTLASTN (m :num) (l :\u03b1 list)))) = BUTLASTN m (REVERSE (TAKE (m + n) (REVERSE l)))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.LASTN_def, listTheory.UNION_APPEND, listTheory.TAKE_DROP, rich_listTheory.LENGTH_LASTN, arithmeticTheory.LESS_EQ_MONO_ADD_EQ]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$arithmetic$ <= @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl"], "goal": "@ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ DROP Vm @ C$list$ REVERSE Vl @ @ C$list$ DROP Vm @ @ C$list$ TAKE @ @ C$arithmetic$ + Vm Vn @ C$list$ REVERSE Vl"}, "plain": {"assumptions": ["(m :num) + (n :num) \u2264 LENGTH (l :\u03b1 list)"], "goal": "TAKE (n :num) (DROP (m :num) (REVERSE (l :\u03b1 list))) = DROP m (TAKE (m + n) (REVERSE l))"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.nub_def, listTheory.SNOC_APPEND, rich_listTheory.BUTLASTN_def, arithmeticTheory.TIMES2, rich_listTheory.TL_T_def]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.SNOC_CASES, listTheory.DROP_TAKE, listTheory.SUM_ACC_DEF, rich_listTheory.BUTLASTN_SUC_FRONT, arithmeticTheory.MODEQ_THM]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n l = EL (PRE (LENGTH l \u2212 n)) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ ELL Vn Vl @ @ C$list$ EL @ C$prim_rec$ PRE @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n l = EL (PRE (LENGTH l \u2212 n)) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.EL_ELL, listTheory.LENGTH_LT_SHORTLEX, arithmeticTheory.PRE_SUB, listTheory.oEL_DROP, rich_listTheory.PREFIX_DEF]", "reward": 5}]], "(OLEAST(n :num). n = (x :num)) = SOME x \u2227 (OLEAST(n :num). x = n) = SOME x \u2227 (OLEAST(n :num). F) = (NONE :num option) \u2227 (OLEAST(n :num). T) = SOME (0 :num)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$while$ OLEAST | Vn @ @ C$min$ = Vn Vx @ C$option$ SOME Vx @ @ C$bool$ /\\ @ @ C$min$ = @ C$while$ OLEAST | Vn @ @ C$min$ = Vx Vn @ C$option$ SOME Vx @ @ C$bool$ /\\ @ @ C$min$ = @ C$while$ OLEAST | Vn C$bool$ F C$option$ NONE @ @ C$min$ = @ C$while$ OLEAST | Vn C$bool$ T @ C$option$ SOME C$num$ 0"}, "plain": {"assumptions": [], "goal": "(OLEAST(n :num). n = (x :num)) = SOME x \u2227 (OLEAST(n :num). x = n) = SOME x \u2227 (OLEAST(n :num). F) = (NONE :num option) \u2227 (OLEAST(n :num). T) = SOME (0 :num)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$while$ LEAST | Vn C$bool$ T C$num$ 0"}, "plain": {"assumptions": [], "goal": "(LEAST(n :num). T) = (0 :num)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[whileTheory.LEAST_EQ, whileTheory.OLEAST_def, whileTheory.HOARE_SPEC_DEF, boolTheory.LEFT_AND_FORALL_THM, boolTheory.LEFT_FORALL_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "simp[whileTheory.LEAST_T, boolTheory.UNWIND_FORALL_THM2, boolTheory.JRH_INDUCT_UTIL, numTheory.NOT_SUC, boolTheory.ETA_THM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). set (MAP f l) = IMAGE f (set l)": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ @ C$pred_set$ IMAGE Vf @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (l :\u03b1 list). set (MAP f l) = IMAGE f (set l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ @ C$pred_set$ IMAGE Vf @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "set (MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list)) = IMAGE f (set l)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.COMPL_COMPL, pred_setTheory.POW_DEF, listTheory.LIST_REL_EVERY_ZIP, pred_setTheory.SUBSET_applied, pred_setTheory.PROD_SET_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl Vx @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$list$ LIST_TO_SET Vl Vx'"}, "plain": {"assumptions": [], "goal": "set (MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list)) (x :\u03b2) \u21d4 \u2203(x' :\u03b1). x = f x' \u2227 set l x'"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.PSUBSET_UNIV, pred_setTheory.num_to_pair_def, pred_setTheory.EXTENSION, boolTheory.EXISTS_itself]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl Vx @ C$bool$ ? | Vx' @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vx' @ @ C$list$ LIST_TO_SET Vl Vx' @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl Vx @ C$bool$ ! | Vx' @ @ C$min$ ==> @ @ C$min$ = Vx @ Vf Vx' @ C$bool$ ~ @ @ C$list$ LIST_TO_SET Vl Vx'"}, "plain": {"assumptions": [], "goal": "set (MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list)) (x :\u03b2) \u2227 (\u2203(x' :\u03b1). x = f x' \u2227 set l x') \u2228 \u00acset (MAP f l) x \u2227 \u2200(x' :\u03b1). x = f x' \u21d2 \u00acset l x'"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_EQ_EMPTY, boolTheory.EQ_EXPAND, pred_setTheory.BIGUNION_applied, pred_setTheory.EXTENSION, pred_setTheory.IN_BIGUNION_IMAGE]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.PAIR_IN_GSPEC_same, listTheory.MEM_MAP, boolTheory.IMP_CONJ_THM, pred_setTheory.IN_APP, pred_setTheory.GSPEC_ETA]", "reward": 5}]], "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a \u227c b ++ c \u21d2 a \u227c b \u2228 b \u227c a": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (b :\u03b1 list) (c :\u03b1 list). a \u227c b ++ c \u21d2 a \u227c b \u2228 b \u227c a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND C$list$ NIL Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va C$list$ NIL @ @ C$list$ isPREFIX C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c ([] :\u03b1 list) \u29fa c \u21d2 a \u227c ([] :\u03b1 list) \u2228 ([] :\u03b1 list) \u227c a"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb Va"}, "plain": {"assumptions": ["\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "\u2200(h :\u03b1) (a :\u03b1 list) (c :\u03b1 list). a \u227c h::(b :\u03b1 list) \u29fa c \u21d2 a \u227c h::b \u2228 h::b \u227c a"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `b`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb Va"}, "plain": {"assumptions": ["\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "\u2200(h :\u03b1) (a :\u03b1 list) (c :\u03b1 list). a \u227c h::(b :\u03b1 list) \u29fa c \u21d2 a \u227c h::b \u2228 h::b \u227c a"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.FLAT, listTheory.LENGTH_FILTER_LEQ_MONO, listTheory.LRC_def, boolTheory.DISJ_IMP_THM, listTheory.EVERY2_LUPDATE_same]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ @ C$min$ ==> @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX C$list$ NIL @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb C$list$ NIL"}, "plain": {"assumptions": ["\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "([] :\u03b1 list) \u227c (h :\u03b1)::(b :\u03b1 list) \u29fa (c :\u03b1 list) \u21d2 ([] :\u03b1 list) \u227c h::b \u2228 h::b \u227c ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb Va", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb @ @ C$list$ CONS Vh' Va"}, "plain": {"assumptions": ["(a :\u03b1 list) \u227c (h :\u03b1)::(b :\u03b1 list) \u29fa (c :\u03b1 list) \u21d2 a \u227c h::b \u2228 h::b \u227c a", "\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "\u2200(h' :\u03b1). h'::(a :\u03b1 list) \u227c (h :\u03b1)::(b :\u03b1 list) \u29fa (c :\u03b1 list) \u21d2 h'::a \u227c h::b \u2228 h::b \u227c h'::a"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb Va", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Va @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh' Va @ @ C$list$ CONS Vh Vb @ @ C$list$ isPREFIX @ @ C$list$ CONS Vh Vb @ @ C$list$ CONS Vh' Va"}, "plain": {"assumptions": ["(a :\u03b1 list) \u227c (h :\u03b1)::(b :\u03b1 list) \u29fa (c :\u03b1 list) \u21d2 a \u227c h::b \u2228 h::b \u227c a", "\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "\u2200(h' :\u03b1). h'::(a :\u03b1 list) \u227c (h :\u03b1)::(b :\u03b1 list) \u29fa (c :\u03b1 list) \u21d2 h'::a \u227c h::b \u2228 h::b \u227c h'::a"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.CONS_11, listTheory.FILTER, listTheory.ZIP_EQ_NIL, listTheory.MAP2_APPEND, listTheory.UNZIP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc", "@ @ C$min$ = Vh' Vh", "@ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va @ @ C$list$ CONS Vh Vb @ @ @ C$list$ list_CASE Va C$bool$ F | Vh' | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vh Vh' @ @ C$list$ isPREFIX Vb Vt'", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ @ C$min$ ==> @ @ C$list$ isPREFIX Va @ @ C$list$ APPEND Vb Vc @ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"], "goal": "@ @ C$bool$ \\/ @ @ C$list$ isPREFIX Va Vb @ @ C$list$ isPREFIX Vb Va"}, "plain": {"assumptions": ["(a :\u03b1 list) \u227c (b :\u03b1 list) \u29fa (c :\u03b1 list)", "(h' :\u03b1) = (h :\u03b1)", "(a :\u03b1 list) \u227c (h :\u03b1)::((b :\u03b1 list) \u29fa (c :\u03b1 list)) \u21d2 a \u227c h::b \u2228 case a of ([] :\u03b1 list) => F | h'::t' => h = h' \u2227 b \u227c t'", "\u2200(a :\u03b1 list) (c :\u03b1 list). a \u227c (b :\u03b1 list) \u29fa c \u21d2 a \u227c b \u2228 b \u227c a"], "goal": "(a :\u03b1 list) \u227c (b :\u03b1 list) \u2228 b \u227c a"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.FILTER_APPEND_DISTRIB, listTheory.EXISTS_MAP, listTheory.list_size_def, listTheory.FLAT, listTheory.OPT_MMAP_def]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.HD_DROP, listTheory.LENGTH_FRONT_CONS, listTheory.MEM_SNOC, listTheory.EL_LENGTH_dropWhile_REVERSE, listTheory.LENGTH]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 f \u2208 FUNSET s t \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 \u2203!(x :\u03b1). x \u2208 s \u2227 y = f x": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET Vs Vt @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vt @ C$bool$ ?! | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = Vy @ Vf Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 f \u2208 FUNSET s t \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 \u2203!(x :\u03b1). x \u2208 s \u2227 y = f x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ @ C$pred_set$ SURJ Vf Vs Vt @ @ C$bool$ /\\ @ @ C$bool$ IN Vf @ @ C$pred_set$ FUNSET Vs Vt @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ IN Vy Vt @ C$bool$ ?! | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$min$ = Vy @ Vf Vx"}, "plain": {"assumptions": [], "goal": "((\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool)) \u2227 \u2200(x :\u03b1) (y :\u03b1). x \u2208 s \u2227 y \u2208 s \u21d2 f x = f y \u21d2 x = y) \u2227 SURJ f s t \u21d4 f \u2208 ((s \u2192 t) :(\u03b1 -> \u03b2) -> bool) \u2227 \u2200(y :\u03b2). y \u2208 t \u21d2 \u2203!(x :\u03b1). x \u2208 s \u2227 y = f x"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_DEF, pred_setTheory.SCHROEDER_CLOSE, boolTheory.SKOLEM_THM, pred_setTheory.BIJ_DEF, pred_setTheory.EMPTY_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx @ Vs Vy @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ Vs Vy @ @ C$min$ = @ Vf Vy Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ Vt Vy @ C$bool$ ?! | Vx @ @ C$bool$ /\\ @ Vs Vx @ @ C$min$ = Vy @ Vf Vx"}, "plain": {"assumptions": [], "goal": "((\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b2 -> bool) ((f :\u03b1 -> \u03b2) x)) \u2227 \u2200(x :\u03b1) (y :\u03b1). s x \u2227 s y \u21d2 f x = f y \u21d2 x = y) \u2227 (\u2200(x :\u03b1). s x \u21d2 t (f x)) \u2227 (\u2200(x :\u03b2). t x \u21d2 \u2203(y :\u03b1). s y \u2227 f y = x) \u21d4 (\u2200(x :\u03b1). s x \u21d2 t (f x)) \u2227 \u2200(y :\u03b2). t y \u21d2 \u2203!(x :\u03b1). s x \u2227 y = f x"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.IN_DISJOINT, pred_setTheory.GSPEC_ETA, pred_setTheory.SURJ_DEF, pred_setTheory.FUNSET]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.SING_DELETE, pred_setTheory.NOT_EMPTY_INSERT, pred_setTheory.NOT_EQUAL_SETS, pred_setTheory.IMAGE_applied]", "reward": 5}]], "\u2200(l :\u03b1 list) (n :num). LENGTH l = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'": [20, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (n :num). LENGTH l = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH C$list$ NIL @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vh Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). LENGTH ([] :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 ([] :\u03b1 list) = h::l'"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l :\u03b1 list)) = SUC n \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l = h'::l'"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l :\u03b1 list)) = SUC n \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l = h'::l'"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl' C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) = LENGTH ([] :\u03b1 list) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l' = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.RES_EXISTS_CONG, listTheory.MAP2_APPEND, boolTheory.ONTO_THM, listTheory.LENGTH_MAP2, listTheory.FLAT_compute]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl' C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) = LENGTH ([] :\u03b1 list) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l' = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "LENGTH (l :\u03b1 list) = (n :num) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 (h :\u03b1)::l = h'::l'"}}], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.RIGHT_OR_OVER_AND, listTheory.LENGTH, listTheory.EL, listTheory.EXISTS_APPEND, numTheory.INV_SUC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "LENGTH (l :\u03b1 list) = (n :num) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 (h :\u03b1)::l = h'::l'"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) \u2260 LENGTH ([] :\u03b1 list)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_DEF, listTheory.EVERY_APPEND, listTheory.EVERY_EL, listTheory.EXISTS_DEF, listTheory.NOT_CONS_NIL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) \u2260 LENGTH ([] :\u03b1 list)"}}], "parent": 4, "goal": 0, "by_tactic": "metis_tac[listTheory.CONS_11, listTheory.MAP2_NIL, listTheory.EL_APPEND_EQN, listTheory.APPEND, listTheory.EVERY_EL]", "reward": 0.2}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl' C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) = LENGTH ([] :\u03b1 list) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l' = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$num$ SUC C$num$ 0 @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' C$num$ 0 @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "LENGTH ((h :\u03b1)::(l :\u03b1 list)) = SUC (0 :num) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = (0 :num) \u2227 h::l = h'::l'"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'", "@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ C$num$ SUC @ C$num$ SUC Vn @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' @ C$num$ SUC Vn @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["LENGTH ((h :\u03b1)::(l :\u03b1 list)) = SUC (n :num) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 h::l = h'::l'", "\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "LENGTH ((h :\u03b1)::(l :\u03b1 list)) = SUC (SUC (n :num)) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). LENGTH l' = SUC n \u2227 h::l = h'::l'"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC C$num$ 0 @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' C$num$ 0 @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). LENGTH l = SUC (0 :num) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = (0 :num) \u2227 l = h::l'"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl' @ C$num$ SUC Vn @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"}, "plain": {"assumptions": ["\u2200(l :\u03b1 list). LENGTH l = SUC (n :num) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = n \u2227 l = h::l'"], "goal": "\u2200(l :\u03b1 list). LENGTH l = SUC (SUC (n :num)) \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). LENGTH l' = SUC n \u2227 l = h::l'"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ~ @ @ C$min$ = @ C$num$ SUC Vn @ C$list$ LENGTH C$list$ NIL"}, "plain": {"assumptions": [], "goal": "SUC (n :num) \u2260 LENGTH ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vn @ C$list$ LENGTH Vl' @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = Vn @ C$list$ LENGTH Vl @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vn @ C$list$ LENGTH Vl' @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). n = LENGTH l' \u2227 l = h::l'"], "goal": "(n :num) = LENGTH (l :\u03b1 list) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). n = LENGTH l' \u2227 (h :\u03b1)::l = h'::l'"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.LENGTH, listTheory.LENGTH, boolTheory.EQ_SYM_EQ, boolTheory.OR_CONG, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ = @ @ C$min$ = @ C$list$ LENGTH Vl @ C$num$ SUC Vn @ C$bool$ ? | Vh @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vn @ C$list$ LENGTH Vl' @ @ C$min$ = Vl @ @ C$list$ CONS Vh Vl'"], "goal": "@ @ C$min$ = @ @ C$min$ = Vn @ C$list$ LENGTH Vl @ C$bool$ ? | Vh' @ C$bool$ ? | Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vn @ C$list$ LENGTH Vl' @ @ C$min$ = @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh' Vl'"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) = SUC n \u21d4 \u2203(h :\u03b1) (l' :\u03b1 list). n = LENGTH l' \u2227 l = h::l'"], "goal": "(n :num) = LENGTH (l :\u03b1 list) \u21d4 \u2203(h' :\u03b1) (l' :\u03b1 list). n = LENGTH l' \u2227 (h :\u03b1)::l = h'::l'"}}], "parent": 8, "goal": 0, "by_tactic": "rw[boolTheory.DATATYPE_TAG_DEF, boolTheory.ONTO_THM, listTheory.EL, listTheory.LENGTH, boolTheory.AND1_THM]", "reward": 0.2}, {"content": [], "parent": 9, "goal": 0, "by_tactic": "metis_tac[boolTheory.RIGHT_OR_OVER_AND, listTheory.MAP2_NIL, listTheory.CONS_11, listTheory.APPEND, listTheory.LENGTH_NIL_SYM]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). x \u2208 t \u21d2 g x \u2208 s) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 g (f x) = x) \u2227 \u2200(x :\u03b2). x \u2208 t \u21d2 f (g x) = x": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vs @ C$bool$ ! | Vt @ @ C$min$ = @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ C$bool$ ? | Vg @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$bool$ IN @ Vg Vx Vs @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$min$ = @ Vg @ Vf Vx Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vt @ @ C$min$ = @ Vf @ Vg Vx Vx"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool). BIJ f s t \u21d4 (\u2200(x :\u03b1). x \u2208 s \u21d2 f x \u2208 t) \u2227 \u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). x \u2208 t \u21d2 g x \u2208 s) \u2227 (\u2200(x :\u03b1). x \u2208 s \u21d2 g (f x) = x) \u2227 \u2200(x :\u03b2). x \u2208 t \u21d2 f (g x) = x"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$pred_set$ BIJ Vf Vs Vt @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ? | Vg @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ Vs @ Vg Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ @ C$min$ = Vx @ Vg @ Vf Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ @ C$min$ = Vx @ Vf @ Vg Vx"}, "plain": {"assumptions": [], "goal": "BIJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool) \u21d4 (\u2200(x :\u03b1). s x \u21d2 t (f x)) \u2227 \u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). t x \u21d2 s (g x)) \u2227 (\u2200(x :\u03b1). s x \u21d2 x = g (f x)) \u2227 \u2200(x :\u03b2). t x \u21d2 x = f (g x)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, pred_setTheory.IN_INTER, pred_setTheory.SPECIFICATION, pred_setTheory.INTER_applied, pred_setTheory.FUNSET_DFUNSET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ Vt Vy @ C$bool$ ?! | Vx @ @ C$bool$ /\\ @ Vs Vx @ @ C$min$ = Vy @ Vf Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ Vt @ Vf Vx @ C$bool$ ? | Vg @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ Vs @ Vg Vx @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vs Vx @ @ C$min$ = Vx @ Vg @ Vf Vx @ C$bool$ ! | Vx @ @ C$min$ ==> @ Vt Vx @ @ C$min$ = Vx @ Vf @ Vg Vx"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). (s :\u03b1 -> bool) x \u21d2 (t :\u03b2 -> bool) ((f :\u03b1 -> \u03b2) x)) \u2227 (\u2200(y :\u03b2). t y \u21d2 \u2203!(x :\u03b1). s x \u2227 y = f x) \u21d4 (\u2200(x :\u03b1). s x \u21d2 t (f x)) \u2227 \u2203(g :\u03b2 -> \u03b1). (\u2200(x :\u03b2). t x \u21d2 s (g x)) \u2227 (\u2200(x :\u03b1). s x \u21d2 x = g (f x)) \u2227 \u2200(x :\u03b2). t x \u21d2 x = f (g x)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[pred_setTheory.SPECIFICATION, pred_setTheory.INTER_applied, pred_setTheory.GSPEC_ETA, pred_setTheory.BIJ_ALT, pred_setTheory.IN_FUNSET]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_APP, pred_setTheory.INTER_EMPTY, boolTheory.NOT_IMP, pred_setTheory.INSERT_applied, pred_setTheory.BIJ_IMAGE]", "reward": 5}]], "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 BIJ f (s DELETE e) (t DELETE f e)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ C$bool$ ! | Vt @ C$bool$ ! | Vf @ @ C$min$ ==> @ @ @ C$pred_set$ BIJ Vf Vs Vt @ C$bool$ ! | Ve @ @ C$min$ ==> @ @ C$bool$ IN Ve Vs @ @ @ C$pred_set$ BIJ Vf @ @ C$pred_set$ DELETE Vs Ve @ @ C$pred_set$ DELETE Vt @ Vf Ve"}, "plain": {"assumptions": [], "goal": "\u2200(s :\u03b1 -> bool) (t :\u03b2 -> bool) (f :\u03b1 -> \u03b2). BIJ f s t \u21d2 \u2200(e :\u03b1). e \u2208 s \u21d2 BIJ f (s DELETE e) (t DELETE f e)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Ve Vs", "@ @ @ C$pred_set$ SURJ Vf Vs Vt", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt"], "goal": "@ @ @ C$pred_set$ SURJ Vf @ @ C$pred_set$ DELETE Vs Ve @ @ C$pred_set$ DELETE Vt @ Vf Ve"}, "plain": {"assumptions": ["(e :\u03b1) \u2208 (s :\u03b1 -> bool)", "SURJ (f :\u03b1 -> \u03b2) (s :\u03b1 -> bool) (t :\u03b2 -> bool)", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u21d2 (f :\u03b1 -> \u03b2) x = f y \u21d2 x = y", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool)"], "goal": "SURJ (f :\u03b1 -> \u03b2) ((s :\u03b1 -> bool) DELETE (e :\u03b1)) ((t :\u03b2 -> bool) DELETE f e)"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.INJ_DEF, pred_setTheory.IN_DELETE, pred_setTheory.EXISTS_IN_IMAGE, pred_setTheory.BIJ_DEF, pred_setTheory.INJ_DELETE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Ve Vs", "@ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN @ Vf Vx Vt @ @ C$min$ ==> @ @ C$bool$ IN Vx' Vt @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ Vf Vy Vx'", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ ==> @ @ C$min$ = @ Vf Vx @ Vf Vy @ @ C$min$ = Vx Vy", "C$bool$ T"], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vx' @ @ C$bool$ /\\ @ @ C$min$ ==> @ @ C$bool$ IN Vx @ @ C$pred_set$ DELETE Vs Ve @ @ C$bool$ IN @ Vf Vx @ @ C$pred_set$ DELETE Vt @ Vf Ve @ @ C$min$ ==> @ @ C$bool$ IN Vx' @ @ C$pred_set$ DELETE Vt @ Vf Ve @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy @ @ C$pred_set$ DELETE Vs Ve @ @ C$min$ = @ Vf Vy Vx'"}, "plain": {"assumptions": ["(e :\u03b1) \u2208 (s :\u03b1 -> bool)", "\u2200(x :\u03b1) (x' :\u03b2). (x \u2208 (s :\u03b1 -> bool) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool)) \u2227 (x' \u2208 t \u21d2 \u2203(y :\u03b1). y \u2208 s \u2227 f y = x')", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u21d2 (f :\u03b1 -> \u03b2) x = f y \u21d2 x = y", "T"], "goal": "\u2200(x :\u03b1) (x' :\u03b2). (x \u2208 (s :\u03b1 -> bool) DELETE (e :\u03b1) \u21d2 (f :\u03b1 -> \u03b2) x \u2208 (t :\u03b2 -> bool) DELETE f e) \u2227 (x' \u2208 t DELETE f e \u21d2 \u2203(y :\u03b1). y \u2208 s DELETE e \u2227 f y = x')"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.INTER_DEF, pred_setTheory.SURJ_DEF, boolTheory.PULL_FORALL, pred_setTheory.SURJ_DEF, pred_setTheory.INJ_DEF]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.DELETE_applied, pred_setTheory.INTER_ASSOC, pred_setTheory.IN_ABS, pred_setTheory.IMAGE_INTER, pred_setTheory.IN_APP]", "reward": 5}]], "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n (REVERSE l) = ELL (PRE (LENGTH l \u2212 n)) l": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$rich_list$ ELL Vn @ C$list$ REVERSE Vl @ @ C$rich_list$ ELL @ C$prim_rec$ PRE @ @ C$arithmetic$ - @ C$list$ LENGTH Vl Vn Vl"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (l :\u03b1 list). n < LENGTH l \u21d2 ELL n (REVERSE l) = ELL (PRE (LENGTH l \u2212 n)) l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.ELL_EL, rich_listTheory.SCANR, rich_listTheory.BUTLASTN_def, listTheory.EL_REVERSE, rich_listTheory.LASTN_def]", "reward": 5}]], "\u2200(l :(\u03b1 # \u03b2) list). ZIP (UNZIP l) = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :(\u03b1 # \u03b2) list). ZIP (UNZIP l) = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "ZIP (UNZIP ([] :(\u03b1 # \u03b2) list)) = ([] :(\u03b1 # \u03b2) list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["ZIP (UNZIP (l :(\u03b1 # \u03b2) list)) = l"], "goal": "\u2200(h :\u03b1 # \u03b2). ZIP (UNZIP (h::(l :(\u03b1 # \u03b2) list))) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ ZIP @ C$list$ UNZIP @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["ZIP (UNZIP (l :(\u03b1 # \u03b2) list)) = l"], "goal": "\u2200(h :\u03b1 # \u03b2). ZIP (UNZIP (h::(l :(\u03b1 # \u03b2) list))) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.UNZIP, listTheory.EL_restricted, listTheory.ZIP, listTheory.LIST_REL_rules, listTheory.ZIP_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.list_size_def, listTheory.NOT_EQ_LIST, listTheory.UNZIP, listTheory.FILTER_EQ_CONS, listTheory.ZIP_def]", "reward": 5}]], "(list_CASE (x :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). x = a::l \u2227 f a l = v'": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE Vx Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vx C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"}, "plain": {"assumptions": [], "goal": "(list_CASE (x :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). x = a::l \u2227 f a l = v'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE C$list$ NIL Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"}, "plain": {"assumptions": [], "goal": "(list_CASE ([] :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). ([] :\u03b1 list) = a::l \u2227 f a l = v'"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE Vx Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vx C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh Vx Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"}, "plain": {"assumptions": ["(list_CASE (x :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). x = a::l \u2227 f a l = v'"], "goal": "\u2200(h :\u03b1). (list_CASE (h::(x :\u03b1 list)) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 h::x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). h::x = a::l \u2227 f a l = v'"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `x`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE Vx Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vx C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = Vx @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh Vx Vv Vf Vv' @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx C$list$ NIL @ @ C$min$ = Vv Vv' @ C$bool$ ? | Va @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vx @ @ C$list$ CONS Va Vl @ @ C$min$ = @ @ Vf Va Vl Vv'"}, "plain": {"assumptions": ["(list_CASE (x :\u03b1 list) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). x = a::l \u2227 f a l = v'"], "goal": "\u2200(h :\u03b1). (list_CASE (h::(x :\u03b1 list)) (v :\u03b2) (f :\u03b1 -> \u03b1 list -> \u03b2) :\u03b2) = (v' :\u03b2) \u21d4 h::x = ([] :\u03b1 list) \u2227 v = v' \u2228 \u2203(a :\u03b1) (l :\u03b1 list). h::x = a::l \u2227 f a l = v'"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[boolTheory.OR_CLAUSES, listTheory.list_case_def, boolTheory.MONO_OR, boolTheory.SELECT_ELIM_THM, boolTheory.LET_RATOR]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[boolTheory.ONE_ONE_DEF, boolTheory.EXISTS_UNIQUE_DEF, listTheory.list_case_def, boolTheory.LEFT_OR_OVER_AND, boolTheory.RIGHT_OR_OVER_AND]", "reward": 5}]], "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). MAP f (TL l) = TL (MAP f l)": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL Vl @ C$list$ TL @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2). MAP f (TL l) = TL (MAP f l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL C$list$ NIL @ C$list$ TL @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2). MAP f (TL ([] :\u03b1 list)) = TL (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL Vl @ C$list$ TL @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). MAP f (TL (l :\u03b1 list)) = TL (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). MAP f (TL (h::(l :\u03b1 list))) = TL (MAP f (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL Vl @ C$list$ TL @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ TL @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2). MAP f (TL (l :\u03b1 list)) = TL (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2). MAP f (TL (h::(l :\u03b1 list))) = TL (MAP f (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.MAP, boolTheory.CONJ_ASSOC, listTheory.TL_DEF, listTheory.TL_DEF, listTheory.LIST_TO_SET]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.TL_DEF, listTheory.TL_DEF, listTheory.LIST_TO_SET, listTheory.MAP]", "reward": 5}]], "(\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acLLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 LLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (LLEX R (h1::t1) (h2::t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ @ C$list$ LLEX VR C$list$ NIL C$list$ NIL @ C$bool$ ~ @ @ @ C$list$ LLEX VR @ @ C$list$ CONS Vh1 Vt1 C$list$ NIL @ @ C$bool$ /\\ @ @ @ C$list$ LLEX VR C$list$ NIL @ @ C$list$ CONS Vh2 Vt2 @ @ C$min$ = @ @ @ C$list$ LLEX VR @ @ C$list$ CONS Vh1 Vt1 @ @ C$list$ CONS Vh2 Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ LLEX VR Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "(\u00acLLEX (R :\u03b1 -> \u03b1 -> bool) ([] :\u03b1 list) ([] :\u03b1 list) \u2227 \u00acLLEX R ((h1 :\u03b1)::(t1 :\u03b1 list)) ([] :\u03b1 list)) \u2227 LLEX R ([] :\u03b1 list) ((h2 :\u03b1)::(t2 :\u03b1 list)) \u2227 (LLEX R (h1::t1) (h2::t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ~ @ @ @ C$list$ list_CASE C$list$ NIL C$bool$ F | Vh2 | Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ LLEX VR Vt1 Vt2 @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh2 Vt2 C$list$ NIL @ @ C$min$ = @ @ @ C$list$ list_CASE @ @ C$list$ CONS Vh2 Vt2 C$bool$ F | Vh2 | Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ LLEX VR Vt1 Vt2 @ @ C$bool$ \\/ @ @ VR Vh1 Vh2 @ @ C$bool$ /\\ @ @ C$min$ = Vh1 Vh2 @ @ @ C$list$ LLEX VR Vt1 Vt2"}, "plain": {"assumptions": [], "goal": "\u00ac(case ([] :\u03b1 list) of ([] :\u03b1 list) => F | h2::t2 => (R :\u03b1 -> \u03b1 -> bool) (h1 :\u03b1) h2 \u2228 h1 = h2 \u2227 LLEX R (t1 :\u03b1 list) t2) \u2227 (h2 :\u03b1)::(t2 :\u03b1 list) \u2260 ([] :\u03b1 list) \u2227 ((case h2::t2 of ([] :\u03b1 list) => F | h2::t2 => R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2) \u21d4 R h1 h2 \u2228 h1 = h2 \u2227 LLEX R t1 t2)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.PAD_RIGHT, listTheory.LLEX_def, listTheory.UNZIP_THM, listTheory.LIST_REL_cases, listTheory.FOLDL2_FOLDL]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.PAD_RIGHT, listTheory.HD_DROP, listTheory.LENGTH, listTheory.list_distinct, listTheory.list_case_def]", "reward": 5}]], "\u2200(c :bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). c) l \u21d4 l = ([] :\u03b1 list) \u2228 c": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vc @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ EVERY | Vx Vc Vl @ @ C$bool$ \\/ @ @ C$min$ = Vl C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "\u2200(c :bool) (l :\u03b1 list). EVERY (\u03bb(x :\u03b1). c) l \u21d4 l = ([] :\u03b1 list) \u2228 c"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl Vc @ @ C$bool$ \\/ @ @ C$min$ = Vl C$list$ NIL Vc"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). MEM x (l :\u03b1 list) \u21d2 (c :bool)) \u21d4 l = ([] :\u03b1 list) \u2228 c"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.LEFT_EXISTS_IMP_THM, boolTheory.OR_CLAUSES, boolTheory.EXCLUDED_MIDDLE, listTheory.MAP2, listTheory.EVERY_MEM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$list$ LIST_TO_SET Vl Vx Vc @ @ C$bool$ \\/ @ @ C$min$ = Vl C$list$ NIL Vc @ @ C$bool$ /\\ @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$list$ LIST_TO_SET Vl Vx @ C$bool$ ~ Vc @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ C$bool$ ~ Vc"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1). set (l :\u03b1 list) x \u21d2 (c :bool)) \u2227 (l = ([] :\u03b1 list) \u2228 c) \u2228 (\u2203(x :\u03b1). set l x \u2227 \u00acc) \u2227 l \u2260 ([] :\u03b1 list) \u2227 \u00acc"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.ONTO_THM, boolTheory.IMP_F_EQ_F, boolTheory.IN_DEF, boolTheory.LEFT_AND_CONG, boolTheory.EQ_EXPAND]", "reward": 0.1}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.list_CASES, boolTheory.NOT_CLAUSES, listTheory.LIST_TO_SET_DEF, listTheory.MAP2_APPEND, listTheory.list_case_def]", "reward": 5}]], "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 FRONT l ++ [LAST l] = l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT Vl @ @ C$list$ CONS @ C$list$ LAST Vl C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). l \u2260 ([] :\u03b1 list) \u21d2 FRONT l ++ [LAST l] = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT C$list$ NIL @ @ C$list$ CONS @ C$list$ LAST C$list$ NIL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT ([] :\u03b1 list) \u29fa [LAST ([] :\u03b1 list)] = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT Vl @ @ C$list$ CONS @ C$list$ LAST Vl C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ C$list$ LAST @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT l \u29fa [LAST l] = l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT (h::l) \u29fa [LAST (h::l)] = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT Vl @ @ C$list$ CONS @ C$list$ LAST Vl C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ C$list$ LAST @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT l \u29fa [LAST l] = l"], "goal": "\u2200(h :\u03b1). h::(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT (h::l) \u29fa [LAST (h::l)] = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_SPLIT2, listTheory.LIST_REL_SPLIT2, listTheory.LIST_REL_SPLIT1, listTheory.ZIP, listTheory.ZIP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL", "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT Vl @ @ C$list$ CONS @ C$list$ LAST Vl C$list$ NIL Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS @ C$list$ LAST @ @ C$list$ CONS Vh Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(h :\u03b1)::(l :\u03b1 list) \u2260 ([] :\u03b1 list)", "(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT l \u29fa [LAST l] = l"], "goal": "FRONT ((h :\u03b1)::(l :\u03b1 list)) \u29fa [LAST (h::l)] = h::l"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_MAP, listTheory.LENGTH_ZIP, listTheory.MEM, listTheory.LENGTH_ZIP, listTheory.MAP_TL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = @ @ C$list$ CONS Vh Vl C$list$ NIL", "@ @ C$min$ ==> @ C$bool$ ~ @ @ C$min$ = Vl C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ FRONT Vl @ @ C$list$ CONS @ C$list$ LAST Vl C$list$ NIL Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ @ C$bool$ COND @ @ C$min$ = Vl C$list$ NIL C$list$ NIL @ @ C$list$ CONS Vh @ C$list$ FRONT Vl @ @ C$list$ CONS @ @ @ C$bool$ COND @ @ C$min$ = Vl C$list$ NIL Vh @ C$list$ LAST Vl C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(h :\u03b1)::(l :\u03b1 list) \u2260 ([] :\u03b1 list)", "(l :\u03b1 list) \u2260 ([] :\u03b1 list) \u21d2 FRONT l \u29fa [LAST l] = l"], "goal": "(if (l :\u03b1 list) = ([] :\u03b1 list) then ([] :\u03b1 list) else (h :\u03b1)::FRONT l) \u29fa [if l = ([] :\u03b1 list) then h else LAST l] = h::l"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EXISTS_MEM, listTheory.LAST_DEF, listTheory.FRONT_CONS, listTheory.FRONT_DEF, listTheory.APPEND]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.NULL_DEF, boolTheory.BOOL_FUN_INDUCT, boolTheory.SWAP_FORALL_THM, listTheory.APPEND, listTheory.LENGTH_FRONT_CONS]", "reward": 5}]], "($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [7, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ RTC C$pred_set$ PSUBSET C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET @ C$relation$ RTC C$pred_set$ PSUBSET C$pred_set$ SUBSET @ @ C$relation$ RSUBSET C$pred_set$ SUBSET @ C$relation$ RTC C$pred_set$ PSUBSET"}, "plain": {"assumptions": [], "goal": "($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 \u2286\u1d63 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2227 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.TC_CASES1, pred_setTheory.EMPTY_DEF, relationTheory.inv_TC, relationTheory.EqIsBothRSUBSET, relationTheory.inv_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC C$pred_set$ PSUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vx Vy @ @ @ C$relation$ RTC C$pred_set$ PSUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 x y \u21d2 x \u2286 y) \u2227 \u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u2286 y \u21d2 ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 x y"}}], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.INVOL, relationTheory.IDEM, relationTheory.RSUBSET, relationTheory.inv_image_def, relationTheory.WeakOrder]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ = @ Vx Vx' @ Vy Vx' @ @ @ C$relation$ TC C$pred_set$ PSUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vx Vy @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ = @ Vx Vx' @ Vy Vx' @ @ @ C$relation$ TC C$pred_set$ PSUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). (\u2200(x' :\u03b1). x x' \u21d4 y x') \u2228 ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\u207a x y \u21d2 x \u2286 y) \u2227 \u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u2286 y \u21d2 (\u2200(x' :\u03b1). x x' \u21d4 y x') \u2228 ($PSUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\u207a x y"}}], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.EXTENSION, relationTheory.WeakOrder_EQ, relationTheory.RTC_CASES_TC, relationTheory.RTC_CASES_TC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ = @ Vx Vx' @ Vy Vx' @ @ C$pred_set$ PSUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$pred_set$ SUBSET Vx Vy @ @ C$bool$ \\/ @ C$bool$ ! | Vx' @ @ C$min$ = @ Vx Vx' @ Vy Vx' @ @ C$pred_set$ PSUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). (\u2200(x' :\u03b1). x x' \u21d4 y x') \u2228 x \u2282 y \u21d2 x \u2286 y) \u2227 \u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). x \u2286 y \u21d2 (\u2200(x' :\u03b1). x x' \u21d4 y x') \u2228 x \u2282 y"}}], "parent": 3, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, relationTheory.INDUCTIVE_INVARIANT_ON_DEF, relationTheory.RTC_ALT_RIGHT_DEF, pred_setTheory.UNIV_applied, pred_setTheory.TC_PSUBSET]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[relationTheory.RRANGE, relationTheory.inv_DEF, pred_setTheory.SUBSET_DEF, pred_setTheory.PSUBSET_DEF, pred_setTheory.PSUBSET_DEF]", "reward": 5}]], "($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ RTC C$pred_set$ SUBSET C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 = ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$relation$ RSUBSET @ C$relation$ RTC C$pred_set$ SUBSET C$pred_set$ SUBSET @ @ C$relation$ RSUBSET C$pred_set$ SUBSET @ C$relation$ RTC C$pred_set$ SUBSET"}, "plain": {"assumptions": [], "goal": "($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 \u2286\u1d63 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2227 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool) \u2286\u1d63 ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.TC_CASES1, pred_setTheory.EMPTY_DEF, relationTheory.inv_TC, relationTheory.EqIsBothRSUBSET, relationTheory.TC_IDEM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ @ C$relation$ RTC C$pred_set$ SUBSET Vx Vy @ @ C$pred_set$ SUBSET Vx Vy"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1 -> bool) (y :\u03b1 -> bool). ($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 x y \u21d2 x \u2286 y"}}], "parent": 1, "goal": 0, "by_tactic": "simp[relationTheory.INVOL, pred_setTheory.IN_APP, relationTheory.RSUBSET, relationTheory.RSUBSET, relationTheory.RC_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ Vx Vx'", "@ @ @ C$relation$ RTC C$pred_set$ SUBSET Vx Vy"], "goal": "@ Vy Vx'"}, "plain": {"assumptions": ["(x :\u03b1 -> bool) (x' :\u03b1)", "($SUBSET :(\u03b1 -> bool) -> (\u03b1 -> bool) -> bool)\ua673 (x :\u03b1 -> bool) (y :\u03b1 -> bool)"], "goal": "(y :\u03b1 -> bool) (x' :\u03b1)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.SUBSET_DEF, pred_setTheory.GSPECIFICATION, pred_setTheory.EXTENSION, relationTheory.INVOL]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.SPECIFICATION, pred_setTheory.NOT_IN_EMPTY, pred_setTheory.TC_SUBSET_THM, pred_setTheory.SUBSET_DEF, relationTheory.EXTEND_RTC_TC_RIGHT1_EQN]", "reward": 5}]], "\u2200(l :\u03b1 list) (n :num). LENGTH l \u2264 n \u21d2 TAKE n l = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl Vn @ @ C$min$ = @ @ C$list$ TAKE Vn Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (n :num). LENGTH l \u2264 n \u21d2 TAKE n l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH C$list$ NIL Vn @ @ C$min$ = @ @ C$list$ TAKE Vn C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(n :num). LENGTH ([] :\u03b1 list) \u2264 n \u21d2 TAKE n ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl Vn @ @ C$min$ = @ @ C$list$ TAKE Vn Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl Vn @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) \u2264 n \u21d2 TAKE n l = l"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l :\u03b1 list)) \u2264 n \u21d2 TAKE n (h::l) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH Vl Vn @ @ C$min$ = @ @ C$list$ TAKE Vn Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$arithmetic$ <= @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl Vn @ @ C$min$ = @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(n :num). LENGTH (l :\u03b1 list) \u2264 n \u21d2 TAKE n l = l"], "goal": "\u2200(h :\u03b1) (n :num). LENGTH (h::(l :\u03b1 list)) \u2264 n \u21d2 TAKE n (h::l) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.APPEND_eq_NIL, listTheory.TAKE_def, listTheory.ZIP_def, listTheory.UNZIP_THM, listTheory.UNZIP_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.WOP_measure, listTheory.EL, listTheory.TAKE_def, arithmeticTheory.OR_LESS, listTheory.LENGTH]", "reward": 5}]], "LIST_BIND (l :\u03b1 list list) (\u03bb(x :\u03b1 list). x) = FLAT l \u2227 LIST_BIND l (I :\u03b1 list -> \u03b1 list) = FLAT l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ LIST_BIND Vl | Vx Vx @ C$list$ FLAT Vl @ @ C$min$ = @ @ C$list$ LIST_BIND Vl C$combin$ I @ C$list$ FLAT Vl"}, "plain": {"assumptions": [], "goal": "LIST_BIND (l :\u03b1 list list) (\u03bb(x :\u03b1 list). x) = FLAT l \u2227 LIST_BIND l (I :\u03b1 list -> \u03b1 list) = FLAT l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ LIST_BIND Vl | Vx Vx @ C$list$ LENGTH @ C$list$ FLAT Vl @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ C$list$ LIST_BIND Vl | Vx Vx @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ LIST_BIND Vl | Vx Vx @ @ C$list$ EL Vx @ C$list$ FLAT Vl @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ LIST_BIND Vl C$combin$ I @ C$list$ LENGTH @ C$list$ FLAT Vl @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ C$list$ LIST_BIND Vl C$combin$ I @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ LIST_BIND Vl C$combin$ I @ @ C$list$ EL Vx @ C$list$ FLAT Vl"}, "plain": {"assumptions": [], "goal": "(LENGTH (LIST_BIND (l :\u03b1 list list) (\u03bb(x :\u03b1 list). x)) = LENGTH (FLAT l) \u2227 \u2200(x :num). x < LENGTH (LIST_BIND l (\u03bb(x :\u03b1 list). x)) \u21d2 EL x (LIST_BIND l (\u03bb(x :\u03b1 list). x)) = EL x (FLAT l)) \u2227 LENGTH (LIST_BIND l (I :\u03b1 list -> \u03b1 list)) = LENGTH (FLAT l) \u2227 \u2200(x :num). x < LENGTH (LIST_BIND l (I :\u03b1 list -> \u03b1 list)) \u21d2 EL x (LIST_BIND l (I :\u03b1 list -> \u03b1 list)) = EL x (FLAT l)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[listTheory.REVERSE_GENLIST, listTheory.SUM_SNOC, listTheory.PAD_RIGHT, listTheory.SUM_ACC_DEF, listTheory.LIST_EQ_REWRITE]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.TL_DEF, listTheory.MAP_ID, listTheory.SUM_ACC_SUM_LEM, listTheory.LIST_BIND_def, listTheory.UNZIP]", "reward": 5}]], "\u2200(R :\u03b1 -> \u03b1 -> bool). Order R \u21d4 StrongOrder (STRORD R)": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ Order VR @ C$relation$ StrongOrder @ C$relation$ STRORD VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). Order R \u21d4 StrongOrder (STRORD R)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VR @ @ C$min$ = @ C$relation$ Order VR @ @ C$bool$ /\\ @ C$relation$ irreflexive @ C$relation$ STRORD VR @ C$relation$ transitive @ C$relation$ STRORD VR"}, "plain": {"assumptions": [], "goal": "\u2200(R :\u03b1 -> \u03b1 -> bool). Order R \u21d4 (irreflexive (STRORD R) :bool) \u2227 transitive (STRORD R)"}}], "parent": 0, "goal": 0, "by_tactic": "simp[relationTheory.WeakOrder, boolTheory.TRUTH, relationTheory.StrongOrder, relationTheory.RTC_RTC, relationTheory.RC_OR_Id]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$relation$ Order VR @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ @ @ C$relation$ STRORD VR Vx Vx @ C$relation$ transitive @ C$relation$ STRORD VR"}, "plain": {"assumptions": [], "goal": "Order (R :\u03b1 -> \u03b1 -> bool) \u21d4 (\u2200(x :\u03b1). \u00acSTRORD R x x) \u2227 transitive (STRORD R)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[relationTheory.reflexive_def, relationTheory.irreflexive_def, boolTheory.FUN_EQ_THM, relationTheory.RSUBSET, relationTheory.RTC_SINGLE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$relation$ antisymmetric VR @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ @ @ C$relation$ STRORD VR Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ STRORD VR Vx Vy @ @ @ C$relation$ STRORD VR Vy Vz @ @ @ C$relation$ STRORD VR Vx Vz"}, "plain": {"assumptions": [], "goal": "antisymmetric (R :\u03b1 -> \u03b1 -> bool) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z) \u21d4 (\u2200(x :\u03b1). \u00acSTRORD R x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). STRORD R x y \u2227 STRORD R y z \u21d2 STRORD R x z"}}], "parent": 2, "goal": 0, "by_tactic": "rw[relationTheory.Order, relationTheory.transitive_def, relationTheory.transitive_def, relationTheory.RUNION, relationTheory.EqIsBothRSUBSET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vx @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ~ @ @ @ C$relation$ STRORD VR Vx Vx @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ @ C$relation$ STRORD VR Vx Vy @ @ @ C$relation$ STRORD VR Vy Vz @ @ @ C$relation$ STRORD VR Vx Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1). (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y x \u21d2 x = y) \u2227 (\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z) \u21d4 (\u2200(x :\u03b1). \u00acSTRORD R x x) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). STRORD R x y \u2227 STRORD R y z \u21d2 STRORD R x z"}}], "parent": 3, "goal": 0, "by_tactic": "rw[relationTheory.RC_DEF, relationTheory.TC_DEF, relationTheory.antisymmetric_def, relationTheory.WeakOrder, relationTheory.EQC_TRANS]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ /\\ @ @ VR Vx Vy @ C$bool$ ~ @ @ C$min$ = Vx Vy @ @ C$bool$ /\\ @ @ VR Vy Vz @ C$bool$ ~ @ @ C$min$ = Vy Vz @ @ C$bool$ /\\ @ @ VR Vx Vz @ C$bool$ ~ @ @ C$min$ = Vx Vz @ @ C$bool$ /\\ @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vx @ @ C$min$ = Vx Vy @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz"}, "plain": {"assumptions": [], "goal": "(\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). ((R :\u03b1 -> \u03b1 -> bool) x y \u2227 x \u2260 y) \u2227 R y z \u2227 y \u2260 z \u21d2 R x z \u2227 x \u2260 z) \u21d4 (\u2200(x :\u03b1) (y :\u03b1). R x y \u2227 R y x \u21d2 x = y) \u2227 \u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). R x y \u2227 R y z \u21d2 R x z"}}], "parent": 4, "goal": 0, "by_tactic": "rw[relationTheory.STRORD, relationTheory.reflexive_def, boolTheory.EQ_SYM_EQ, boolTheory.EQ_SYM, relationTheory.RUNION]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[boolTheory.FUN_EQ_THM, boolTheory.bool_case_thm, boolTheory.NOT_F, boolTheory.IMP_F_EQ_F, relationTheory.STRORD_AND_NOT_Id]", "reward": 5}]], "\u2200(l :\u03b1 list) (m :num) (x :\u03b1). MEM x (TAKE m l) \u21d2 MEM x l": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (m :num) (x :\u03b1). MEM x (TAKE m l) \u21d2 MEM x l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm C$list$ NIL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (x :\u03b1). MEM x (TAKE m ([] :\u03b1 list)) \u21d2 MEM x ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (x :\u03b1). MEM x (TAKE m (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "\u2200(h :\u03b1) (m :num) (x :\u03b1). MEM x (TAKE m (h::(l :\u03b1 list))) \u21d2 MEM x (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (x :\u03b1). MEM x (TAKE m (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "\u2200(h :\u03b1) (m :num) (x :\u03b1). MEM x (TAKE m (h::(l :\u03b1 list))) \u21d2 MEM x (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.REVERSE_DEF, listTheory.nub_def, listTheory.SHORTLEX_total, listTheory.LENGTH_UNZIP, listTheory.EL_restricted]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ @ C$bool$ COND @ @ C$min$ = Vm C$num$ 0 C$list$ NIL @ @ C$list$ CONS Vh @ @ C$list$ TAKE @ @ C$arithmetic$ - Vm @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ TAKE Vm Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vx Vh @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["MEM (x :\u03b1) (if (m :num) = (0 :num) then ([] :\u03b1 list) else (h :\u03b1)::TAKE (m \u2212 (1 :num)) (l :\u03b1 list))", "\u2200(m :num) (x :\u03b1). MEM x (TAKE m (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "(x :\u03b1) = (h :\u03b1) \u2228 MEM x (l :\u03b1 list)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_DEF, listTheory.TAKE_def, listTheory.UNZIP, listTheory.UNZIP, listTheory.UNZIP]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "metis_tac[listTheory.list_CASES, listTheory.ZIP_GENLIST, listTheory.MEM, listTheory.APPEND_SNOC, listTheory.UNZIP]", "reward": 5}]], "\u2200(ls :\u03b1 list) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (ls,ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls": [4, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vls @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , Vls Vls @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx Vls"}, "plain": {"assumptions": [], "goal": "\u2200(ls :\u03b1 list) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (ls,ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL C$list$ NIL @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (([] :\u03b1 list),([] :\u03b1 list))) = MAP (\u03bb(x :\u03b1). f (x,x)) ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , Vls Vls @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx Vls"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["\u2200(f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP ((ls :\u03b1 list),ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls"], "goal": "\u2200(h :\u03b1) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (h::(ls :\u03b1 list),h::ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) (h::ls)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , Vls Vls @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx Vls"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh Vls @ @ C$list$ CONS Vh Vls @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx @ @ C$list$ CONS Vh Vls"}, "plain": {"assumptions": ["\u2200(f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP ((ls :\u03b1 list),ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) ls"], "goal": "\u2200(h :\u03b1) (f :\u03b1 # \u03b1 -> \u03b2). MAP f (ZIP (h::(ls :\u03b1 list),h::ls)) = MAP (\u03bb(x :\u03b1). f (x,x)) (h::ls)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL C$list$ NIL @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 # \u03b1 -> \u03b2) (ZIP (([] :\u03b1 list),([] :\u03b1 list))) = MAP (\u03bb(x :\u03b1). f (x,x)) ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_EL_EQN, listTheory.TAKE_DROP, listTheory.FOLDL_CONG, listTheory.GENLIST_GENLIST_AUX, pairTheory.SND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL C$list$ NIL @ @ C$list$ MAP | Vx @ Vf @ @ C$pair$ , Vx Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 # \u03b1 -> \u03b2) (ZIP (([] :\u03b1 list),([] :\u03b1 list))) = MAP (\u03bb(x :\u03b1). f (x,x)) ([] :\u03b1 list)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_NIL, listTheory.LIST_REL_def, listTheory.MAP, listTheory.TAKE_def, listTheory.ZIP_def]", "reward": 0.2}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_TO_SET_DEF, listTheory.MAP, listTheory.UNZIP, listTheory.UNZIP_THM, listTheory.ZIP_def]", "reward": 5}]], "\u2200(l :bool list). OR_EL l \u21d4 FOLDL $\\/ F l": [2, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ = @ C$rich_list$ OR_EL Vl @ @ @ C$list$ FOLDL C$bool$ \\/ C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :bool list). OR_EL l \u21d4 FOLDL $\\/ F l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$rich_list$ OR_EL Vl @ @ @ C$list$ FOLDL C$bool$ \\/ C$bool$ F Vl"}, "plain": {"assumptions": [], "goal": "OR_EL (l :bool list) \u21d4 FOLDL $\\/ F l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_UNZIP, listTheory.MEM_SPLIT, rich_listTheory.AND_EL_DEF, boolTheory.LEFT_OR_OVER_AND, rich_listTheory.LASTN_MAP]", "reward": 0.1}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.MAP_FLAT, rich_listTheory.SEG_TAKE_DROP, rich_listTheory.REVERSE_FOLDR, rich_listTheory.OR_EL_DEF, rich_listTheory.EXISTS_FOLDL_MAP]", "reward": 5}]], "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vl @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf C$list$ NIL @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). ([] :\u03b1 list) = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vl @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh' Vl @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh' Vl @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"}, "plain": {"assumptions": ["MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"], "goal": "\u2200(h' :\u03b1). MAP (f :\u03b1 -> \u03b2) (h'::(l :\u03b1 list)) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). h'::l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf Vl @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vl @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ = @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh' Vl @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vx0 @ C$bool$ ? | Vt0 @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh' Vl @ @ C$list$ CONS Vx0 Vt0 @ @ C$bool$ /\\ @ @ C$min$ = Vh @ Vf Vx0 @ @ C$min$ = Vt @ @ C$list$ MAP Vf Vt0"}, "plain": {"assumptions": ["MAP (f :\u03b1 -> \u03b2) (l :\u03b1 list) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"], "goal": "\u2200(h' :\u03b1). MAP (f :\u03b1 -> \u03b2) (h'::(l :\u03b1 list)) = (h :\u03b2)::(t :\u03b2 list) \u21d4 \u2203(x0 :\u03b1) (t0 :\u03b1 list). h'::l = x0::t0 \u2227 h = f x0 \u2227 t = MAP f t0"}}], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.MAP, listTheory.EL, listTheory.LIST_TO_SET_DEF, boolTheory.JRH_INDUCT_UTIL, listTheory.list_case_def]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "metis_tac[listTheory.CONS_11, listTheory.TL_DEF, boolTheory.bool_case_thm, listTheory.MAP, listTheory.MAP2]", "reward": 5}]], "LIST_REL (R :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) ((h :\u03b2)::(t :\u03b2 list)) \u21d4 \u2203(h' :\u03b1) (t' :\u03b1 list). xs = h'::t' \u2227 R h' h \u2227 LIST_REL R t' t": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ LIST_REL VR Vxs @ @ C$list$ CONS Vh Vt @ C$bool$ ? | Vh' @ C$bool$ ? | Vt' @ @ C$bool$ /\\ @ @ C$min$ = Vxs @ @ C$list$ CONS Vh' Vt' @ @ C$bool$ /\\ @ @ VR Vh' Vh @ @ @ C$list$ LIST_REL VR Vt' Vt"}, "plain": {"assumptions": [], "goal": "LIST_REL (R :\u03b1 -> \u03b2 -> bool) (xs :\u03b1 list) ((h :\u03b2)::(t :\u03b2 list)) \u21d4 \u2203(h' :\u03b1) (t' :\u03b1 list). xs = h'::t' \u2227 R h' h \u2227 LIST_REL R t' t"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.list_CASES, listTheory.LIST_REL_cases, listTheory.APPEND_11_LENGTH, listTheory.APPEND_eq_NIL, listTheory.LIST_REL_def]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (n :num) (l :\u03b1 list). MAP f (TAKE n l) = TAKE n (MAP f l)": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (n :num) (l :\u03b1 list). MAP f (TAKE n l) = TAKE n (MAP f l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n ([] :\u03b1 list)) = TAKE n (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n (l :\u03b1 list)) = TAKE n (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n (h::(l :\u03b1 list))) = TAKE n (MAP f (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n (l :\u03b1 list)) = TAKE n (MAP f l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n (h::(l :\u03b1 list))) = TAKE n (MAP f (h::l))"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (TAKE (n :num) ([] :\u03b1 list)) = TAKE n (MAP f ([] :\u03b1 list))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.UNZIP, listTheory.FRONT_DEF, listTheory.UNZIP, listTheory.MAP2_NIL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (TAKE (n :num) ([] :\u03b1 list)) = TAKE n (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vn @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (n :num). MAP f (TAKE n (l :\u03b1 list)) = TAKE n (MAP f l)"], "goal": "MAP (f :\u03b1 -> \u03b2) (TAKE (n :num) ((h :\u03b1)::(l :\u03b1 list))) = TAKE n (MAP f (h::l))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.EL, listTheory.UNZIP_THM, listTheory.FLAT, listTheory.ZIP, listTheory.UNZIP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ TAKE Vn C$list$ NIL @ @ C$list$ TAKE Vn @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (TAKE (n :num) ([] :\u03b1 list)) = TAKE n (MAP f ([] :\u03b1 list))"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.MAP, boolTheory.EQ_SYM, listTheory.TAKE_def, listTheory.SUM, listTheory.LAST_MAP]", "reward": 0.2}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.LENGTH_TL, listTheory.MAP, listTheory.REVERSE_DEF, listTheory.TAKE_def]", "reward": 5}]], "MAP (f :\u03b2 -> \u03b1) (LIST_BIND (l :\u03b3 list) (g :\u03b3 -> \u03b2 list)) = LIST_BIND l (MAP f \u2218 g)": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ LIST_BIND Vl Vg @ @ C$list$ LIST_BIND Vl @ @ C$combin$ o @ C$list$ MAP Vf Vg"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b2 -> \u03b1) (LIST_BIND (l :\u03b3 list) (g :\u03b3 -> \u03b2 list)) = LIST_BIND l (MAP f \u2218 g)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (l :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) l)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.SUM_IMAGE_eq_SUM_MAP_SET_TO_LIST, listTheory.FLAT, listTheory.LIST_BIND_def, listTheory.LENGTH_EQ_NUM_compute, listTheory.LIST_BIND_MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg C$list$ NIL @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) ([] :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) ([] :\u03b3 list))"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (l :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) l)"], "goal": "\u2200(h :\u03b3). MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (h::(l :\u03b3 list)))) = FLAT (MAP (MAP f \u2218 g) (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (l :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) l)"], "goal": "\u2200(h :\u03b3). MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (h::(l :\u03b3 list)))) = FLAT (MAP (MAP f \u2218 g) (h::l))"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.EL_REVERSE, listTheory.LIST_REL_def, listTheory.FLAT, listTheory.LIST_REL_SPLIT2, listTheory.MAP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg @ @ C$list$ CONS Vh Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (l :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) l)"], "goal": "MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) ((h :\u03b3)::(l :\u03b3 list)))) = FLAT (MAP (MAP f \u2218 g) (h::l))"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.EVERY_FILTER, listTheory.FILTER_EQ_CONS, listTheory.SUM_APPEND, listTheory.TAKE_def, listTheory.FRONT_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ C$list$ FLAT @ @ C$list$ CONS @ Vg Vh @ @ C$list$ MAP Vg Vl @ C$list$ FLAT @ @ C$list$ CONS @ @ C$list$ MAP Vf @ Vg Vh @ @ C$list$ MAP @ @ C$combin$ o @ C$list$ MAP Vf Vg Vl"}, "plain": {"assumptions": ["MAP (f :\u03b2 -> \u03b1) (FLAT (MAP (g :\u03b3 -> \u03b2 list) (l :\u03b3 list))) = FLAT (MAP (MAP f \u2218 g) l)"], "goal": "MAP (f :\u03b2 -> \u03b1) (FLAT ((g :\u03b3 -> \u03b2 list) (h :\u03b3)::MAP g (l :\u03b3 list))) = FLAT (MAP f (g h)::MAP (MAP f \u2218 g) l)"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.NOT_NULL_MEM, listTheory.MAP_EQ_f, listTheory.MAP, listTheory.MAP_SNOC, listTheory.FINITE_LIST_TO_SET]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.EL_GENLIST, listTheory.MAP_APPEND, listTheory.LENGTH_TAKE_EQ, listTheory.FLAT, listTheory.REVERSE_SNOC]", "reward": 5}]], "\u2200(n :num) (x :\u03b1) (y :\u03b1). MEM y (REPLICATE n x) \u21d4 x = y \u2227 (0 :num) < n": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vn @ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn"}, "plain": {"assumptions": [], "goal": "\u2200(n :num) (x :\u03b1) (y :\u03b1). MEM y (REPLICATE n x) \u21d4 x = y \u2227 (0 :num) < n"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn"}, "plain": {"assumptions": [], "goal": "MEM (y :\u03b1) (REPLICATE (n :num) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < n"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.EVERY_MEM, listTheory.EVERY2_LUPDATE_same, rich_listTheory.APPEND_BUTLASTN_LASTN, rich_listTheory.DROP_APPEND, rich_listTheory.BUTLASTN_REVERSE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE C$num$ 0 Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 C$num$ 0"}, "plain": {"assumptions": [], "goal": "MEM (y :\u03b1) (REPLICATE (0 :num) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < (0 :num)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn"}, "plain": {"assumptions": ["MEM (y :\u03b1) (REPLICATE (n :num) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < n"], "goal": "MEM (y :\u03b1) (REPLICATE (SUC (n :num)) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < SUC n"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `n`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE @ C$num$ SUC Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 @ C$num$ SUC Vn"}, "plain": {"assumptions": ["MEM (y :\u03b1) (REPLICATE (n :num) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < n"], "goal": "MEM (y :\u03b1) (REPLICATE (SUC (n :num)) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < SUC n"}}], "parent": 2, "goal": 0, "by_tactic": "rw[rich_listTheory.REPLICATE, listTheory.SUM_ACC_SUM_LEM, rich_listTheory.SCANL, listTheory.DROP_TAKE, listTheory.TAKE_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$rich_list$ REPLICATE Vn Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vy Vx @ @ C$bool$ /\\ @ @ C$min$ = Vx Vy @ @ C$prim_rec$ < C$num$ 0 Vn @ @ C$min$ = Vx Vy"}, "plain": {"assumptions": ["MEM (y :\u03b1) (REPLICATE (n :num) (x :\u03b1)) \u21d4 x = y \u2227 (0 :num) < n"], "goal": "(y :\u03b1) = (x :\u03b1) \u2228 x = y \u2227 (0 :num) < (n :num) \u21d4 x = y"}}], "parent": 3, "goal": 0, "by_tactic": "fs[rich_listTheory.ELL_SEG, rich_listTheory.ELL_SEG, rich_listTheory.EL_CONS, listTheory.LIST_TO_SET_DEF, rich_listTheory.REPLICATE]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[rich_listTheory.ELL_REVERSE_EL, rich_listTheory.COUNT_LIST_AUX_def, boolTheory.SELECT_ELIM_THM, listTheory.REV_DEF, boolTheory.LCOMM_THM]", "reward": 5}]], "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). e \u2208 POW set \u21d4 e \u2286 set": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vset @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$pred_set$ POW Vset @ @ C$pred_set$ SUBSET Ve Vset"}, "plain": {"assumptions": [], "goal": "\u2200(set :\u03b1 -> bool) (e :\u03b1 -> bool). e \u2208 POW set \u21d4 e \u2286 set"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.IN_APP, pred_setTheory.COUNT_SUC, pred_setTheory.GSPEC_ETA, pred_setTheory.IMAGE_DEF, pred_setTheory.POW_DEF]", "reward": 5}]], "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool) \u21d2 (\u2205 :\u03b1 -> bool) \u2209 partition R s": [15, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ @ C$pred_set$ equiv_on VR Vs @ C$bool$ ~ @ @ C$bool$ IN C$pred_set$ EMPTY @ @ C$pred_set$ partition VR Vs"}, "plain": {"assumptions": [], "goal": "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool) \u21d2 (\u2205 :\u03b1 -> bool) \u2209 partition R s"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$pred_set$ equiv_on VR Vs"], "goal": "@ C$bool$ ~ @ @ C$bool$ IN C$pred_set$ EMPTY @ C$pred_set$ GSPEC | Vt @ @ C$pair$ , Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx' @ @ C$min$ = @ Vt Vx' @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy Vx'"}, "plain": {"assumptions": ["(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool)"], "goal": "(\u2205 :\u03b1 -> bool) \u2209 {t | \u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 \u2200(x' :\u03b1). t x' \u21d4 equiv_class (R :\u03b1 -> \u03b1 -> bool) s x x'}"}}], "parent": 0, "goal": 0, "by_tactic": "rw[pred_setTheory.SUBSET_DEF, pred_setTheory.SUBSET_DEF, boolTheory.FUN_EQ_THM, pred_setTheory.partition_def, pred_setTheory.INJ_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ @ C$min$ = @ C$pred_set$ EMPTY Vx' @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy Vx'", "@ @ C$bool$ IN Vx Vs", "@ @ C$pred_set$ equiv_on VR Vs"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). \u2205 x' \u21d4 equiv_class (R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (x :\u03b1) x'", "(x :\u03b1) \u2208 (s :\u03b1 -> bool)", "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool)"], "goal": "F"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.SUBSET_ANTISYM_EQ, pred_setTheory.BIJ_EMPTY, pred_setTheory.INTER_DEF, pred_setTheory.IN_INTER, pred_setTheory.IN_GSPEC_IFF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN | Vx C$bool$ F @ C$pred_set$ GSPEC | Vt @ @ C$pair$ , Vt @ C$bool$ ? | Vx @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ C$bool$ ! | Vx' @ @ C$min$ = @ Vt Vx' @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy Vx'", "@ @ C$pred_set$ equiv_on VR Vs"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["(\u03bb(x :\u03b1). F) \u2208 {t | \u2203(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 \u2200(x' :\u03b1). t x' \u21d4 equiv_class (R :\u03b1 -> \u03b1 -> bool) s x x'}", "(R :\u03b1 -> \u03b1 -> bool) equiv_on (s :\u03b1 -> bool)"], "goal": "F"}}], "parent": 1, "goal": 0, "by_tactic": "fs[pred_setTheory.DIFF_INTER_COMPL, pred_setTheory.SING_applied, pred_setTheory.EMPTY_DEF, pred_setTheory.SING_applied, pred_setTheory.IN_UNION]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ @ C$min$ = @ C$pred_set$ EMPTY Vx' @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ VR Vx Vy Vx'", "@ @ C$bool$ IN Vx Vs", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vy Vs @ @ C$bool$ /\\ @ @ C$bool$ IN Vz Vs @ @ C$bool$ /\\ @ @ VR Vx Vy @ @ VR Vy Vz @ @ VR Vx Vz", "@ C$bool$ ! | Vx @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Vx Vs @ @ C$bool$ IN Vy Vs @ @ C$min$ = @ @ VR Vx Vy @ @ VR Vy Vx", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx Vs @ @ VR Vx Vx"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). \u2205 x' \u21d4 equiv_class (R :\u03b1 -> \u03b1 -> bool) (s :\u03b1 -> bool) (x :\u03b1) x'", "(x :\u03b1) \u2208 (s :\u03b1 -> bool)", "\u2200(x :\u03b1) (y :\u03b1) (z :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u2227 z \u2208 s \u2227 (R :\u03b1 -> \u03b1 -> bool) x y \u2227 R y z \u21d2 R x z", "\u2200(x :\u03b1) (y :\u03b1). x \u2208 (s :\u03b1 -> bool) \u2227 y \u2208 s \u21d2 ((R :\u03b1 -> \u03b1 -> bool) x y \u21d4 R y x)", "\u2200(x :\u03b1). x \u2208 (s :\u03b1 -> bool) \u21d2 (R :\u03b1 -> \u03b1 -> bool) x x"], "goal": "F"}}], "parent": 2, "goal": 0, "by_tactic": "fs[pred_setTheory.INSERT_INTER, pred_setTheory.UNION_DEF, pred_setTheory.DFUNSET_applied, pred_setTheory.DFUNSET_applied, pred_setTheory.equiv_on_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ @ C$min$ = @ C$pred_set$ EMPTY Vx' @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ Vs Vy @ @ VR Vx Vy Vx'", "@ Vs Vx", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ @ C$bool$ /\\ @ Vs Vy @ @ C$bool$ /\\ @ Vs Vz @ @ C$bool$ /\\ @ @ VR Vx' Vy @ @ VR Vy Vz @ @ VR Vx' Vz", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ Vs Vy @ @ C$min$ = @ @ VR Vx' Vy @ @ VR Vy Vx'", "@ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vs Vx' @ @ VR Vx' Vx'"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). \u2205 x' \u21d4 {y | (s :\u03b1 -> bool) y \u2227 (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) y} x'", "(s :\u03b1 -> bool) (x :\u03b1)", "\u2200(x' :\u03b1) (y :\u03b1) (z :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u2227 s z \u2227 (R :\u03b1 -> \u03b1 -> bool) x' y \u2227 R y z \u21d2 R x' z", "\u2200(x' :\u03b1) (y :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u21d2 ((R :\u03b1 -> \u03b1 -> bool) x' y \u21d4 R y x')", "\u2200(x' :\u03b1). (s :\u03b1 -> bool) x' \u21d2 (R :\u03b1 -> \u03b1 -> bool) x' x'"], "goal": "F"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.SPECIFICATION, pred_setTheory.POW_INSERT, pred_setTheory.UNIV_DEF, pred_setTheory.UNIV_DEF, pred_setTheory.UNION_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ C$bool$ ~ @ @ C$pred_set$ GSPEC | Vy @ @ C$pair$ , Vy @ @ C$bool$ /\\ @ Vs Vy @ @ VR Vx Vy Vx'", "@ Vs Vx", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ @ C$bool$ /\\ @ Vs Vy @ @ C$bool$ /\\ @ Vs Vz @ @ C$bool$ /\\ @ @ VR Vx' Vy @ @ VR Vy Vz @ @ VR Vx' Vz", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ Vs Vy @ @ C$min$ = @ @ VR Vx' Vy @ @ VR Vy Vx'", "@ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vs Vx' @ @ VR Vx' Vx'"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). \u00ac{y | (s :\u03b1 -> bool) y \u2227 (R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) y} x'", "(s :\u03b1 -> bool) (x :\u03b1)", "\u2200(x' :\u03b1) (y :\u03b1) (z :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u2227 s z \u2227 (R :\u03b1 -> \u03b1 -> bool) x' y \u2227 R y z \u21d2 R x' z", "\u2200(x' :\u03b1) (y :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u21d2 ((R :\u03b1 -> \u03b1 -> bool) x' y \u21d4 R y x')", "\u2200(x' :\u03b1). (s :\u03b1 -> bool) x' \u21d2 (R :\u03b1 -> \u03b1 -> bool) x' x'"], "goal": "F"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.SUM_IMAGE_SING, pred_setTheory.EMPTY_DEF, pred_setTheory.EMPTY_DEF, pred_setTheory.IN_IMAGE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx' @ @ C$bool$ \\/ @ C$bool$ ~ @ Vs Vx' @ C$bool$ ~ @ @ VR Vx Vx'", "@ Vs Vx", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ C$bool$ ! | Vz @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ @ C$bool$ /\\ @ Vs Vy @ @ C$bool$ /\\ @ Vs Vz @ @ C$bool$ /\\ @ @ VR Vx' Vy @ @ VR Vy Vz @ @ VR Vx' Vz", "@ C$bool$ ! | Vx' @ C$bool$ ! | Vy @ @ C$min$ ==> @ @ C$bool$ /\\ @ Vs Vx' @ Vs Vy @ @ C$min$ = @ @ VR Vx' Vy @ @ VR Vy Vx'", "@ C$bool$ ! | Vx' @ @ C$min$ ==> @ Vs Vx' @ @ VR Vx' Vx'"], "goal": "C$bool$ F"}, "plain": {"assumptions": ["\u2200(x' :\u03b1). \u00ac(s :\u03b1 -> bool) x' \u2228 \u00ac(R :\u03b1 -> \u03b1 -> bool) (x :\u03b1) x'", "(s :\u03b1 -> bool) (x :\u03b1)", "\u2200(x' :\u03b1) (y :\u03b1) (z :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u2227 s z \u2227 (R :\u03b1 -> \u03b1 -> bool) x' y \u2227 R y z \u21d2 R x' z", "\u2200(x' :\u03b1) (y :\u03b1). (s :\u03b1 -> bool) x' \u2227 s y \u21d2 ((R :\u03b1 -> \u03b1 -> bool) x' y \u21d4 R y x')", "\u2200(x' :\u03b1). (s :\u03b1 -> bool) x' \u21d2 (R :\u03b1 -> \u03b1 -> bool) x' x'"], "goal": "F"}}], "parent": 4, "goal": 0, "by_tactic": "fs[pred_setTheory.IN_APP, pred_setTheory.HAS_SIZE_CARD, pred_setTheory.EMPTY_DEF, pred_setTheory.GSPEC_ETA, pred_setTheory.EXTENSION]", "reward": 0.1}, {"content": [], "parent": 7, "goal": 0, "by_tactic": "metis_tac[pred_setTheory.IN_POW, pred_setTheory.POW_EQNS, pred_setTheory.SUM_SET_count_2, pred_setTheory.COMMUTING_ITSET_INSERT, pred_setTheory.SUBSET_ADD]", "reward": 5}]], "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 HD l::TL l = l": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list). \u00acNULL l \u21d2 HD l::TL l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL C$list$ NIL @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD C$list$ NIL @ C$list$ TL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u00acNULL ([] :\u03b1 list) \u21d2 HD ([] :\u03b1 list)::TL ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "\u2200(h :\u03b1). \u00acNULL (h::(l :\u03b1 list)) \u21d2 HD (h::l)::TL (h::l) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "\u2200(h :\u03b1). \u00acNULL (h::(l :\u03b1 list)) \u21d2 HD (h::l)::TL (h::l) = h::l"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD C$list$ NIL @ C$list$ TL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": ["\u00acNULL ([] :\u03b1 list)"], "goal": "HD ([] :\u03b1 list)::TL ([] :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.BOOL_EQ_DISTINCT, boolTheory.IMP_F_EQ_F, boolTheory.IMP_F_EQ_F, boolTheory.IMP_F_EQ_F, listTheory.CONS_11]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD C$list$ NIL @ C$list$ TL C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": ["\u00acNULL ([] :\u03b1 list)"], "goal": "HD ([] :\u03b1 list)::TL ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl", "@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u00acNULL ((h :\u03b1)::(l :\u03b1 list))", "\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "HD ((h :\u03b1)::(l :\u03b1 list))::TL (h::l) = h::l"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.LIST_NOT_EQ, boolTheory.EQ_REFL, listTheory.LIST_TO_SET, listTheory.LIST_TO_SET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD @ @ C$list$ CONS Vh Vl @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "\u2200(h :\u03b1). \u00acNULL (h::(l :\u03b1 list)) \u21d2 HD (h::l)::TL (h::l) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.NULL_DEF, listTheory.list_CASES, boolTheory.IMP_F_EQ_F, listTheory.MAP2, listTheory.EQ_LIST]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ C$list$ NULL @ @ C$list$ CONS Vh Vl", "@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ CONS Vh @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u00acNULL ((h :\u03b1)::(l :\u03b1 list))", "\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "(h :\u03b1)::TL (h::(l :\u03b1 list)) = h::l"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.HD, listTheory.list_size_def, listTheory.LENGTH, listTheory.MAP2_APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["C$bool$ T", "@ @ C$min$ ==> @ C$bool$ ~ @ C$list$ NULL Vl @ @ C$min$ = @ @ C$list$ CONS @ C$list$ HD Vl @ C$list$ TL Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ CONS Vh @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["T", "\u00acNULL (l :\u03b1 list) \u21d2 HD l::TL l = l"], "goal": "(h :\u03b1)::TL (h::(l :\u03b1 list)) = h::l"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.MAP, boolTheory.PULL_FORALL, listTheory.NULL, listTheory.LENGTH_MAP2, listTheory.FLAT]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, listTheory.LENGTH, listTheory.TL_DEF, boolTheory.EQ_EXT, listTheory.LENGTH]", "reward": 5}]], "LIST_BIND (l :\u03b1 list) (\u03bb(x :\u03b1). [x]) = l": [3, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_BIND Vl | Vx @ @ C$list$ CONS Vx C$list$ NIL Vl"}, "plain": {"assumptions": [], "goal": "LIST_BIND (l :\u03b1 list) (\u03bb(x :\u03b1). [x]) = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ LIST_BIND C$list$ NIL | Vx @ @ C$list$ CONS Vx C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LIST_BIND ([] :\u03b1 list) (\u03bb(x :\u03b1). [x]) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ LIST_BIND Vl | Vx @ @ C$list$ CONS Vx C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ LIST_BIND @ @ C$list$ CONS Vh Vl | Vx @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LIST_BIND (l :\u03b1 list) (\u03bb(x :\u03b1). [x]) = l"], "goal": "\u2200(h :\u03b1). LIST_BIND (h::(l :\u03b1 list)) (\u03bb(x :\u03b1). [x]) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$list$ LIST_BIND Vl | Vx @ @ C$list$ CONS Vx C$list$ NIL Vl"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$list$ LIST_BIND @ @ C$list$ CONS Vh Vl | Vx @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["LIST_BIND (l :\u03b1 list) (\u03bb(x :\u03b1). [x]) = l"], "goal": "\u2200(h :\u03b1). LIST_BIND (h::(l :\u03b1 list)) (\u03bb(x :\u03b1). [x]) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.LIST_BIND_THM, listTheory.TAKE_def, listTheory.UNZIP, listTheory.SET_TO_LIST_THM, listTheory.isPREFIX_THM]", "reward": 0.2}, {"content": [], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.LIST_BIND_THM, listTheory.LIST_REL_SPLIT1, listTheory.LENGTH, listTheory.FRONT_CONS, listTheory.APPEND]", "reward": 5}]], "\u2200(l :\u03b1 list) (x :\u03b1). MEM x (TL l) \u21d2 MEM x l": [5, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (x :\u03b1). MEM x (TL l) \u21d2 MEM x l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL C$list$ NIL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). MEM x (TL ([] :\u03b1 list)) \u21d2 MEM x ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (TL (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). MEM x (TL (h::(l :\u03b1 list))) \u21d2 MEM x (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (TL (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). MEM x (TL (h::(l :\u03b1 list))) \u21d2 MEM x (h::l)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.TL_DEF, listTheory.MAP_EQ_f, listTheory.MAP_MAP_o, listTheory.list_size_def, listTheory.MAP_ID]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["MEM (x :\u03b1) (TL ((h :\u03b1)::(l :\u03b1 list)))", "\u2200(x :\u03b1). MEM x (TL (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "MEM (x :\u03b1) ((h :\u03b1)::(l :\u03b1 list))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, boolTheory.PULL_EXISTS, boolTheory.F_IMP, listTheory.FLAT, boolTheory.FUN_EQ_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL @ @ C$list$ CONS Vh Vl", "@ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ TL Vl @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vx Vh @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["MEM (x :\u03b1) (TL ((h :\u03b1)::(l :\u03b1 list)))", "\u2200(x :\u03b1). MEM x (TL (l :\u03b1 list)) \u21d2 MEM x l"], "goal": "(x :\u03b1) = (h :\u03b1) \u2228 MEM x (l :\u03b1 list)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, boolTheory.DATATYPE_TAG_THM, listTheory.HD, listTheory.LIST_TO_SET, listTheory.SUM]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.APPEND_ASSOC, listTheory.TL_DEF, listTheory.APPEND_NIL, listTheory.MAP_TL]", "reward": 5}]], "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f l) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f l) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf C$list$ NIL @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f ([] :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (h::(l :\u03b1 list))) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (h::(l :\u03b1 list))) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y (h::l)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf C$list$ NIL @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b2) (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.IMP_DISJ_THM, listTheory.TL, listTheory.TL_DEF, listTheory.MAP_EQ_NIL, listTheory.APPEND_ASSOC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf C$list$ NIL @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b2) (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx @ Vf Vh @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vh @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"], "goal": "(x :\u03b2) = (f :\u03b1 -> \u03b2) (h :\u03b1) \u2228 (\u2203(y :\u03b1). x = f y \u2227 MEM y (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 (y = h \u2228 MEM y l)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LIST_TO_SET, boolTheory.PULL_FORALL, listTheory.MAP, listTheory.FLAT, listTheory.LENGTH]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx @ Vf Vh @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vh @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"], "goal": "(x :\u03b2) = (f :\u03b1 -> \u03b2) (h :\u03b1) \u2228 (\u2203(y :\u03b1). x = f y \u2227 MEM y (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 (y = h \u2228 MEM y l)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET C$list$ NIL @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b2) ([] :\u03b2 list) \u21d4 \u2203(y :\u03b1). x = (f :\u03b1 -> \u03b2) y \u2227 MEM y ([] :\u03b1 list)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.EXISTS_DEF, boolTheory.IMP_F_EQ_F, listTheory.LENGTH, listTheory.MAP, listTheory.list_distinct]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ MAP Vf Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Vx @ Vf Vh @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl @ C$bool$ ? | Vy @ @ C$bool$ /\\ @ @ C$min$ = Vx @ Vf Vy @ @ C$bool$ \\/ @ @ C$min$ = Vy Vh @ @ C$bool$ IN Vy @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (x :\u03b2). MEM x (MAP f (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 MEM y l"], "goal": "(x :\u03b2) = (f :\u03b1 -> \u03b2) (h :\u03b1) \u2228 (\u2203(y :\u03b1). x = f y \u2227 MEM y (l :\u03b1 list)) \u21d4 \u2203(y :\u03b1). x = f y \u2227 (y = h \u2228 MEM y l)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.MAP, listTheory.LIST_TO_SET, listTheory.TL_DEF, listTheory.MAP2_NIL, listTheory.TL_DEF]", "reward": 0.2}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.TL_DEF, listTheory.LENGTH, listTheory.LIST_TO_SET_DEF, listTheory.MEM_FILTER, boolTheory.EQ_EXT]", "reward": 5}]], "\u2200(a :\u03b1 list) (b :\u03b2 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH b \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d)": [13, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (b :\u03b2 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH b \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) ++ ZIP (c,d) = ZIP (a ++ c,b ++ d)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vb @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (b :\u03b2 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH b \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"}}], "parent": 0, "goal": 0, "by_tactic": "fs[listTheory.EL_ALL_DISTINCT_EL_EQ, listTheory.LENGTH_UNZIP, listTheory.LIST_TO_SET_SNOC, listTheory.LIST_REL_def, listTheory.MEM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va C$list$ NIL @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND C$list$ NIL Vd"}, "plain": {"assumptions": [], "goal": "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH ([] :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,([] :\u03b2 list)) \u29fa ZIP (c,d) = ZIP (a \u29fa c,([] :\u03b2 list) \u29fa d)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH @ @ C$list$ CONS Vh Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vd"}, "plain": {"assumptions": ["\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "\u2200(h :\u03b2) (a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (h::(b :\u03b2 list)) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,h::b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,h::b \u29fa d)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `b`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH @ @ C$list$ CONS Vh Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vb Vd"}, "plain": {"assumptions": ["\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "\u2200(h :\u03b2) (a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (h::(b :\u03b2 list)) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,h::b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,h::b \u29fa d)"}}], "parent": 2, "goal": 0, "by_tactic": "rw[pairTheory.UNCURRY_VAR, listTheory.LUPDATE_SOME_MAP, listTheory.FILTER_F, listTheory.EVERY2_LUPDATE_same, listTheory.ZIP_EQ_NIL]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd", "@ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH @ @ C$list$ CONS Vh Vb", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": ["LENGTH (c :\u03b1 list) = LENGTH (d :\u03b2 list)", "LENGTH (a :\u03b1 list) = LENGTH ((h :\u03b2)::(b :\u03b2 list))", "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "ZIP ((a :\u03b1 list),(h :\u03b2)::(b :\u03b2 list)) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (a \u29fa c,h::(b \u29fa d))"}}], "parent": 3, "goal": 0, "by_tactic": "rw[pairTheory.CLOSED_PAIR_EQ, pairTheory.ELIM_PEXISTS, listTheory.TAKE_DROP, listTheory.MAP_EQ_NIL, pairTheory.UNCURRY_VAR]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd", "@ @ C$min$ = @ C$list$ LENGTH Va @ C$num$ SUC @ C$list$ LENGTH Vb", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": ["LENGTH (c :\u03b1 list) = LENGTH (d :\u03b2 list)", "LENGTH (a :\u03b1 list) = SUC (LENGTH (b :\u03b2 list))", "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "ZIP ((a :\u03b1 list),(h :\u03b2)::(b :\u03b2 list)) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (a \u29fa c,h::(b \u29fa d))"}}], "parent": 4, "goal": 0, "by_tactic": "fs[boolTheory.EQ_IMP_THM, listTheory.nub_def, listTheory.HD_GENLIST, listTheory.OPT_MMAP_def, listTheory.FOLDL2_FOLDL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH C$list$ NIL @ C$num$ SUC @ C$list$ LENGTH Vb @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , C$list$ NIL @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND C$list$ NIL Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": ["LENGTH (c :\u03b1 list) = LENGTH (d :\u03b2 list)", "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "LENGTH ([] :\u03b1 list) = SUC (LENGTH (b :\u03b2 list)) \u21d2 ZIP (([] :\u03b1 list),(h :\u03b2)::b) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (([] :\u03b1 list) \u29fa c,h::(b \u29fa d))"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Va @ C$num$ SUC @ C$list$ LENGTH Vb @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd", "@ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh' Va @ C$num$ SUC @ C$list$ LENGTH Vb @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh' Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": ["LENGTH (a :\u03b1 list) = SUC (LENGTH (b :\u03b2 list)) \u21d2 ZIP (a,(h :\u03b2)::b) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (a \u29fa c,h::(b \u29fa d))", "LENGTH (c :\u03b1 list) = LENGTH (d :\u03b2 list)", "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "\u2200(h' :\u03b1). LENGTH (h'::(a :\u03b1 list)) = SUC (LENGTH (b :\u03b2 list)) \u21d2 ZIP (h'::a,(h :\u03b2)::b) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (h'::a \u29fa c,h::(b \u29fa d))"}}], "parent": 5, "goal": 0, "by_tactic": "Induct_on `a`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH Va @ C$num$ SUC @ C$list$ LENGTH Vb @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd", "@ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd", "@ C$bool$ ! | Va @ C$bool$ ! | Vc @ C$bool$ ! | Vd @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH Vb @ @ C$min$ = @ C$list$ LENGTH Vc @ C$list$ LENGTH Vd @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , Va Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND Va Vc @ @ C$list$ APPEND Vb Vd"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS Vh' Va @ C$num$ SUC @ C$list$ LENGTH Vb @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ CONS Vh' Va @ @ C$list$ CONS Vh Vb @ C$list$ ZIP @ @ C$pair$ , Vc Vd @ C$list$ ZIP @ @ C$pair$ , @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Va Vc @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vb Vd"}, "plain": {"assumptions": ["LENGTH (a :\u03b1 list) = SUC (LENGTH (b :\u03b2 list)) \u21d2 ZIP (a,(h :\u03b2)::b) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (a \u29fa c,h::(b \u29fa d))", "LENGTH (c :\u03b1 list) = LENGTH (d :\u03b2 list)", "\u2200(a :\u03b1 list) (c :\u03b1 list) (d :\u03b2 list). LENGTH a = LENGTH (b :\u03b2 list) \u2227 LENGTH c = LENGTH d \u21d2 ZIP (a,b) \u29fa ZIP (c,d) = ZIP (a \u29fa c,b \u29fa d)"], "goal": "\u2200(h' :\u03b1). LENGTH (h'::(a :\u03b1 list)) = SUC (LENGTH (b :\u03b2 list)) \u21d2 ZIP (h'::a,(h :\u03b2)::b) \u29fa ZIP ((c :\u03b1 list),(d :\u03b2 list)) = ZIP (h'::a \u29fa c,h::(b \u29fa d))"}}], "parent": 6, "goal": 0, "by_tactic": "fs[listTheory.CONS_11, listTheory.ALL_DISTINCT_EL_IMP, listTheory.splitAtPki_EQN, listTheory.SUM_MAP_PLUS_ZIP, listTheory.LENGTH]", "reward": 0.2}, {"content": [], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.ALL_DISTINCT_EL_IMP, listTheory.APPEND_EQ_APPEND, listTheory.FLAT_compute, listTheory.ZIP_def, listTheory.SUM_ACC_DEF]", "reward": 5}]], "\u2200(e :\u03b1) (l1 :\u03b1 list) (l2 :\u03b1 list). MEM e (l1 ++ l2) \u21d4 MEM e l1 \u2228 MEM e l2": [22, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l1 :\u03b1 list) (l2 :\u03b1 list). MEM e (l1 ++ l2) \u21d4 MEM e l1 \u2228 MEM e l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l1 :\u03b1 list) (l2 :\u03b1 list). MEM e (l1 \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"}}], "parent": 0, "goal": 0, "by_tactic": "simp[boolTheory.DISJ_COMM, listTheory.LIST_TO_SET, listTheory.EXISTS_NOT_EVERY, listTheory.EXISTS_NOT_EVERY, listTheory.FLAT]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (([] :\u03b1 list) \u29fa l2) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (l2 :\u03b1 list). MEM e (h::(l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e (h::l1) \u2228 MEM e l2"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (l2 :\u03b1 list). MEM e (h::(l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e (h::l1) \u2228 MEM e l2"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa ([] :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1). MEM e (([] :\u03b1 list) \u29fa h::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l2`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa ([] :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1). MEM e (([] :\u03b1 list) \u29fa h::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.SUM, listTheory.MAP_MAP_o, listTheory.LIST_TO_SET, listTheory.FLAT, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1). MEM e (([] :\u03b1 list) \u29fa h::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ~ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1). \u00acMEM e (([] :\u03b1 list) \u29fa ([] :\u03b1 list))"}}], "parent": 4, "goal": 0, "by_tactic": "simp[boolTheory.DISJ_EQ_IMP, listTheory.LIST_TO_SET, listTheory.EVERY_MEM, listTheory.LENGTH_APPEND, listTheory.EVERY_MEM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa ([] :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1). MEM e (([] :\u03b1 list) \u29fa h::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "MEM (e :\u03b1) ((h :\u03b1)::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_TO_SET, listTheory.MAP_MAP_o, listTheory.LIST_TO_SET, listTheory.MAP_TL, listTheory.EL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "\u2200(h :\u03b1) (e :\u03b1). MEM e (([] :\u03b1 list) \u29fa h::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.TL_DEF, boolTheory.itself_case_thm, boolTheory.IMP_DISJ_THM, listTheory.APPEND, listTheory.SUM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "MEM (e :\u03b1) (([] :\u03b1 list) \u29fa (h :\u03b1)::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.LENGTH, listTheory.MAP2, listTheory.MAP, listTheory.LENGTH, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (([] :\u03b1 list) \u29fa (l2 :\u03b1 list)) \u21d4 MEM e l2"], "goal": "MEM (e :\u03b1) (([] :\u03b1 list) \u29fa (h :\u03b1)::(l2 :\u03b1 list)) \u21d4 e = h \u2228 MEM e l2"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.MAP2, listTheory.LIST_TO_SET, listTheory.EXISTS_DEF, listTheory.LENGTH]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2"], "goal": "(e :\u03b1) = (h :\u03b1) \u2228 MEM e (l1 :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (l2 :\u03b1 list) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "MEM (e :\u03b1) ((h :\u03b1)::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.LENGTH, boolTheory.PULL_EXISTS, listTheory.MAP, listTheory.LENGTH, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["\u2200(e :\u03b1). MEM e (l2 :\u03b1 list) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2"], "goal": "MEM (e :\u03b1) ((h :\u03b1)::(l2 :\u03b1 list)) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e (h::l2)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "(\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (([] :\u03b1 list) \u29fa l2) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e ([] :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e ([] :\u03b1 list)) \u2228 MEM e l2)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["(\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e l1 \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2)"], "goal": "\u2200(h' :\u03b1). (\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (h'::(l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e (h'::l1) \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e (h'::l1) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e (h'::l1)) \u2228 MEM e l2)"}}], "parent": 10, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": [], "goal": "(\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (([] :\u03b1 list) \u29fa l2) \u21d4 MEM e ([] :\u03b1 list) \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e ([] :\u03b1 list) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e ([] :\u03b1 list)) \u2228 MEM e l2)"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["(\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e l1 \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2)"], "goal": "\u2200(h' :\u03b1). (\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (h'::(l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e (h'::l1) \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e (h'::l1) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e (h'::l1)) \u2228 MEM e l2)"}}], "parent": 11, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.INDEX_FIND_def, listTheory.LIST_TO_SET, listTheory.SUM, listTheory.SUM]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ C$bool$ ! | Ve @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Vl1 Vl2 @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$min$ = @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ \\/ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2 @ @ C$bool$ \\/ @ @ C$bool$ \\/ @ @ C$min$ = Ve Vh @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh' Vl1 @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl2"}, "plain": {"assumptions": ["(\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e ((l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e l1 \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e l1 \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e l1) \u2228 MEM e l2)"], "goal": "\u2200(h' :\u03b1). (\u2200(e :\u03b1) (l2 :\u03b1 list). MEM e (h'::(l1 :\u03b1 list) \u29fa l2) \u21d4 MEM e (h'::l1) \u2228 MEM e l2) \u21d2 ((e :\u03b1) = (h :\u03b1) \u2228 MEM e (h'::l1) \u2228 MEM e (l2 :\u03b1 list) \u21d4 (e = h \u2228 MEM e (h'::l1)) \u2228 MEM e l2)"}}], "parent": 12, "goal": 0, "by_tactic": "fs[listTheory.LIST_TO_SET, listTheory.TL_DEF, listTheory.LIST_TO_SET, listTheory.MAP_TL, listTheory.EL]", "reward": 0.2}, {"content": [], "parent": 13, "goal": 0, "by_tactic": "metis_tac[boolTheory.LEFT_OR_CONG, listTheory.MEM_TL, listTheory.EVERY_MEM, listTheory.SUM, listTheory.EXISTS_MEM]", "reward": 5}]], "\u2200(P :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list) (v1 :\u03b1) (v2 :\u03b2) (n :num). P v1 v2 \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | VP @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ C$bool$ ! | Vv1 @ C$bool$ ! | Vv2 @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ VP Vv1 Vv2 @ @ @ C$list$ LIST_REL VP Vl1 Vl2 @ @ @ C$list$ LIST_REL VP @ @ @ C$list$ LUPDATE Vv1 Vn Vl1 @ @ @ C$list$ LUPDATE Vv2 Vn Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(P :\u03b1 -> \u03b2 -> bool) (l1 :\u03b1 list) (l2 :\u03b2 list) (v1 :\u03b1) (v2 :\u03b2) (n :num). P v1 v2 \u2227 LIST_REL P l1 l2 \u21d2 LIST_REL P (LUPDATE v1 n l1) (LUPDATE v2 n l2)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": ["@ @ C$prim_rec$ < Vn' @ C$list$ LENGTH Vl2", "@ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$prim_rec$ < Vn @ C$list$ LENGTH Vl1 @ @ VP @ @ C$list$ EL Vn Vl1 @ @ C$list$ EL Vn Vl2", "@ @ C$min$ = @ C$list$ LENGTH Vl1 @ C$list$ LENGTH Vl2", "@ @ VP Vv1 Vv2"], "goal": "@ @ VP @ @ @ C$bool$ COND @ @ C$min$ = Vn' Vn Vv1 @ @ C$list$ EL Vn' Vl1 @ @ @ C$bool$ COND @ @ C$min$ = Vn' Vn Vv2 @ @ C$list$ EL Vn' Vl2"}, "plain": {"assumptions": ["(n' :num) < LENGTH (l2 :\u03b2 list)", "\u2200(n :num). n < LENGTH (l1 :\u03b1 list) \u21d2 (P :\u03b1 -> \u03b2 -> bool) (EL n l1) (EL n (l2 :\u03b2 list))", "LENGTH (l1 :\u03b1 list) = LENGTH (l2 :\u03b2 list)", "(P :\u03b1 -> \u03b2 -> bool) (v1 :\u03b1) (v2 :\u03b2)"], "goal": "(P :\u03b1 -> \u03b2 -> bool) (if (n' :num) = (n :num) then (v1 :\u03b1) else EL n' (l1 :\u03b1 list)) (if n' = n then (v2 :\u03b2) else EL n' (l2 :\u03b2 list))"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LIST_REL_EL_EQN, listTheory.GENLIST, listTheory.LIST_REL_SPLIT1, listTheory.LIST_REL_NIL, listTheory.LUPDATE_SEM]", "reward": 0.1}, {"content": [], "parent": 1, "goal": 0, "by_tactic": "metis_tac[listTheory.REV_DEF, listTheory.nub_NIL, listTheory.isPREFIX, listTheory.isPREFIX, listTheory.LIST_REL_rules]", "reward": 5}]], "\u2200(x :\u03b1) (L :\u03b1 list list). MEM x (FLAT L) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l": [33, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | VL @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (L :\u03b1 list list). MEM x (FLAT L) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b1) (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.EQ_SYM_EQ, listTheory.list_CASES, boolTheory.FORALL_itself, listTheory.list_Axiom_old, boolTheory.IMP_CONG]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT C$list$ NIL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). MEM x (FLAT ([] :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l ([] :\u03b1 list list) \u2227 MEM x l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "\u2200(h :\u03b1 list) (x :\u03b1). MEM x (FLAT (h::(L :\u03b1 list list))) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `L`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "\u2200(h :\u03b1 list) (x :\u03b1). MEM x (FLAT (h::(L :\u03b1 list list))) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT C$list$ NIL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b1) (FLAT ([] :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l ([] :\u03b1 list list) \u2227 MEM x l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[boolTheory.DISJ_EQ_IMP, boolTheory.IMP_DISJ_THM, listTheory.MAP2_NIL, listTheory.list_Axiom, listTheory.EQ_LIST]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT C$list$ NIL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET C$list$ NIL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": [], "goal": "MEM (x :\u03b1) (FLAT ([] :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l ([] :\u03b1 list list) \u2227 MEM x l"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "MEM (x :\u03b1) (FLAT ((h :\u03b1 list)::(L :\u03b1 list list))) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}], "parent": 3, "goal": 0, "by_tactic": "fs[boolTheory.RES_EXISTS_DEF, listTheory.MAP_MAP_o, listTheory.SUM, listTheory.MAP_MAP_o, listTheory.list_case_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "\u2200(h :\u03b1 list) (x :\u03b1). MEM x (FLAT (h::(L :\u03b1 list list))) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}], "parent": 2, "goal": 0, "by_tactic": "simp[boolTheory.EQ_SYM_EQ, listTheory.LIST_TO_SET, listTheory.MEM_FILTER, listTheory.EVERY_NOT_EXISTS, listTheory.FLAT]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "MEM (x :\u03b1) (FLAT ((h :\u03b1 list)::(L :\u03b1 list list))) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.LENGTH, listTheory.EL, listTheory.list_CASES, listTheory.EL, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$min$ = @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ APPEND Vh @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l L \u2227 MEM x l"], "goal": "MEM (x :\u03b1) ((h :\u03b1 list) \u29fa FLAT (L :\u03b1 list list)) \u21d4 \u2203(l :\u03b1 list). MEM l (h::L) \u2227 MEM x l"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.MAP_MAP_o, listTheory.NULL, listTheory.FLAT, listTheory.SUM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT VL @ C$bool$ ! | Vl @ @ C$bool$ \\/ @ C$bool$ ~ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"], "goal": "@ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ? | Vl @ @ C$bool$ /\\ @ @ C$bool$ \\/ @ @ C$min$ = Vl Vh @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ C$list$ FLAT @ @ C$list$ CONS Vh VL @ C$bool$ ! | Vl @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ C$bool$ ~ @ @ C$min$ = Vl Vh @ C$bool$ ~ @ @ C$bool$ IN Vl @ C$list$ LIST_TO_SET VL @ C$bool$ ~ @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). MEM x (FLAT (L :\u03b1 list list)) \u2227 (\u2203(l :\u03b1 list). MEM l L \u2227 MEM x l) \u2228 \u00acMEM x (FLAT L) \u2227 \u2200(l :\u03b1 list). \u00acMEM l L \u2228 \u00acMEM x l"], "goal": "MEM (x :\u03b1) (FLAT ((h :\u03b1 list)::(L :\u03b1 list list))) \u2227 (\u2203(l :\u03b1 list). (l = h \u2228 MEM l L) \u2227 MEM x l) \u2228 \u00acMEM x (FLAT (h::L)) \u2227 \u2200(l :\u03b1 list). l \u2260 h \u2227 \u00acMEM l L \u2228 \u00acMEM x l"}}], "parent": 5, "goal": 0, "by_tactic": "fs[boolTheory.EQ_EXPAND, listTheory.EVERY_SIMP, listTheory.LIST_TO_SET, listTheory.LENGTH, listTheory.LENGTH]", "reward": 0.1}, {"content": [], "parent": 8, "goal": 0, "by_tactic": "metis_tac[boolTheory.LEFT_EXISTS_AND_THM, listTheory.MEM_FILTER, listTheory.LIST_TO_SET, listTheory.MEM_APPEND, listTheory.FLAT]", "reward": 5}]], "\u2200(l1 :\u03b1 list list) (l2 :\u03b1 list list). FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2": [16, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l1 :\u03b1 list list) (l2 :\u03b1 list list). FLAT (l1 ++ l2) = FLAT l1 ++ FLAT l2"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list list). FLAT (([] :\u03b1 list list) \u29fa l2) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list) (l2 :\u03b1 list list). FLAT (h::(l1 :\u03b1 list list) \u29fa l2) = FLAT (h::l1) \u29fa FLAT l2"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list) (l2 :\u03b1 list list). FLAT (h::(l1 :\u03b1 list list) \u29fa l2) = FLAT (h::l1) \u29fa FLAT l2"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FLAT (([] :\u03b1 list list) \u29fa ([] :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT ([] :\u03b1 list list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list). FLAT (([] :\u03b1 list list) \u29fa h::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}], "parent": 1, "goal": 0, "by_tactic": "Induct_on `l2`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FLAT (([] :\u03b1 list list) \u29fa ([] :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT ([] :\u03b1 list list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list). FLAT (([] :\u03b1 list list) \u29fa h::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ ==> @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh C$list$ NIL @ C$list$ FLAT Vl2"}, "plain": {"assumptions": [], "goal": "(\u2200(l2 :\u03b1 list list). FLAT (([] :\u03b1 list list) \u29fa l2) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2) \u21d2 FLAT ([(h :\u03b1 list)] \u29fa (l2 :\u03b1 list list)) = FLAT [h] \u29fa FLAT l2"}}, {"polished": {"assumptions": ["@ @ C$min$ ==> @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh' @ @ C$min$ ==> @ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh' Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh' Vl1 @ C$list$ FLAT Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh @ @ C$list$ CONS Vh' Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["(\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2) \u21d2 FLAT ((h :\u03b1 list)::l1 \u29fa (l2 :\u03b1 list list)) = FLAT (h::l1) \u29fa FLAT l2"], "goal": "\u2200(h' :\u03b1 list). (\u2200(l2 :\u03b1 list list). FLAT (h'::(l1 :\u03b1 list list) \u29fa l2) = FLAT (h'::l1) \u29fa FLAT l2) \u21d2 FLAT ((h :\u03b1 list)::h'::l1 \u29fa (l2 :\u03b1 list list)) = FLAT (h::h'::l1) \u29fa FLAT l2"}}], "parent": 2, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL C$list$ NIL @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT C$list$ NIL"}, "plain": {"assumptions": [], "goal": "FLAT (([] :\u03b1 list list) \u29fa ([] :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT ([] :\u03b1 list list)"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list). FLAT (([] :\u03b1 list list) \u29fa h::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT (h::l1) \u29fa FLAT l2"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.MAP_MAP_o, listTheory.MAP2_APPEND, boolTheory.AND_CLAUSES, listTheory.MAP2_APPEND, listTheory.LIST_TO_SET_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "\u2200(h :\u03b1 list). FLAT (([] :\u03b1 list list) \u29fa h::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT (h::l1) \u29fa FLAT l2"}}], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.TL_DEF, listTheory.FLAT, listTheory.APPEND, listTheory.MAP, listTheory.MAP2_APPEND]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT (h::l1) \u29fa FLAT l2"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "FLAT (([] :\u03b1 list list) \u29fa (h :\u03b1 list)::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}], "parent": 5, "goal": 0, "by_tactic": "fs[boolTheory.LET_CONG, listTheory.list_size_def, listTheory.list_size_def, listTheory.list_size_def, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT (h::l1) \u29fa FLAT l2"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.LIST_TO_SET_DEF, listTheory.EL_MAP2, listTheory.FLAT, boolTheory.LET_CONG, listTheory.APPEND]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ APPEND Vh @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = h \u29fa FLAT l1 \u29fa FLAT l2"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.MEM_APPEND, listTheory.MAP_MAP_o, listTheory.MAP, listTheory.FLAT, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vh Vl2 @ @ C$list$ APPEND @ C$list$ FLAT C$list$ NIL @ C$list$ FLAT @ @ C$list$ CONS Vh Vl2"}, "plain": {"assumptions": ["FLAT (([] :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT l2"], "goal": "FLAT (([] :\u03b1 list list) \u29fa (h :\u03b1 list)::(l2 :\u03b1 list list)) = FLAT ([] :\u03b1 list list) \u29fa FLAT (h::l2)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ APPEND @ @ C$list$ APPEND Vh @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::(l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list)) = h \u29fa FLAT l1 \u29fa FLAT l2"}}], "parent": 6, "goal": 0, "by_tactic": "simp[listTheory.MAP, listTheory.EXISTS_NOT_EVERY, listTheory.NOT_CONS_NIL, listTheory.FLAT, listTheory.INDEX_OF_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ C$list$ FLAT @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT @ @ C$list$ CONS Vh Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "FLAT ((h :\u03b1 list)::((l1 :\u03b1 list list) \u29fa (l2 :\u03b1 list list))) = FLAT (h::l1) \u29fa FLAT l2"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.FOLDL, listTheory.MAP_EQ_f, listTheory.MAP, listTheory.APPEND, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl2 @ @ C$min$ = @ C$list$ FLAT @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND Vh @ @ C$list$ APPEND @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2 @ @ C$list$ APPEND @ @ C$list$ APPEND Vh @ C$list$ FLAT Vl1 @ C$list$ FLAT Vl2"}, "plain": {"assumptions": ["\u2200(l2 :\u03b1 list list). FLAT ((l1 :\u03b1 list list) \u29fa l2) = FLAT l1 \u29fa FLAT l2"], "goal": "(h :\u03b1 list) \u29fa (FLAT (l1 :\u03b1 list list) \u29fa FLAT (l2 :\u03b1 list list)) = h \u29fa FLAT l1 \u29fa FLAT l2"}}], "parent": 7, "goal": 0, "by_tactic": "simp[listTheory.EVERY_DEF, listTheory.MEM_FLAT, listTheory.EXISTS_NOT_EVERY, listTheory.APPEND, listTheory.FLAT]", "reward": 0.1}, {"content": [], "parent": 11, "goal": 0, "by_tactic": "fs[listTheory.FOLDR, listTheory.APPEND_ASSOC, listTheory.list_size_def, listTheory.LIST_TO_SET, listTheory.list_size_def]", "reward": 5}]], "(\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l1 \u21d4 l2 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l2 \u21d4 l1 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l1 ++ l2 \u21d4 l2 = ([] :\u03b1 list)) \u2227 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 = l1 ++ l2 \u21d4 l1 = ([] :\u03b1 list)": [1, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 Vl1 @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 Vl2 @ @ C$min$ = Vl1 C$list$ NIL @ @ C$bool$ /\\ @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl1 Vl2 @ @ C$min$ = Vl2 C$list$ NIL @ C$bool$ ! | Vl1 @ C$bool$ ! | Vl2 @ @ C$min$ = @ @ C$min$ = Vl2 @ @ C$list$ APPEND Vl1 Vl2 @ @ C$min$ = Vl1 C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l1 \u21d4 l2 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 ++ l2 = l2 \u21d4 l1 = ([] :\u03b1 list)) \u2227 (\u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l1 = l1 ++ l2 \u21d4 l2 = ([] :\u03b1 list)) \u2227 \u2200(l1 :\u03b1 list) (l2 :\u03b1 list). l2 = l1 ++ l2 \u21d4 l1 = ([] :\u03b1 list)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [], "parent": 0, "goal": 0, "by_tactic": "metis_tac[listTheory.APPEND_11, listTheory.TL_DEF, listTheory.APPEND_NIL, listTheory.APPEND_eq_NIL, listTheory.APPEND]", "reward": 5}]], "\u2200(l :\u03b1 list) (i :num). MAP (f :\u03b1 -> \u03b2) (DROP i l) = DROP i (MAP f l)": [8, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (i :num). MAP (f :\u03b1 -> \u03b2) (DROP i l) = DROP i (MAP f l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi C$list$ NIL @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i ([] :\u03b1 list)) = DROP i (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "\u2200(h :\u03b1) (i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (h::(l :\u03b1 list))) = DROP i (MAP f (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "\u2200(h :\u03b1) (i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (h::(l :\u03b1 list))) = DROP i (MAP f (h::l))"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi C$list$ NIL @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ([] :\u03b1 list)) = DROP i (MAP f ([] :\u03b1 list))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, boolTheory.CONJ_ASSOC, listTheory.LENGTH, listTheory.TL_DEF, listTheory.NOT_CONS_NIL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi C$list$ NIL @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ([] :\u03b1 list)) = DROP i (MAP f ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vi @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ((h :\u03b1)::(l :\u03b1 list))) = DROP i (f h::MAP f l)"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.UNZIP, listTheory.LIST_TO_SET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vi @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ((h :\u03b1)::(l :\u03b1 list))) = DROP i (f h::MAP f l)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi C$list$ NIL @ @ C$list$ DROP Vi C$list$ NIL"}, "plain": {"assumptions": [], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ([] :\u03b1 list)) = DROP i ([] :\u03b2 list)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.MAP, listTheory.SING_HD, listTheory.LENGTH, listTheory.LIST_REL_rules, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vi @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "MAP (f :\u03b1 -> \u03b2) (DROP (i :num) ((h :\u03b1)::(l :\u03b1 list))) = DROP i (f h::MAP f l)"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.FLAT_compute, listTheory.MAP, listTheory.DROP_def, listTheory.ZIP_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vi @ @ C$min$ = @ @ C$list$ MAP Vf @ @ C$list$ DROP Vi Vl @ @ C$list$ DROP Vi @ @ C$list$ MAP Vf Vl"], "goal": "@ @ C$min$ = @ @ C$list$ MAP Vf @ @ @ C$bool$ COND @ @ C$min$ = Vi C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vi @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ @ C$bool$ COND @ @ C$min$ = Vi C$num$ 0 @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vi @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO @ @ C$list$ MAP Vf Vl"}, "plain": {"assumptions": ["\u2200(i :num). MAP (f :\u03b1 -> \u03b2) (DROP i (l :\u03b1 list)) = DROP i (MAP f l)"], "goal": "MAP (f :\u03b1 -> \u03b2) (if (i :num) = (0 :num) then (h :\u03b1)::(l :\u03b1 list) else DROP (i \u2212 (1 :num)) l) = if i = (0 :num) then f h::MAP f l else DROP (i \u2212 (1 :num)) (MAP f l)"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.FOLDL, listTheory.DROP_def, listTheory.TAKE_def, listTheory.MAP, listTheory.SUM]", "reward": 0.1}, {"content": [], "parent": 6, "goal": 0, "by_tactic": "rw[listTheory.DROP_LENGTH_TOO_LONG, listTheory.LIST_REL_SPLIT1, listTheory.LIST_NOT_EQ, listTheory.MAP, listTheory.LENGTH]", "reward": 5}]], "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). IS_SUFFIX (REVERSE l1) (REVERSE l2) \u21d4 l2 \u227c l1": [20, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl2 @ C$bool$ ! | Vl1 @ @ C$min$ = @ @ C$rich_list$ IS_SUFFIX @ C$list$ REVERSE Vl1 @ C$list$ REVERSE Vl2 @ @ C$list$ isPREFIX Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "\u2200(l2 :\u03b1 list) (l1 :\u03b1 list). IS_SUFFIX (REVERSE l1) (REVERSE l2) \u21d4 l2 \u227c l1"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$rich_list$ IS_SUFFIX @ C$list$ REVERSE Vl1 @ C$list$ REVERSE Vl2 @ @ C$list$ isPREFIX Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "IS_SUFFIX (REVERSE (l1 :\u03b1 list)) (REVERSE (l2 :\u03b1 list)) \u21d4 l2 \u227c l1"}}], "parent": 0, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_MAP2, rich_listTheory.MEM_EXISTS, rich_listTheory.LASTN_def, boolTheory.ABS_REP_THM, listTheory.LENGTH_ZIP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ @ C$min$ = @ C$list$ REVERSE Vl1 @ @ C$list$ APPEND Vl @ C$list$ REVERSE Vl2 @ @ C$list$ isPREFIX Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). REVERSE (l1 :\u03b1 list) = l \u29fa REVERSE (l2 :\u03b1 list)) \u21d4 l2 \u227c l1"}}], "parent": 0, "goal": 0, "by_tactic": "rw[rich_listTheory.IS_SUFFIX_CONS, rich_listTheory.IS_SUFFIX_APPEND, listTheory.APPEND_EQ_APPEND, listTheory.LENGTH_EQ_NUM, boolTheory.RIGHT_OR_EXISTS_THM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 @ C$list$ REVERSE Vl @ @ C$list$ isPREFIX Vl2 Vl1"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). (l1 :\u03b1 list) = (l2 :\u03b1 list) \u29fa REVERSE l) \u21d4 l2 \u227c l1"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.list_CASES, listTheory.DROP_LENGTH_TOO_LONG, listTheory.LAST_DEF, listTheory.SWAP_REVERSE_SYM, listTheory.REV_REVERSE_LEM]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 @ C$list$ REVERSE Vl @ C$bool$ ? | Vl @ @ C$min$ = Vl1 @ @ C$list$ APPEND Vl2 Vl"}, "plain": {"assumptions": [], "goal": "(\u2203(l :\u03b1 list). (l1 :\u03b1 list) = (l2 :\u03b1 list) \u29fa REVERSE l) \u21d4 \u2203(l :\u03b1 list). l1 = l2 \u29fa l"}}], "parent": 3, "goal": 0, "by_tactic": "rw[listTheory.LIST_BIND_MAP, rich_listTheory.IS_PREFIX_APPEND, listTheory.EXISTS_MAP, listTheory.EXISTS_MEM, listTheory.EVERY_SNOC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vl' @ @ C$min$ = @ @ C$list$ APPEND Vl2 @ C$list$ REVERSE Vl @ @ C$list$ APPEND Vl2 Vl'"}, "plain": {"assumptions": [], "goal": "\u2203(l' :\u03b1 list). (l2 :\u03b1 list) \u29fa REVERSE (l :\u03b1 list) = l2 \u29fa l'"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vl' @ @ C$min$ = @ @ C$list$ APPEND Vl2 Vl @ @ C$list$ APPEND Vl2 @ C$list$ REVERSE Vl'"}, "plain": {"assumptions": [], "goal": "\u2203(l' :\u03b1 list). (l2 :\u03b1 list) \u29fa (l :\u03b1 list) = l2 \u29fa REVERSE l'"}}], "parent": 4, "goal": 0, "by_tactic": "rw[listTheory.MAP_FLAT, listTheory.LENGTH_MAP2, listTheory.oEL_DROP, listTheory.SWAP_REVERSE_SYM, boolTheory.EQ_IMP_THM]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[listTheory.LENGTH_CONS, listTheory.APPEND_EQ_CONS, boolTheory.CONJ_COMM, listTheory.REVERSE_REVERSE, listTheory.REVERSE_SNOC]", "reward": 5}]], "\u2200(x :\u03b1) (l :\u03b1 list). REVERSE (SNOC x l) = x::REVERSE l": [9, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ C$bool$ ! | Vl @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1) (l :\u03b1 list). REVERSE (SNOC x l) = x::REVERSE l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx C$list$ NIL @ @ C$list$ CONS Vx @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE (SNOC x ([] :\u03b1 list)) = x::REVERSE ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). REVERSE (SNOC x (h::(l :\u03b1 list))) = x::REVERSE (h::l)"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). REVERSE (SNOC x (h::(l :\u03b1 list))) = x::REVERSE (h::l)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "REVERSE (SNOC (x :\u03b1) ([] :\u03b1 list)) = [x]"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.REVERSE_DEF, listTheory.SING_HD, listTheory.FRONT_DEF, listTheory.ZIP, boolTheory.MONO_AND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). REVERSE (SNOC x (h::(l :\u03b1 list))) = x::REVERSE (h::l)"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE [x] = x::REVERSE ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.REVERSE_EQ_SING, listTheory.LIST_TO_SET_FILTER, listTheory.LIST_TO_SET_FILTER, listTheory.LENGTH_UNZIP, listTheory.SNOC]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE [x] = x::REVERSE ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ @ C$list$ APPEND @ C$list$ REVERSE Vl @ @ C$list$ CONS Vh C$list$ NIL"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "REVERSE (SNOC (x :\u03b1) ((h :\u03b1)::(l :\u03b1 list))) = x::(REVERSE l \u29fa [h])"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_DEF, listTheory.SING_HD, listTheory.UNZIP, listTheory.ZIP, listTheory.UNZIP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE [x] = x::REVERSE ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "REVERSE (SNOC (x :\u03b1) ((h :\u03b1)::(l :\u03b1 list))) = x::REVERSE (h::l)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, listTheory.MAP, listTheory.TAKE_def, listTheory.TAKE_def, listTheory.UNZIP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vx @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1). REVERSE (SNOC x (l :\u03b1 list)) = x::REVERSE l"], "goal": "\u2200(h :\u03b1) (x :\u03b1). REVERSE (SNOC x (h::(l :\u03b1 list))) = x::REVERSE (h::l)"}}, {"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ SNOC Vx C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE (SNOC x ([] :\u03b1 list)) = [x]"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_DEF, listTheory.TAKE_cons, listTheory.TAKE_def, listTheory.UNZIP, listTheory.UNZIP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ C$list$ REVERSE @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). REVERSE [x] = x::REVERSE ([] :\u03b1 list)"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.SNOC, listTheory.REVERSE_SNOC_DEF, listTheory.UNZIP, listTheory.LIST_TO_SET, listTheory.ZIP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vx @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL @ @ C$list$ CONS Vx C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(x :\u03b1). ([] :\u03b1 list) \u29fa [x] = [x]"}}], "parent": 7, "goal": 0, "by_tactic": "simp[listTheory.REVERSE_DEF, listTheory.LIST_TO_SET, listTheory.MEM_FILTER, listTheory.LENGTH_MAP2, listTheory.FLAT]", "reward": 0.1}, {"content": [], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_DEF, listTheory.FLAT, listTheory.UNZIP, listTheory.ZIP_def, listTheory.APPEND_EQ_SELF]", "reward": 5}]], "\u2200(s :num -> bool). (\u2203(n :num). n \u2208 s) \u21d4 \u2203(n :num). n \u2208 s \u2227 \u2200(m :num). m \u2208 s \u21d2 n \u2264 m": [14, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ? | Vn @ @ C$bool$ IN Vn Vs @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ @ C$bool$ IN Vn Vs @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$bool$ IN Vm Vs @ @ C$arithmetic$ <= Vn Vm"}, "plain": {"assumptions": [], "goal": "\u2200(s :num -> bool). (\u2203(n :num). n \u2208 s) \u21d4 \u2203(n :num). n \u2208 s \u2227 \u2200(m :num). m \u2208 s \u21d2 n \u2264 m"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vs @ @ C$min$ = @ C$bool$ ? | Vn @ Vs Vn @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ Vs Vn @ C$bool$ ! | Vm @ @ C$min$ ==> @ Vs Vm @ @ C$arithmetic$ <= Vn Vm"}, "plain": {"assumptions": [], "goal": "\u2200(s :num -> bool). (\u2203(n :num). s n) \u21d4 \u2203(n :num). s n \u2227 \u2200(m :num). s m \u21d2 n \u2264 m"}}], "parent": 0, "goal": 0, "by_tactic": "fs[boolTheory.FUN_EQ_THM, arithmeticTheory.NOT_SUC_LESS_EQ, boolTheory.IN_DEF, arithmeticTheory.RIGHT_SUB_DISTRIB, arithmeticTheory.ODD_ADD]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vn @ @ C$bool$ IN Vn Vs @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ @ C$bool$ IN Vn Vs @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$bool$ IN Vm Vs @ @ C$arithmetic$ <= Vn Vm"}, "plain": {"assumptions": [], "goal": "(\u2203(n :num). n \u2208 (s :num -> bool)) \u21d4 \u2203(n :num). n \u2208 s \u2227 \u2200(m :num). m \u2208 s \u21d2 n \u2264 m"}}], "parent": 0, "goal": 0, "by_tactic": "rw[boolTheory.literal_case_THM, arithmeticTheory.PRE_SUB, arithmeticTheory.ABS_DIFF_LE_SUM, boolTheory.RES_EXISTS_CONG, arithmeticTheory.SUB_RIGHT_EQ]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vn @ @ C$bool$ IN Vn Vs @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ @ C$bool$ IN Vn Vs @ C$bool$ ! | Vm @ @ C$min$ ==> @ @ C$bool$ IN Vm Vs @ @ @ C$relation$ RTC | Vx | Vy @ @ C$min$ = Vy @ C$num$ SUC Vx Vn Vm"}, "plain": {"assumptions": [], "goal": "(\u2203(n :num). n \u2208 (s :num -> bool)) \u21d4 \u2203(n :num). n \u2208 s \u2227 \u2200(m :num). m \u2208 s \u21d2 (\u03bb(x :num) (y :num). y = SUC x)\ua673 n m"}}], "parent": 2, "goal": 0, "by_tactic": "fs[arithmeticTheory.LESS_OR_EQ_ALT, arithmeticTheory.NOT_LT_ZERO_EQ_ZERO, arithmeticTheory.X_MOD_Y_EQ_X, arithmeticTheory.LT_MULT_LCANCEL, arithmeticTheory.NOT_LESS_EQUAL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$bool$ ? | Vn @ Vs Vn @ C$bool$ ? | Vn @ @ C$bool$ /\\ @ Vs Vn @ C$bool$ ! | Vm @ @ C$min$ ==> @ Vs Vm @ @ C$arithmetic$ <= Vn Vm"}, "plain": {"assumptions": [], "goal": "(\u2203(n :num). (s :num -> bool) n) \u21d4 \u2203(n :num). s n \u2227 \u2200(m :num). s m \u21d2 n \u2264 m"}}], "parent": 2, "goal": 0, "by_tactic": "fs[boolTheory.LET_THM, arithmeticTheory.LESS_IMP_LESS_OR_EQ, boolTheory.IN_DEF, arithmeticTheory.FUNPOW_1, arithmeticTheory.LT_SUB_RCANCEL]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[arithmeticTheory.FORALL_NUM_THM, arithmeticTheory.EXP_EXP_MULT, arithmeticTheory.WOP_measure, arithmeticTheory.LESS_OR_EQ_ALT, arithmeticTheory.num_case_NUMERAL_compute]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l :\u03b1 list). FOLDR f e l = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)": [18, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ C$bool$ ! | Vl @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2) (l :\u03b1 list). FOLDR f e l = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve C$list$ NIL @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e ([] :\u03b1 list) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE ([] :\u03b1 list))"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (l :\u03b1 list) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (h::(l :\u03b1 list)) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE (h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (l :\u03b1 list) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (h::(l :\u03b1 list)) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE (h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.TL_DEF, listTheory.EL_LUPDATE, listTheory.oEL_DROP, listTheory.LIST_BIND_def, listTheory.DROP_TAKE]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl"], "goal": "@ @ C$min$ = @ @ Vf Vh @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ @ C$list$ APPEND @ C$list$ REVERSE Vl @ @ C$list$ CONS Vh C$list$ NIL"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (l :\u03b1 list) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)"], "goal": "(f :\u03b1 -> \u03b2 -> \u03b2) (h :\u03b1) (FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) (e :\u03b2) (REVERSE (l :\u03b1 list))) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l \u29fa [h])"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.ZIP_EQ_NIL, rich_listTheory.ALL_DISTINCT_DROP, listTheory.SUM_SNOC, listTheory.SINGL_APPLY_MAP, listTheory.SINGL_APPLY_MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Ve @ @ C$min$ = @ @ @ C$list$ FOLDR Vf Ve Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl"], "goal": "@ @ C$min$ = @ @ Vf Vh @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ C$list$ REVERSE Vl @ @ @ C$list$ FOLDL | Vx | Vy @ @ Vf Vy Vx Ve @ @ C$list$ SNOC Vh @ C$list$ REVERSE Vl"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2 -> \u03b2) (e :\u03b2). FOLDR f e (l :\u03b1 list) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (REVERSE l)"], "goal": "(f :\u03b1 -> \u03b2 -> \u03b2) (h :\u03b1) (FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) (e :\u03b2) (REVERSE (l :\u03b1 list))) = FOLDL (\u03bb(x :\u03b2) (y :\u03b1). f y x) e (SNOC h (REVERSE l))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.REVERSE_SNOC_DEF, listTheory.EL_simp, listTheory.MAP, listTheory.UNZIP, listTheory.FRONT_CONS]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "fs[listTheory.nub_def, listTheory.FOLDL_SNOC, listTheory.UNZIP, listTheory.EL, listTheory.DROP_def]", "reward": 5}]], "(l1 :\u03b1 list) ++ (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]": [13, [{"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "(l1 :\u03b1 list) ++ (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 ([] :\u03b1 list) = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 ([] :\u03b1 list) = ([] :\u03b1 list) \u2227 l2 = [e]"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": ["(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"], "goal": "\u2200(h :\u03b1). h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 h::l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 h::l1 = ([] :\u03b1 list) \u2227 l2 = [e]"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l1`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"], "goal": "@ C$bool$ ! | Vh @ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND @ @ C$list$ CONS Vh Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": ["(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"], "goal": "\u2200(h :\u03b1). h::(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 h::l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 h::l1 = ([] :\u03b1 list) \u2227 l2 = [e]"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Ve C$list$ NIL C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 [e] = ([] :\u03b1 list) \u2227 l2 = ([] :\u03b1 list) \u2228 l2 = [e]"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.LIST_TO_SET_DEF, listTheory.FLAT_compute, listTheory.FLAT_compute, listTheory.datatype_list, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND C$list$ NIL Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Ve C$list$ NIL C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": [], "goal": "([] :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 [e] = ([] :\u03b1 list) \u2227 l2 = ([] :\u03b1 list) \u2228 l2 = [e]"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": ["(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"], "goal": "(h :\u03b1)::((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = [(e :\u03b1)] \u21d4 h::l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 h::l1 = ([] :\u03b1 list) \u2227 l2 = [e]"}}], "parent": 2, "goal": 0, "by_tactic": "simp[listTheory.LENGTH, listTheory.FLAT_compute, listTheory.NULL_DEF, listTheory.TL_DEF, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"}, "plain": {"assumptions": ["(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"], "goal": "(h :\u03b1)::((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = [(e :\u03b1)] \u21d4 h::l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 h::l1 = ([] :\u03b1 list) \u2227 l2 = [e]"}}], "parent": 3, "goal": 0, "by_tactic": "metis_tac[listTheory.APPEND, listTheory.FOLDR, boolTheory.RES_EXISTS_CONG, listTheory.MAP2, listTheory.MAP2]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$min$ = @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ \\/ @ @ C$bool$ /\\ @ @ C$min$ = Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = Vl1 C$list$ NIL @ @ C$min$ = Vl2 @ @ C$list$ CONS Ve C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$min$ = @ @ C$list$ CONS Vh @ @ C$list$ APPEND Vl1 Vl2 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl1 @ @ C$list$ CONS Ve C$list$ NIL @ @ C$min$ = Vl2 C$list$ NIL"}, "plain": {"assumptions": ["(l1 :\u03b1 list) \u29fa (l2 :\u03b1 list) = [(e :\u03b1)] \u21d4 l1 = [e] \u2227 l2 = ([] :\u03b1 list) \u2228 l1 = ([] :\u03b1 list) \u2227 l2 = [e]"], "goal": "(h :\u03b1)::((l1 :\u03b1 list) \u29fa (l2 :\u03b1 list)) = [(e :\u03b1)] \u21d4 h::l1 = [e] \u2227 l2 = ([] :\u03b1 list)"}}], "parent": 4, "goal": 0, "by_tactic": "simp[listTheory.LENGTH, listTheory.MAP, listTheory.NOT_CONS_NIL, boolTheory.DATATYPE_TAG_THM, listTheory.NULL_APPEND]", "reward": 0.1}, {"content": [], "parent": 5, "goal": 0, "by_tactic": "metis_tac[listTheory.APPEND_eq_NIL, listTheory.TL_DEF, listTheory.APPEND_eq_NIL, listTheory.APPEND_eq_NIL, listTheory.MAP2]", "reward": 5}]], "\u2200(f :\u03b1 -> \u03b2) (ls :\u03b1 list) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ls = MAP f ls ++ a": [47, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Vls @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (ls :\u03b1 list) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ls = MAP f ls ++ a"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list) = MAP f ([] :\u03b1 list) \u29fa a"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (h::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `ls`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (h::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list) = ([] :\u03b2 list) \u29fa a"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, listTheory.MAP, listTheory.CONS_ACYCLIC, listTheory.NOT_CONS_NIL, listTheory.NOT_EVERY]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (h::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (([] :\u03b2 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list))"], "goal": "EL (x :num) (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = EL x (([] :\u03b2 list) \u29fa a)"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.LIST_EQ_REWRITE, listTheory.MAP, listTheory.EVERY_MEM, listTheory.NOT_CONS_NIL, listTheory.LENGTH_EQ_NUM_compute]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (h::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = Va @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "(a :\u03b2 list) = ([] :\u03b2 list) \u29fa a"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.FOLDL, listTheory.MAP, listTheory.FOLDR, boolTheory.SELECT_ELIM_THM, listTheory.MAP2_APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "\u2200(h :\u03b1) (f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (h::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list) = MAP f ([] :\u03b1 list) \u29fa a"}}], "parent": 1, "goal": 0, "by_tactic": "rw[boolTheory.FUN_EQ_THM, listTheory.MAP2_NIL, boolTheory.itself_case_thm, listTheory.MAP_MAP_o, listTheory.MAP2_APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list) = MAP f ([] :\u03b1 list) \u29fa a"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ((h :\u03b1)::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}], "parent": 5, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_EQ_SUM, listTheory.APPEND_eq_NIL, listTheory.MAP2_DEF, listTheory.LENGTH_CONS, listTheory.APPEND_11_LENGTH]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf @ @ C$list$ CONS Vh Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ((h :\u03b1)::(ls :\u03b1 list)) = MAP f (h::ls) \u29fa a"}}, {"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}], "parent": 6, "goal": 0, "by_tactic": "fs[listTheory.LIST_EQ_REWRITE, boolTheory.LEFT_OR_EXISTS_THM, listTheory.MEM_FILTER, listTheory.INDEX_OF_def, boolTheory.ABS_SIMP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "(f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list)) = f h::MAP f ls \u29fa a"}}], "parent": 7, "goal": 0, "by_tactic": "rw[listTheory.MEM_MAP_f, listTheory.FOLDR, listTheory.EXISTS_MEM, listTheory.MAP, listTheory.LENGTH_EQ_NUM_compute]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}], "parent": 7, "goal": 0, "by_tactic": "rw[listTheory.APPEND, listTheory.FOLDR, listTheory.MAP, listTheory.MAP, listTheory.list_size_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LENGTH (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list) \u29fa (a :\u03b2 list)) = LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (MAP f ([] :\u03b1 list) \u29fa a) = EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list))"}}], "parent": 9, "goal": 0, "by_tactic": "fs[listTheory.SUM, boolTheory.EQ_SYM_EQ, listTheory.LIST_EQ_REWRITE, listTheory.LENGTH_CONS, boolTheory.ITSELF_UNIQUE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (([] :\u03b2 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (([] :\u03b2 list) \u29fa a)"}}], "parent": 9, "goal": 0, "by_tactic": "fs[listTheory.MAP, listTheory.MAP, listTheory.SING_HD, listTheory.list_size_def, listTheory.EL]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH a"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list))"], "goal": "EL (x :num) (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = EL x a"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.MAP_EQ_SING, listTheory.EXISTS_DEF, listTheory.SING_HD, listTheory.MAP, listTheory.APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list))"], "goal": "EL (x :num) (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.LENGTH, listTheory.TL_DEF, listTheory.MAP2_NIL, listTheory.APPEND, listTheory.LENGTH_EQ_NUM_compute]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH Va @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (a :\u03b2 list) = LENGTH (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH Va"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx Va @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (a :\u03b2 list)"], "goal": "EL (x :num) (a :\u03b2 list) = EL x (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list) \u29fa a)"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.LENGTH, listTheory.FOLDR, listTheory.MAP2_NIL, listTheory.LENGTH_EQ_NUM_compute, listTheory.APPEND_EQ_SING]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (([] :\u03b2 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND C$list$ NIL Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list))"], "goal": "EL (x :num) (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = EL x (([] :\u03b2 list) \u29fa a)"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.LENGTH, listTheory.MAP, listTheory.LENGTH, listTheory.MAP_TL, listTheory.MAP]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "LENGTH ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list))) = LENGTH (f h::MAP f ls \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va", "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["(x :num) < LENGTH ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list)))", "\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "EL (x :num) ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list))) = EL x (f h::MAP f ls \u29fa a)"}}], "parent": 7, "goal": 0, "by_tactic": "rw[listTheory.EL, listTheory.FOLDR, listTheory.MAP, listTheory.LIST_EQ_REWRITE, listTheory.EXISTS_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ? | Vl1 @ C$bool$ ? | Vl2 @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl1 @ C$list$ LENGTH Va @ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH Vl2 @ C$list$ LENGTH @ @ C$list$ MAP Vf C$list$ NIL @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ APPEND Vl1 Vl2"}, "plain": {"assumptions": [], "goal": "\u2203(l1 :\u03b2 list) (l2 :\u03b2 list). LENGTH l1 = LENGTH (a :\u03b2 list) \u2227 LENGTH l2 = LENGTH (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list)) \u2227 FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list) = l1 \u29fa l2"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": ["(x :num) < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list))"], "goal": "EL (x :num) (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.LENGTH_APPEND, listTheory.APPEND, listTheory.MAP2_NIL, listTheory.LENGTH_EQ_NUM, listTheory.EXISTS_APPEND]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "LENGTH ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list))) = LENGTH (f h::MAP f ls \u29fa a)"}}, {"polished": {"assumptions": ["@ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va", "@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ CONS @ Vf Vh @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["(x :num) < LENGTH ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list)))", "\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "EL (x :num) ((f :\u03b1 -> \u03b2) (h :\u03b1)::(MAP f (ls :\u03b1 list) \u29fa (a :\u03b2 list))) = EL x (f h::MAP f ls \u29fa a)"}}, {"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL"}, "plain": {"assumptions": [], "goal": "LENGTH (MAP (f :\u03b1 -> \u03b2) ([] :\u03b1 list) \u29fa (a :\u03b2 list)) = LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (MAP f ([] :\u03b1 list) \u29fa a) = EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list))"}}], "parent": 16, "goal": 0, "by_tactic": "fs[listTheory.MAP_EQ_SING, boolTheory.EQ_SYM_EQ, listTheory.FLAT_compute, listTheory.APPEND, listTheory.LIST_EQ_REWRITE]", "reward": 0.1}, {"content": [{"polished": {"assumptions": [], "goal": "@ @ C$bool$ /\\ @ @ C$min$ = @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ C$list$ LENGTH @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va @ C$bool$ ! | Vx @ @ C$min$ ==> @ @ C$prim_rec$ < Vx @ C$list$ LENGTH @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$min$ = @ @ C$list$ EL Vx @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va C$list$ NIL @ @ C$list$ EL Vx @ @ C$list$ APPEND @ @ C$list$ MAP Vf C$list$ NIL Va"}, "plain": {"assumptions": [], "goal": "LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ([] :\u03b1 list)) = LENGTH (MAP f ([] :\u03b1 list) \u29fa a) \u2227 \u2200(x :num). x < LENGTH (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) \u21d2 EL x (FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a ([] :\u03b1 list)) = EL x (MAP f ([] :\u03b1 list) \u29fa a)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vf @ C$bool$ ! | Va @ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va Vls @ @ C$list$ APPEND @ @ C$list$ MAP Vf Vls Va"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDR | Vx | Vy @ @ C$list$ CONS @ Vf Vx Vy Va @ @ C$list$ CONS Vh Vls @ @ C$list$ APPEND @ @ C$list$ CONS @ Vf Vh @ @ C$list$ MAP Vf Vls Va"}, "plain": {"assumptions": ["\u2200(f :\u03b1 -> \u03b2) (a :\u03b2 list). FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). f x::y) a (ls :\u03b1 list) = MAP f ls \u29fa a"], "goal": "FOLDR (\u03bb(x :\u03b1) (y :\u03b2 list). (f :\u03b1 -> \u03b2) x::y) (a :\u03b2 list) ((h :\u03b1)::(ls :\u03b1 list)) = f h::MAP f ls \u29fa a"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_CONS, listTheory.APPEND_eq_NIL, listTheory.FLAT_compute, listTheory.NULL, listTheory.MAP]", "reward": 0.1}, {"content": [], "parent": 9, "goal": 0, "by_tactic": "rw[listTheory.MEM_MAP, listTheory.FOLDR, listTheory.APPEND, listTheory.MAP, listTheory.MAP]", "reward": 5}]], "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'": [6, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl @ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(l :\u03b1 list) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). l = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = C$list$ NIL Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb C$list$ NIL @ @ @ C$list$ FOLDL Vf' Vb' Vl'"}, "plain": {"assumptions": [], "goal": "\u2200(l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). ([] :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b ([] :\u03b1 list) = FOLDL f' b' l'"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"}, "plain": {"assumptions": ["\u2200(l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). (l :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'"], "goal": "\u2200(h :\u03b1) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). h::(l :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b (h::l) = FOLDL f' b' l'"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = @ @ C$list$ CONS Vh Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb @ @ C$list$ CONS Vh Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"}, "plain": {"assumptions": ["\u2200(l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). (l :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'"], "goal": "\u2200(h :\u03b1) (l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). h::(l :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b (h::l) = FOLDL f' b' l'"}}], "parent": 1, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_EL_EQN, listTheory.FOLDL, listTheory.LIST_REL_cases, listTheory.FOLDL, listTheory.LIST_REL_cases]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx", "@ C$bool$ ! | Vl' @ C$bool$ ! | Vb @ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$min$ = Vl Vl' @ @ C$bool$ /\\ @ @ C$min$ = Vb Vb' @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl' @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl'"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDL Vf @ @ Vf Vb Vh Vl @ @ @ C$list$ FOLDL Vf' @ @ Vf' Vb Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (a :\u03b2). MEM x ((h :\u03b1)::(l :\u03b1 list)) \u21d2 (f :\u03b2 -> \u03b1 -> \u03b2) a x = (f' :\u03b2 -> \u03b1 -> \u03b2) a x", "\u2200(l' :\u03b1 list) (b :\u03b2) (b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). (l :\u03b1 list) = l' \u2227 b = b' \u2227 (\u2200(x :\u03b1) (a :\u03b2). MEM x l' \u21d2 f a x = f' a x) \u21d2 FOLDL f b l = FOLDL f' b' l'"], "goal": "FOLDL (f :\u03b2 -> \u03b1 -> \u03b2) (f (b :\u03b2) (h :\u03b1)) (l :\u03b1 list) = FOLDL (f' :\u03b2 -> \u03b1 -> \u03b2) (f' b h) l"}}], "parent": 2, "goal": 0, "by_tactic": "rw[listTheory.list_case_def, listTheory.MAP, listTheory.FOLDL, listTheory.MAP, listTheory.FOLDR]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx", "@ C$bool$ ! | Vb' @ C$bool$ ! | Vf @ C$bool$ ! | Vf' @ @ C$min$ ==> @ C$bool$ ! | Vx @ C$bool$ ! | Va @ @ C$min$ ==> @ @ C$bool$ IN Vx @ C$list$ LIST_TO_SET Vl @ @ C$min$ = @ @ Vf Va Vx @ @ Vf' Va Vx @ @ C$min$ = @ @ @ C$list$ FOLDL Vf Vb' Vl @ @ @ C$list$ FOLDL Vf' Vb' Vl"], "goal": "@ @ C$min$ = @ @ @ C$list$ FOLDL Vf @ @ Vf Vb Vh Vl @ @ @ C$list$ FOLDL Vf' @ @ Vf' Vb Vh Vl"}, "plain": {"assumptions": ["\u2200(x :\u03b1) (a :\u03b2). MEM x ((h :\u03b1)::(l :\u03b1 list)) \u21d2 (f :\u03b2 -> \u03b1 -> \u03b2) a x = (f' :\u03b2 -> \u03b1 -> \u03b2) a x", "\u2200(b' :\u03b2) (f :\u03b2 -> \u03b1 -> \u03b2) (f' :\u03b2 -> \u03b1 -> \u03b2). (\u2200(x :\u03b1) (a :\u03b2). MEM x (l :\u03b1 list) \u21d2 f a x = f' a x) \u21d2 FOLDL f b' l = FOLDL f' b' l"], "goal": "FOLDL (f :\u03b2 -> \u03b1 -> \u03b2) (f (b :\u03b2) (h :\u03b1)) (l :\u03b1 list) = FOLDL (f' :\u03b2 -> \u03b1 -> \u03b2) (f' b h) l"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_NIL, boolTheory.PULL_FORALL, boolTheory.COND_RATOR, listTheory.SUM, boolTheory.itself_Axiom]", "reward": 0.1}, {"content": [], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.LIST_REL_NIL, boolTheory.PULL_FORALL, boolTheory.NOT_EXISTS_THM, listTheory.LIST_TO_SET, listTheory.SUM]", "reward": 5}]], "\u2200(m :num) (n :num) (l :\u03b1 list). m + n = LENGTH l \u21d2 BUTLASTN m l ++ DROP n l = l": [28, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ C$bool$ ! | Vl @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num) (l :\u03b1 list). m + n = LENGTH l \u21d2 BUTLASTN m l ++ DROP n l = l"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH C$list$ NIL @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm C$list$ NIL @ @ C$list$ DROP Vn C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(m :num) (n :num). m + n = LENGTH ([] :\u03b1 list) \u21d2 BUTLASTN m ([] :\u03b1 list) \u29fa DROP n ([] :\u03b1 list) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "\u2200(h :\u03b1) (m :num) (n :num). m + n = LENGTH (h::(l :\u03b1 list)) \u21d2 BUTLASTN m (h::l) \u29fa DROP n (h::l) = h::l"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "\u2200(h :\u03b1) (m :num) (n :num). m + n = LENGTH (h::(l :\u03b1 list)) \u21d2 BUTLASTN m (h::l) \u29fa DROP n (h::l) = h::l"}}, {"polished": {"assumptions": [], "goal": "@ @ C$min$ = @ @ C$rich_list$ BUTLASTN C$num$ 0 C$list$ NIL C$list$ NIL"}, "plain": {"assumptions": [], "goal": "BUTLASTN (0 :num) ([] :\u03b1 list) = ([] :\u03b1 list)"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.SHORTLEX_def, rich_listTheory.IS_SUFFIX_CONS, rich_listTheory.LASTN_def, arithmeticTheory.DIV_MULT, rich_listTheory.LASTN_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH @ @ C$list$ CONS Vh Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "\u2200(h :\u03b1) (m :num) (n :num). m + n = LENGTH (h::(l :\u03b1 list)) \u21d2 BUTLASTN m (h::l) \u29fa DROP n (h::l) = h::l"}}], "parent": 1, "goal": 0, "by_tactic": "simp[listTheory.EXISTS_LIST_EQ_MAP, rich_listTheory.BUTLASTN_def, rich_listTheory.LASTN_def, rich_listTheory.BUTLASTN_def, rich_listTheory.BUTLASTN_def]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP Vn @ @ C$list$ CONS Vh Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "BUTLASTN (m :num) ((h :\u03b1)::(l :\u03b1 list)) \u29fa DROP (n :num) (h::l) = h::l"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.INJ_MAP_EQ_IFF, listTheory.LUPDATE_SNOC, rich_listTheory.DROP_LENGTH_NIL, listTheory.OPT_MMAP_def, rich_listTheory.IS_SUFFIX]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "BUTLASTN (m :num) ((h :\u03b1)::(l :\u03b1 list)) \u29fa (if (n :num) = (0 :num) then h::l else DROP (n \u2212 (1 :num)) l) = h::l"}}], "parent": 3, "goal": 0, "by_tactic": "fs[rich_listTheory.LASTN_BUTLASTN, rich_listTheory.TL_T_def, listTheory.oEL_def, listTheory.TL_DEF, listTheory.DROP_def]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm C$num$ 0 @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["(m :num) + (0 :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "BUTLASTN (m :num) ((h :\u03b1)::(l :\u03b1 list)) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0", "@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num)", "(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "BUTLASTN (m :num) ((h :\u03b1)::(l :\u03b1 list)) \u29fa DROP ((n :num) \u2212 (1 :num)) l = h::l"}}], "parent": 5, "goal": 0, "by_tactic": "rw[rich_listTheory.NOT_SNOC_NIL, listTheory.LIST_REL_SPLIT1, listTheory.LIST_TO_SET_GENLIST, listTheory.TAKE_def, listTheory.LENGTH]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm C$num$ 0 @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ @ C$rich_list$ SEG @ @ C$arithmetic$ - @ C$num$ SUC @ C$list$ LENGTH Vl Vm C$num$ 0 @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["(m :num) + (0 :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (SUC (LENGTH (l :\u03b1 list)) \u2212 (m :num)) (0 :num) ((h :\u03b1)::l) = ([] :\u03b1 list)"}}, {"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0", "@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ @ C$rich_list$ SEG @ @ C$arithmetic$ - @ C$num$ SUC @ C$list$ LENGTH Vl Vm C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num)", "(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (SUC (LENGTH (l :\u03b1 list)) \u2212 (m :num)) (0 :num) ((h :\u03b1)::l) \u29fa DROP ((n :num) \u2212 (1 :num)) l = h::l"}}], "parent": 5, "goal": 0, "by_tactic": "rw[rich_listTheory.BUTLASTN_SEG, listTheory.LIST_REL_SPLIT2, arithmeticTheory.PRE_SUB, listTheory.TAKE_def, listTheory.LIST_TO_SET]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0", "@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ @ C$rich_list$ SEG @ @ C$arithmetic$ - @ C$num$ SUC @ C$list$ LENGTH Vl Vm C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num)", "(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (SUC (LENGTH (l :\u03b1 list)) \u2212 (m :num)) (0 :num) ((h :\u03b1)::l) \u29fa DROP ((n :num) \u2212 (1 :num)) l = h::l"}}, {"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm C$num$ 0 @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ @ C$rich_list$ SEG @ @ C$arithmetic$ - @ C$num$ SUC @ @ C$list$ LEN Vl C$num$ 0 Vm C$num$ 0 @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["(m :num) + (0 :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (SUC (LEN (l :\u03b1 list) (0 :num)) \u2212 (m :num)) (0 :num) ((h :\u03b1)::l) = ([] :\u03b1 list)"}}], "parent": 7, "goal": 0, "by_tactic": "rw[rich_listTheory.AND_EL_DEF, listTheory.LIST_REL_APPEND_IMP, listTheory.LENGTH_LEN, listTheory.DROP_def, listTheory.REVERSE_DEF]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Vn C$num$ 0", "@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ @ @ C$rich_list$ SEG @ @ C$arithmetic$ - @ C$num$ SUC @ C$list$ LENGTH Vl Vm C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(n :num) \u2260 (0 :num)", "(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (SUC (LENGTH (l :\u03b1 list)) \u2212 (m :num)) (0 :num) ((h :\u03b1)::l) \u29fa DROP ((n :num) \u2212 (1 :num)) l = h::l"}}, {"polished": {"assumptions": ["@ @ C$min$ = Vm @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm @ C$bool$ ! | Vn @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ @ C$rich_list$ BUTLASTN Vm Vl @ @ C$list$ DROP Vn Vl Vl"], "goal": "@ @ C$min$ = @ @ @ C$rich_list$ SEG C$num$ 0 C$num$ 0 @ @ C$list$ CONS Vh Vl C$list$ NIL"}, "plain": {"assumptions": ["(m :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m :num) (n :num). m + n = LENGTH (l :\u03b1 list) \u21d2 BUTLASTN m l \u29fa DROP n l = l"], "goal": "SEG (0 :num) (0 :num) ((h :\u03b1)::(l :\u03b1 list)) = ([] :\u03b1 list)"}}], "parent": 7, "goal": 0, "by_tactic": "fs[listTheory.LENGTH_REVERSE, rich_listTheory.TL_T_def, listTheory.SUM_SUM_ACC, rich_listTheory.IS_SUBLIST_REVERSE, arithmeticTheory.ADD_EQ_SUB]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ @ C$min$ = @ @ C$arithmetic$ + Vm Vn @ C$num$ SUC @ C$list$ LENGTH Vl", "@ C$bool$ ! | Vm' @ C$bool$ ! | Vn' @ @ C$min$ ==> @ @ C$min$ = @ @ C$arithmetic$ + Vm' Vn' @ C$list$ LENGTH Vl @ @ C$min$ = @ @ C$list$ APPEND @ C$list$ REVERSE @ @ C$list$ DROP Vm' @ C$list$ REVERSE Vl @ @ C$list$ DROP Vn' Vl Vl"], "goal": "@ @ C$min$ = @ @ C$list$ APPEND @ C$list$ REVERSE @ @ C$list$ DROP Vm @ @ C$list$ APPEND @ C$list$ REVERSE Vl @ @ C$list$ CONS Vh C$list$ NIL @ @ @ C$bool$ COND @ @ C$min$ = Vn C$num$ 0 @ @ C$list$ CONS Vh Vl @ @ C$list$ DROP @ @ C$arithmetic$ - Vn @ C$arithmetic$ NUMERAL @ C$arithmetic$ BIT1 C$arithmetic$ ZERO Vl @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(m :num) + (n :num) = SUC (LENGTH (l :\u03b1 list))", "\u2200(m' :num) (n' :num). m' + n' = LENGTH (l :\u03b1 list) \u21d2 REVERSE (DROP m' (REVERSE l)) \u29fa DROP n' l = l"], "goal": "REVERSE (DROP (m :num) (REVERSE (l :\u03b1 list) \u29fa [(h :\u03b1)])) \u29fa (if (n :num) = (0 :num) then h::l else DROP (n \u2212 (1 :num)) l) = h::l"}}], "parent": 5, "goal": 0, "by_tactic": "fs[boolTheory.BOOL_FUN_INDUCT, rich_listTheory.TL_T_def, rich_listTheory.BUTLASTN_def, listTheory.SINGL_APPLY_MAP, listTheory.list_CASES]", "reward": 0.1}, {"content": [], "parent": 10, "goal": 0, "by_tactic": "rw[rich_listTheory.MEM_FOLDL, rich_listTheory.DROP_APPEND1, rich_listTheory.LASTN_LENGTH_APPEND, listTheory.APPEND, listTheory.isPREFIX_THM]", "reward": 5}]], "\u2200(e :\u03b1) (l :\u03b1 list) (h :\u03b1). MEM e l \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))": [35, [{"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vl @ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (l :\u03b1 list) (h :\u03b1). MEM e l \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))"}}], "parent": null, "goal": null, "by_tactic": "", "reward": null}, {"content": [{"polished": {"assumptions": [], "goal": "@ C$bool$ ! | Ve @ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET C$list$ NIL @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh C$list$ NIL @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh C$list$ NIL"}, "plain": {"assumptions": [], "goal": "\u2200(e :\u03b1) (h :\u03b1). MEM e ([] :\u03b1 list) \u2227 e \u2260 LAST [h] \u21d2 MEM e (FRONT [h])"}}, {"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh' @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh' @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (h :\u03b1). MEM e (l :\u03b1 list) \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (h' :\u03b1). MEM e (h::(l :\u03b1 list)) \u2227 e \u2260 LAST (h'::h::l) \u21d2 MEM e (FRONT (h'::h::l))"}}], "parent": 0, "goal": 0, "by_tactic": "Induct_on `l`", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ! | Ve @ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"], "goal": "@ C$bool$ ! | Vh @ C$bool$ ! | Ve @ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ @ C$list$ CONS Vh Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh' @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh' @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["\u2200(e :\u03b1) (h :\u03b1). MEM e (l :\u03b1 list) \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))"], "goal": "\u2200(h :\u03b1) (e :\u03b1) (h' :\u03b1). MEM e (h::(l :\u03b1 list)) \u2227 e \u2260 LAST (h'::h::l) \u21d2 MEM e (FRONT (h'::h::l))"}}], "parent": 1, "goal": 0, "by_tactic": "rw[listTheory.EL_MAP, listTheory.TAKE_def, listTheory.EVERY_SIMP, listTheory.LENGTH, listTheory.oEL_DROP]", "reward": 0.2}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh Vl", "@ @ C$min$ = Ve Vh", "@ C$bool$ ! | Ve @ C$bool$ ! | Vh @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ @ C$min$ = Ve @ C$list$ LAST @ @ C$list$ CONS Vh Vl @ @ C$bool$ IN Ve @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vh Vh' @ @ C$bool$ IN Vh @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(e :\u03b1) \u2260 LAST ((h :\u03b1)::(l :\u03b1 list))", "(e :\u03b1) = (h :\u03b1)", "\u2200(e :\u03b1) (h :\u03b1). MEM e (l :\u03b1 list) \u2227 e \u2260 LAST (h::l) \u21d2 MEM e (FRONT (h::l))"], "goal": "(h :\u03b1) = (h' :\u03b1) \u2228 MEM h (FRONT (h::(l :\u03b1 list)))"}}], "parent": 2, "goal": 0, "by_tactic": "fs[listTheory.LENGTH, listTheory.nub_append, listTheory.SNOC_CASES, listTheory.LIST_TO_SET, listTheory.LAST_CONS]", "reward": 0.1}, {"content": [{"polished": {"assumptions": ["@ C$bool$ ~ @ @ C$min$ = Ve @ @ @ C$bool$ COND @ @ C$min$ = Vl C$list$ NIL Vh @ C$list$ LAST Vl", "@ @ C$min$ = Ve Vh", "@ C$bool$ ! | Ve' @ C$bool$ ! | Vh' @ @ C$min$ ==> @ @ C$bool$ /\\ @ @ C$bool$ IN Ve' @ C$list$ LIST_TO_SET Vl @ C$bool$ ~ @ @ C$min$ = Ve' @ @ @ C$bool$ COND @ @ C$min$ = Vl C$list$ NIL Vh' @ C$list$ LAST Vl @ @ C$bool$ IN Ve' @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh' Vl"], "goal": "@ @ C$bool$ \\/ @ @ C$min$ = Vh Vh' @ @ C$bool$ IN Vh @ C$list$ LIST_TO_SET @ C$list$ FRONT @ @ C$list$ CONS Vh Vl"}, "plain": {"assumptions": ["(e :\u03b1) \u2260 if (l :\u03b1 list) = ([] :\u03b1 list) then (h :\u03b1) else LAST l", "(e :\u03b1) = (h :\u03b1)", "\u2200(e' :\u03b1) (h' :\u03b1). MEM e' (l :\u03b1 list) \u2227 e' \u2260 (if l = ([] :\u03b1 list) then h' else LAST l) \u21d2 MEM e' (FRONT (h'::l))"], "goal": "(h :\u03b1) = (h' :\u03b1) \u2228 MEM h (FRONT (h::(l :\u03b1 list)))"}}], "parent": 3, "goal": 0, "by_tactic": "fs[listTheory.SNOC_CASES, listTheory.LAST_DEF, listTheory.REVERSE_SNOC, listTheory.SUM, listTheory.EL]", "reward": 0.1}, {"content": [], "parent": 4, "goal": 0, "by_tactic": "metis_tac[listTheory.DROP_cons, listTheory.ZIP_GENLIST, boolTheory.CONJ_COMM, listTheory.MEM, listTheory.FRONT_DEF]", "reward": 5}]]}